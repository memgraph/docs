<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.3">
<link rel="search" type="application/opensearchdescription+xml" title="Memgraph Docs" href="/opensearch.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Encode+Sans+Condensed:500,600">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400, 500,600">
<script src="https://docs.memgraph.com/js/load-analytics.js"></script>
<script src="https://kit.fontawesome.com/3a9f2eb5b9.js"></script><title data-react-helmet="true">NetworkX Algorithms | Memgraph Docs</title><meta data-react-helmet="true" property="og:url" content="https://docs.memgraph.com/memgraph/1.3.0/reference-guide/networkx/nxalg"><meta data-react-helmet="true" name="docsearch:language" content="en"><meta data-react-helmet="true" name="docsearch:version" content="1.3.0"><meta data-react-helmet="true" name="docsearch:docusaurus_tag" content="docs-memgraph-1.3.0"><meta data-react-helmet="true" property="og:title" content="NetworkX Algorithms | Memgraph Docs"><meta data-react-helmet="true" name="description" content="In addition to standalone community graph algorithms implemented as Python modules,"><meta data-react-helmet="true" property="og:description" content="In addition to standalone community graph algorithms implemented as Python modules,"><link data-react-helmet="true" rel="shortcut icon" href="/img/social-logo-round-corners.png"><link data-react-helmet="true" rel="canonical" href="https://docs.memgraph.com/memgraph/1.3.0/reference-guide/networkx/nxalg"><link data-react-helmet="true" rel="alternate" href="https://docs.memgraph.com/memgraph/1.3.0/reference-guide/networkx/nxalg" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://docs.memgraph.com/memgraph/1.3.0/reference-guide/networkx/nxalg" hreflang="x-default"><link data-react-helmet="true" rel="preconnect" href="https://BH4D9OD16A-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.ebe12304.css">
<link rel="preload" href="/assets/js/runtime~main.e0378192.js" as="script">
<link rel="preload" href="/assets/js/main.408798e3.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/memgraph-logo-500x380.png" alt="Memgraph Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/memgraph-logo-500x380.png" alt="Memgraph Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">Docs</b></a><div class="navbar__item dropdown dropdown--hoverable dropdown--left"><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/memgraph/overview">Memgraph DB</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/memgraph/getting-started">Getting started</a></li><li><a class="dropdown__link" href="/memgraph/getting-started/installation">Installation</a></li><li><a class="dropdown__link" href="/memgraph/database-functionalities">Database functionalities</a></li><li><a class="dropdown__link" href="/memgraph/getting-started/connecting-applications">Building applications</a></li><li><a class="dropdown__link" href="/memgraph/reference-guide">Reference guide</a></li></ul></div><a class="navbar__item navbar__link" href="/memgraph-lab/">Memgraph Lab</a><div class="navbar__item dropdown dropdown--hoverable dropdown--left"><a class="navbar__item navbar__link" href="/cypher-manual/">Cypher manual</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/cypher-manual/">Overview</a></li><li><a class="dropdown__link" href="/cypher-manual/functions">Functions</a></li><li><a class="dropdown__link" href="/cypher-manual/clauses">Clauses</a></li><li><a class="dropdown__link" href="/cypher-manual/other-features">Other features</a></li><li><a class="dropdown__link" href="/cypher-manual/differences">Differences</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable dropdown--left"><a class="navbar__item navbar__link" href="/mage">MAGE</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/mage">Overview</a></li><li><a class="dropdown__link" href="/mage/installation">Installation</a></li><li><a class="dropdown__link" href="/mage/usage/calling-procedures">Usage</a></li><li><a class="dropdown__link" href="/mage/contributing">Contributing</a></li><li><a class="dropdown__link" href="/mage/getting-help">Getting help</a></li></ul></div><a class="navbar__item navbar__link" href="/help-center">Help Center</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__item navbar__link" href="/memgraph/1.3.0/overview">1.3.0</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/memgraph/next/overview">Unreleased 🚧</a></li><li><a class="dropdown__link" href="/memgraph/reference-guide/networkx/nxalg">1.5.0</a></li><li><a class="dropdown__link" href="/memgraph/1.4.0/reference-guide/networkx/nxalg">1.4.0</a></li><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/memgraph/1.3.0/reference-guide/networkx/nxalg">1.3.0</a></li></ul></div><a href="https://github.com/memgraph" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div><div class="searchBox_1Doo"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/memgraph-logo-500x380.png" alt="Memgraph Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/memgraph-logo-500x380.png" alt="Memgraph Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">Docs</b></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a aria-current="page" class="menu__link menu__link--sublist navbar__link--active" role="button" href="/memgraph/overview">Memgraph DB</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/memgraph/getting-started">Getting started</a></li><li class="menu__list-item"><a class="menu__link" href="/memgraph/getting-started/installation">Installation</a></li><li class="menu__list-item"><a class="menu__link" href="/memgraph/database-functionalities">Database functionalities</a></li><li class="menu__list-item"><a class="menu__link" href="/memgraph/getting-started/connecting-applications">Building applications</a></li><li class="menu__list-item"><a class="menu__link" href="/memgraph/reference-guide">Reference guide</a></li></ul></li><li class="menu__list-item"><a class="menu__link" href="/memgraph-lab/">Memgraph Lab</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" role="button" href="/cypher-manual/">Cypher manual</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/cypher-manual/">Overview</a></li><li class="menu__list-item"><a class="menu__link" href="/cypher-manual/functions">Functions</a></li><li class="menu__list-item"><a class="menu__link" href="/cypher-manual/clauses">Clauses</a></li><li class="menu__list-item"><a class="menu__link" href="/cypher-manual/other-features">Other features</a></li><li class="menu__list-item"><a class="menu__link" href="/cypher-manual/differences">Differences</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" role="button" href="/mage">MAGE</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/mage">Overview</a></li><li class="menu__list-item"><a class="menu__link" href="/mage/installation">Installation</a></li><li class="menu__list-item"><a class="menu__link" href="/mage/usage/calling-procedures">Usage</a></li><li class="menu__list-item"><a class="menu__link" href="/mage/contributing">Contributing</a></li><li class="menu__list-item"><a class="menu__link" href="/mage/getting-help">Getting help</a></li></ul></li><li class="menu__list-item"><a class="menu__link" href="/help-center">Help Center</a></li><li class="menu__list-item"><a role="button" class="menu__link menu__link--sublist">Versions</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/memgraph/next/overview">Unreleased 🚧</a></li><li class="menu__list-item"><a class="menu__link" href="/memgraph/reference-guide/networkx/nxalg">1.5.0</a></li><li class="menu__list-item"><a class="menu__link" href="/memgraph/1.4.0/reference-guide/networkx/nxalg">1.4.0</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active" href="/memgraph/1.3.0/reference-guide/networkx/nxalg">1.3.0</a></li></ul></li><li class="menu__list-item"><a href="https://github.com/memgraph" target="_blank" rel="noopener noreferrer" class="menu__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu menu--responsive thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA" aria-label="Sidebar navigation"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/memgraph/1.3.0/overview">Overview</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Getting started</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/getting-started">Where to start?</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">Installation</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/getting-started/installation">Installation overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/getting-started/installation/docker-installation">Docker (Windows, Linux, macOS)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/getting-started/installation/debian-installation">Debian GNU/Linux</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/getting-started/installation/rpm-installation">RPM package</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">Querying the database</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/getting-started/querying">Querying the database</a></li><li class="menu__list-item"><a href="https://docs.memgraph.com/memgraph-lab" target="_blank" rel="noopener noreferrer" class="menu__link" tabindex="-1"><span>Memgraph Lab<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="menu__list-item"><a href="https://playground.memgraph.com/" target="_blank" rel="noopener noreferrer" class="menu__link" tabindex="-1"><span>Memgraph Playground<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">Building applications</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/getting-started/connecting-applications">Building applications</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/getting-started/connecting-applications/python">Python</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/getting-started/connecting-applications/rust">Rust</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/getting-started/connecting-applications/c-sharp">C#</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/getting-started/connecting-applications/java">Java</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/getting-started/connecting-applications/go">Go</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/getting-started/connecting-applications/javascript">JavaScript</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Tutorials</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/tutorials/tutorials">Tutorials overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/tutorials/analyzing-ted-talks">Analyzing TED Talks</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/tutorials/backpacking-through-europe">Backpacking through Europe</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/tutorials/exploring-the-european-road-network">Exploring the European road network</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/tutorials/football-transfers">Football transfers</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/tutorials/graphing-the-premier-league">Graphing the Premier League</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/tutorials/marvel-universe">Marvel Comic Universe social network</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/tutorials/movie-recommendation">Movie recommendation system</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/tutorials/got-deaths">Game of Thrones deaths</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/tutorials/social-network-analysis">Social network analysis with NetworkX</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/tutorials/understanding-music-with-modules">Understanding music (with query modules)</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Database functionalities</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/database-functionalities">Database functionalities overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/database-functionalities/import-data">Import data</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/database-functionalities/inspecting-queries">Inspecting queries</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/database-functionalities/profiling-queries">Profiling queries</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/database-functionalities/tensorflow-setup">TensorFlow Op</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/reference-guide/backup">Backup</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">Enforcing constraints</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/database-functionalities/constraints/existence-constraint">Existence constraint</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/database-functionalities/constraints/uniqueness-constraint">Uniqueness constraint</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">Query modules</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/database-functionalities/query-modules/built-in-query-modules">Built-in query modules</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/database-functionalities/query-modules/load-call-query-modules">Load and call custom query modules</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/database-functionalities/query-modules/implement-query-modules">Implement custom query modules</a></li></ul></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/database-functionalities/manage-user-privileges">User privileges (Enterprise)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/database-functionalities/manage-users-using-ldap">Authentication and authorization (Enterprise)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/database-functionalities/replication">Replication (Enterprise)</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">Reference guide</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/memgraph/1.3.0/reference-guide">Reference guide overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/memgraph/1.3.0/reference-guide/configuration">Memgraph configuration</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/memgraph/1.3.0/reference-guide/indexing">Indexing</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/memgraph/1.3.0/reference-guide/graph-algorithms">Graph algorithms</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/memgraph/1.3.0/reference-guide/tensorflow">TensorFlow Op</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/memgraph/1.3.0/reference-guide/backup">Backup</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">Query modules</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/reference-guide/query-modules">Query modules</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/reference-guide/query-modules/c-api">C API</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/reference-guide/query-modules/python-api">Python API</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">NetworkX</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/memgraph/1.3.0/reference-guide/networkx">NetworkX overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/memgraph/1.3.0/reference-guide/networkx/graph-analyzer">Graph Analyzer</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/memgraph/1.3.0/reference-guide/networkx/nxalg">NetworkX Algorithms</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/memgraph/1.3.0/reference-guide/networkx/wcc">Weakly Connected Components</a></li></ul></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/memgraph/1.3.0/reference-guide/security">Security (Enterprise)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/memgraph/1.3.0/reference-guide/auth-module">Auth module (Enterprise)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/memgraph/1.3.0/reference-guide/ldap-security">LDAP Security (Enterprise)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/memgraph/1.3.0/reference-guide/audit-log">Audit log (Enterprise)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/memgraph/1.3.0/reference-guide/replication">Replication (Enterprise)</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Concepts</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/concepts">Concepts overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/concepts/storage">Storage</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/concepts/graph-algorithms">Graph algorithms</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/concepts/indexing">Indexing</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/concepts/replication">Replication</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Drivers</a><ul class="menu__list"><li class="menu__list-item"><a href="https://github.com/memgraph/mgclient" target="_blank" rel="noopener noreferrer" class="menu__link" tabindex="-1"><span>C/C++<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="menu__list-item"><a href="https://github.com/memgraph/mgconsole" target="_blank" rel="noopener noreferrer" class="menu__link" tabindex="-1"><span>CLI Console<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="menu__list-item"><a href="https://github.com/memgraph/pymgclient" target="_blank" rel="noopener noreferrer" class="menu__link" tabindex="-1"><span>Python<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="menu__list-item"><a href="https://github.com/memgraph/rsmgclient" target="_blank" rel="noopener noreferrer" class="menu__link" tabindex="-1"><span>Rust<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></li><li class="menu__list-item"><a class="menu__link" href="/memgraph/1.3.0/upcoming-features">Upcoming features</a></li><li class="menu__list-item"><a class="menu__link" href="/memgraph/1.3.0/changelog">Changelog</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Getting help</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/getting-help/getting-help">Getting help</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/1.3.0/getting-help/faq">FAQ</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="alert alert--warning margin-bottom--md" role="alert"><div>This is documentation for Memgraph Docs <b>1.3.0</b>, which is no longer actively maintained.</div><div class="margin-top--md">For up-to-date documentation, see the <b><a href="/memgraph/reference-guide/networkx/nxalg">latest version</a></b> (1.5.0).</div></div><div class="docItemContainer_33ec"><article><span class="badge badge--secondary">Version: 1.3.0</span><div class="markdown"><header><h1 class="h1Heading_27L5">NetworkX Algorithms</h1></header><p>In addition to standalone community graph algorithms implemented as Python modules,
we implemented a module providing NetworkX integration with Memgraph.
This module, named <strong>nxalg</strong>, provides a comprehensive set of thin wrappers
around most of the algorithms present in the NetworkX package.
The wrapper functions now have the capability to create a NetworkX
compatible graph-like object that can stream the native database graph
directly saving on memory usage significantly.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="all_shortest_pathsctx-source-target-weight-method"></a><code>all_shortest_paths(ctx, source, target, weight, method)</code><a class="hash-link" href="#all_shortest_pathsctx-source-target-weight-method" title="Direct link to heading">#</a></h2><p>Compute all shortest simple paths in the graph.</p><p>A simple path is a path with no repeated nodes.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>source</strong> (<em>mgp.Vertex</em>) – Starting node for the path.</li></ul><ul><li><strong>target</strong> (<em>mgp.Vertex</em>) – Ending node for the path.</li></ul><ul><li><strong>weight</strong> (<em>mgp.Nullable[str]</em>) – (default=None)
If <code>None</code>, every edge has weight/distance/cost 1.
If a string, use this edge attribute as the edge weight.
Any edge attribute not present defaults to 1.</li></ul><ul><li><strong>method</strong> (<em>str</em>) – (default=’dijkstra’)
The algorithm to use to compute the path lengths.
Supported options: ‘dijkstra’, ‘bellman-ford’.
Other inputs produce a ValueError.
If <code>weight</code> is <code>None</code>, unweighted graph methods are used, and this
suggestion is ignored.</li></ul><p><strong>Returns</strong></p><p>A list of all paths between source and target.</p><p><strong>Return type</strong></p><p>mgp.Record(paths=mgp.List[mgp.List[mgp.Vertex]])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="all_simple_pathsctx-source-target-cutoff"></a><code>all_simple_paths(ctx, source, target, cutoff)</code><a class="hash-link" href="#all_simple_pathsctx-source-target-cutoff" title="Direct link to heading">#</a></h2><p>Returns all simple paths in the graph <code>G</code> from source to target.</p><p>A simple path is a path with no repeated nodes.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>source</strong> (<em>mgp.Vertex</em>) – Starting node for the path.</li></ul><ul><li><strong>target</strong> (<em>mgp.Vertex</em>) – Ending node for the path.</li></ul><ul><li><strong>cutoff</strong> (<em>mgp.Nullable[int]</em>) – (default=None)
Depth to stop the search. Only paths of <code>length &lt;= cutoff</code> are returned.</li></ul><p><strong>Returns</strong></p><p>A list of simple path lists. If there are no paths
between the source and target within the given cutoff there is no output.</p><p><strong>Return type</strong></p><p>mgp.Record(paths=mgp.List[mgp.List[mgp.Vertex]])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="ancestorsctx-source"></a><code>ancestors(ctx, source)</code><a class="hash-link" href="#ancestorsctx-source" title="Direct link to heading">#</a></h2><p>Returns all nodes having a path to <code>source</code> in <code>G</code>.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>source</strong> (<em>node</em>) – A node in <code>G</code>.</li></ul><p><strong>Returns</strong></p><p>The ancestors of source in <code>G</code>.</p><p><strong>Return type</strong></p><p>mgp.Record(ancestors=mgp.List[mgp.Vertex])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="betweenness_centralityctx-k-normalized-weight-endpoints-seed"></a><code>betweenness_centrality(ctx, k, normalized, weight, endpoints, seed)</code><a class="hash-link" href="#betweenness_centralityctx-k-normalized-weight-endpoints-seed" title="Direct link to heading">#</a></h2><p>Compute the shortest-path betweenness centrality for nodes.</p><p><em>Betweenness centrality</em> is a measure of centrality in a graph based on shortest
paths. Centrality identifies the most important nodes within a graph.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>k</strong> (<em>mgp.Nullable[str]</em>) – (default=None)
If <code>k</code> is not <code>None</code>, use <code>k</code> node samples to estimate betweenness.
The value of <code>k &lt;= n</code> where <code>n</code> is the number of nodes in the graph.
Higher values give a better approximation.</li></ul><ul><li><strong>normalized</strong> (<em>bool</em>) – (default=True)
If <code>True</code> the betweenness values are normalized by <code>2/((n-1)(n-2))</code>
for graphs, and <code>1/((n-1)(n-2))</code> for directed graphs where <code>n</code>
is the number of nodes in <code>G</code>.</li></ul><ul><li><strong>weight</strong> (<em>mgp.Nullable[str]</em>) – (default=None)
If <code>None</code>, all edge weights are considered equal.
Otherwise holds the name of the edge attribute used as weight.</li></ul><ul><li><strong>endpoints</strong> (<em>bool</em>) – (default=False)
If <code>True</code>, includes the endpoints in the shortest path counts.</li></ul><ul><li><strong>seed</strong> (<em>mgp.Nullable[int]</em>) – (default=None)
Indicator of random number generation state.
Note that this is only used if <code>k</code> is not <code>None</code>.</li></ul><p><strong>Returns</strong></p><p>Dictionary of nodes with betweenness centrality as the value.</p><p><strong>Return type</strong></p><p>mgp.Record(node=mgp.Vertex, betweenness=mgp.Number)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="bfs_edgesctx-source-reverse-depth_limit"></a><code>bfs_edges(ctx, source, reverse, depth_limit)</code><a class="hash-link" href="#bfs_edgesctx-source-reverse-depth_limit" title="Direct link to heading">#</a></h2><p>Iterate over edges in a breadth-first-search starting at source.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>source</strong> (<em>mgp.Vertex</em>) – Specify starting node for breadth-first search; this function
iterates over only those edges in the component reachable from
this node.</li></ul><ul><li><strong>reverse</strong> (<em>bool</em>) – (default=False)
If <code>True</code>, traverse a directed graph in the reverse direction.</li></ul><ul><li><strong>depth_limit</strong> (<em>mgp.Nullable[int]</em>) – (default=None)
Specify the maximum search depth.</li></ul><p><strong>Returns</strong></p><p>A list of edges in the breadth-first-search.</p><p><strong>Return type</strong></p><p>mgp.Record(edges=mgp.List[mgp.Edge])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="bfs_predecessorsctx-source-depth_limit"></a><code>bfs_predecessors(ctx, source, depth_limit)</code><a class="hash-link" href="#bfs_predecessorsctx-source-depth_limit" title="Direct link to heading">#</a></h2><p>Returns an iterator of predecessors in breadth-first-search from source.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>source</strong> (<em>mgp.Vertex</em>) – Specify starting node for breadth-first search.</li></ul><ul><li><strong>depth_limit</strong> (<em>mgp.Nullable[int]</em>) – (default=None)
Specify the maximum search depth.</li></ul><p><strong>Returns</strong></p><p><code>(node, predecessors)</code> iterator where <code>predecessors</code> is the list of
predecessors of the node.</p><p><strong>Return type</strong></p><p>mgp.Record(node=mgp.Vertex, predecessor=mgp.Vertex)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="bfs_successorsctx-source-depth_limit"></a><code>bfs_successors(ctx, source, depth_limit)</code><a class="hash-link" href="#bfs_successorsctx-source-depth_limit" title="Direct link to heading">#</a></h2><p>Returns an iterator of successors in breadth-first-search from source.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>source</strong> (<em>node</em>) – Specify starting node for breadth-first search.</li></ul><ul><li><strong>depth_limit</strong> (<em>int optional</em>) – (default=None)
Specify the maximum search depth.</li></ul><p><strong>Returns</strong></p><p><code>(node, successors)</code> iterator where <code>successors</code> is the list of
successors of the node.</p><p><strong>Return type</strong></p><p>mgp.Record(node=mgp.Vertex, successors=mgp.List[mgp.Vertex])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="bfs_treectx-source-reverse-depth_limit"></a><code>bfs_tree(ctx, source, reverse, depth_limit)</code><a class="hash-link" href="#bfs_treectx-source-reverse-depth_limit" title="Direct link to heading">#</a></h2><p>Returns an oriented tree constructed from of a breadth-first-search
starting at <code>source</code>.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>source</strong> (<em>mgp.Vertex</em>) – Specify starting node for breadth-first search.</li></ul><ul><li><strong>reverse</strong> (<em>bool</em>) – (default=False)
If <code>True</code>, traverse a directed graph in the reverse direction.</li></ul><ul><li><strong>depth_limit</strong> (<em>mgp.Nullable[int]</em>) – (default=None)
Specify the maximum search depth.</li></ul><p><strong>Returns</strong></p><p>An oriented tree.</p><p><strong>Return type</strong></p><p>mgp.Record(tree=mgp.List[mgp.Vertex])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="biconnected_componentsctx"></a><code>biconnected_components(ctx)</code><a class="hash-link" href="#biconnected_componentsctx" title="Direct link to heading">#</a></h2><p>Returns a list of sets of nodes, one set for each biconnected
component of the graph</p><p><em>Biconnected components</em> are maximal subgraphs such that the removal of a
node (and all edges incident on that node) will not disconnect the
subgraph. Note that nodes may be part of more than one biconnected
component.  Those nodes are articulation points or cut vertices.  The
removal of articulation points will increase the number of connected
components of the graph.</p><p>Notice that by convention a dyad is considered a biconnected component.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><p><strong>Returns</strong></p><p>A list of sets of nodes, one set for each biconnected component.</p><p><strong>Return type</strong></p><p>mgp.Record(components=mgp.List[mgp.List[mgp.Vertex]])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="bridgesctx-root"></a><code>bridges(ctx, root)</code><a class="hash-link" href="#bridgesctx-root" title="Direct link to heading">#</a></h2><p>Returns all bridges in a graph.</p><p>A <em>bridge</em> in a graph is an edge whose removal causes the number of
connected components of the graph to increase.  Equivalently, a bridge is an
edge that does not belong to any cycle.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>root</strong> (<em>mgp.Nullable[mgp.Vertex]</em>) – (default=None)
A node in the graph <code>G</code>. If specified, only the bridges in the
connected components containing this node will be returned.</li></ul><p><strong>Returns</strong></p><p>A list of edges in the graph whose removal disconnects the graph (or
causes the number of connected components to increase).</p><p><strong>Return type</strong></p><p>mgp.Record(bridges=mgp.List[mgp.Edge])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="centerctx"></a><code>center(ctx)</code><a class="hash-link" href="#centerctx" title="Direct link to heading">#</a></h2><p>Returns the center of the graph <code>G</code>.</p><p>The <em>center</em> is the set of nodes with eccentricity equal to the radius.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><p><strong>Returns</strong></p><p>List of nodes in center.</p><p><strong>Return type</strong></p><p>mgp.Record(center=mgp.List[mgp.Vertex])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="chain_decompositionctx-root"></a><code>chain_decomposition(ctx, root)</code><a class="hash-link" href="#chain_decompositionctx-root" title="Direct link to heading">#</a></h2><p>Returns the chain decomposition of a graph.</p><p>The <em>chain decomposition</em> of a graph with respect a depth-first
search tree is a set of cycles or paths derived from the set of
fundamental cycles of the tree in the following manner. Consider
each fundamental cycle with respect to the given tree, represented
as a list of edges beginning with the non tree edge oriented away
from the root of the tree. For each fundamental cycle, if it
overlaps with any previous fundamental cycle, just take the initial
non-overlapping segment, which is a path instead of a cycle. Each
cycle or path is called a <em>chain</em>.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>root</strong> (<em>mgp.Nullable[mgp.Vertex]</em>) – (default=None)
Optional. A node in the graph <code>G</code>. If specified, only the chain
decomposition for the connected component containing this node
will be returned. This node indicates the root of the depth-first
search tree.</li></ul><p><strong>Returns</strong></p><p>A list of edges representing a chain. There is no guarantee on
the orientation of the edges in each chain (for example, if a
chain includes the edge joining nodes 1 and 2, the chain may
include either (1, 2) or (2, 1)).</p><p><strong>Return type</strong></p><p>mgp.Record(chains=mgp.List[mgp.List[mgp.Edge]])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="check_planarityctx"></a><code>check_planarity(ctx)</code><a class="hash-link" href="#check_planarityctx" title="Direct link to heading">#</a></h2><p>Check if a graph is planar.</p><p>A graph is planar if it can be drawn in a plane without
any edge intersections.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><p><strong>Returns</strong></p><p><code>is_planar</code> is <code>True</code> if the graph is planar.</p><p><strong>Return type</strong></p><p>mgp.Record(is_planar=bool)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="clusteringctx-nodes-weight"></a><code>clustering(ctx, nodes, weight)</code><a class="hash-link" href="#clusteringctx-nodes-weight" title="Direct link to heading">#</a></h2><p>Compute the clustering coefficient for nodes.</p><p>A <em>clustering coefficient</em> is a measure of the degree to which nodes
in a graph tend to cluster together.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>nodes</strong> (<em>mgp.Nullable[mgp.List[mgp.Vertex]]</em>) – (default=None)
Compute clustering for nodes in this container.</li></ul><ul><li><strong>weight</strong> (<em>mgp.Nullable[str]</em>) – (default=None)
The edge attribute that holds the numerical value used as a weight.
If <code>None</code>, then each edge has weight 1.</li></ul><p><strong>Returns</strong></p><p>Clustering coefficient at specified nodes.</p><p><strong>Return type</strong></p><p>mgp.Record(node=mgp.Vertex, clustering=mgp.Number)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="communicabilityctx"></a><code>communicability(ctx)</code><a class="hash-link" href="#communicabilityctx" title="Direct link to heading">#</a></h2><p>Returns communicability between all pairs of nodes in <code>G</code>.</p><p>The <em>communicability</em> between pairs of nodes in <code>G</code> is the sum of
closed walks of different lengths starting at node <code>u</code> and ending at node <code>v</code>.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><p><strong>Returns</strong></p><p>Dictionary of dictionaries keyed by nodes with communicability
as the value.</p><p><strong>Return type</strong></p><p>mgp.Record(node1=mgp.Vertex, node2=mgp.Vertex, communicability=mgp.Number)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="core_numberctx"></a><code>core_number(ctx)</code><a class="hash-link" href="#core_numberctx" title="Direct link to heading">#</a></h2><p>Returns the core number for each vertex.</p><p>A <em>k-core</em> is a maximal subgraph that contains nodes of degree <code>k</code> or more.</p><p>The core number of a node is the largest value <code>k</code> of a k-core containing
that node.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><p><strong>Returns</strong></p><p>A dictionary keyed by node to the core number.</p><p><strong>Return type</strong></p><p>mgp.Record(node=mgp.Vertex, core=mgp.Number)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="degree_assortativity_coefficientctx-x-y-weight-nodes"></a><code>degree_assortativity_coefficient(ctx, x, y, weight, nodes)</code><a class="hash-link" href="#degree_assortativity_coefficientctx-x-y-weight-nodes" title="Direct link to heading">#</a></h2><p>Compute degree assortativity of a graph.</p><p><em>Assortativity</em> measures the similarity of connections
in the graph with respect to the node degree.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>x</strong> (<em>str(&#x27;in&#x27;,&#x27;out&#x27;)</em>) – (default=’out’)
The degree type for source node (directed graphs only).</li></ul><ul><li><strong>y</strong> (<em>str(&#x27;in&#x27;,&#x27;out&#x27;)</em>) – (default=’in’)
The degree type for target node (directed graphs only).</li></ul><ul><li><strong>weight</strong> (<em>mgp.Nullable[str]</em>) – (default=None)
The edge attribute that holds the numerical value used
as a weight.  If <code>None</code>, then each edge has weight 1.
The degree is the sum of the edge weights adjacent to the node.</li></ul><ul><li><strong>nodes</strong> (<em>mgp.Nullable[mgp.List[mgp.Vertex]]</em>) – (default=None)
Compute degree assortativity only for nodes in a container.
The default is all nodes.</li></ul><p><strong>Returns</strong></p><p>Assortativity of graph by degree.</p><p><strong>Return type</strong></p><p>mgp.Record(assortativity=float)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="descendantsctx-source"></a><code>descendants(ctx, source)</code><a class="hash-link" href="#descendantsctx-source" title="Direct link to heading">#</a></h2><p>Returns all nodes reachable from <code>source</code> in <code>G</code>.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>source</strong> (<em>node</em>) – A node in <code>G</code>.</li></ul><p><strong>Returns</strong></p><p>The descendants of <code>source</code> in <code>G</code>.</p><p><strong>Return type</strong></p><p>mgp.Record(descendants=mgp.List[mgp.Vertex])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="dfs_postorder_nodesctx-source-depth_limit"></a><code>dfs_postorder_nodes(ctx, source, depth_limit)</code><a class="hash-link" href="#dfs_postorder_nodesctx-source-depth_limit" title="Direct link to heading">#</a></h2><p>Returns nodes in a depth-first-search post-ordering starting at source.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>source</strong> (<em>mgp.Vertex</em>) – Specify starting node for depth-first search.</li></ul><ul><li><strong>depth_limit</strong> (<em>mgp.Nullable[int]</em>) – (default=None)
Specify the maximum search depth.</li></ul><p><strong>Returns</strong></p><p>A list of nodes in a depth-first-search post-ordering.</p><p><strong>Return type</strong></p><p>mgp.Record(nodes=mgp.List[mgp.Vertex])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="dfs_predecessorsctx-source-depth_limit"></a><code>dfs_predecessors(ctx, source, depth_limit)</code><a class="hash-link" href="#dfs_predecessorsctx-source-depth_limit" title="Direct link to heading">#</a></h2><p>Returns a dictionary of predecessors in depth-first-search from source.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>source</strong> (<em>mgp.Vertex</em>) – Specify starting node for depth-first search.</li></ul><ul><li><strong>depth_limit</strong> (<em>mgp.Nullable[int]</em>) – (default=None)
Specify the maximum search depth.</li></ul><p><strong>Returns</strong></p><p>A dictionary with nodes as keys and predecessor nodes as values.</p><p><strong>Return type</strong></p><p>mgp.Record(node=mgp.Vertex, predecessor=mgp.Vertex)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="dfs_preorder_nodesctx-source-depth_limit"></a><code>dfs_preorder_nodes(ctx, source, depth_limit)</code><a class="hash-link" href="#dfs_preorder_nodesctx-source-depth_limit" title="Direct link to heading">#</a></h2><p>Returns nodes in a depth-first-search pre-ordering starting at source.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>source</strong> (<em>mgp.Vertex</em>) – Specify starting node for depth-first search and return nodes in
the component reachable from
this node.</li></ul><ul><li><strong>depth_limit</strong> (<em>mgp.Nullable[int]</em>) – (default=None)
Specify the maximum search depth.</li></ul><p><strong>Returns</strong></p><p>A list of nodes in a depth-first-search pre-ordering.</p><p><strong>Return type</strong></p><p>mgp.Record(nodes=mgp.List[mgp.Vertex])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="dfs_successorsctx-source-depth_limit"></a><code>dfs_successors(ctx, source, depth_limit)</code><a class="hash-link" href="#dfs_successorsctx-source-depth_limit" title="Direct link to heading">#</a></h2><p>Returns a dictionary of successors in depth-first-search from source.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>source</strong> (<em>mgp.Vertex</em>) – Specify starting node for depth-first search.</li></ul><ul><li><strong>depth_limit</strong> (<em>mgp.Nullable[int]</em>) – (default=None)
Specify the maximum search depth.</li></ul><p><strong>Returns</strong></p><p>A dictionary with nodes as keys and list of successor nodes as values.</p><p><strong>Return type</strong></p><p>mgp.Record(node=mgp.Vertex, successors=mgp.List[mgp.Vertex])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="dfs_treectx-source-depth_limit"></a><code>dfs_tree(ctx, source, depth_limit)</code><a class="hash-link" href="#dfs_treectx-source-depth_limit" title="Direct link to heading">#</a></h2><p>Returns an oriented tree constructed from a depth-first-search from source.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>source</strong> (<em>mgp.Vertex</em>) – Specify starting node for depth-first search.</li></ul><ul><li><strong>depth_limit</strong> (<em>mgp.Nullable[int]</em>) – (default=None)
Specify the maximum search depth.</li></ul><p><strong>Returns</strong></p><p>An oriented tree.</p><p><strong>Return type</strong></p><p>mgp.Record(tree=mgp.List[mgp.Vertex])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="diameterctx"></a><code>diameter(ctx)</code><a class="hash-link" href="#diameterctx" title="Direct link to heading">#</a></h2><p>Returns the diameter of the graph <code>G</code>.</p><p>The diameter is the maximum eccentricity.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><p><strong>Returns</strong></p><p>Diameter of graph.</p><p><strong>Return type</strong></p><p>mgp.Record(diameter=int)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="dominance_frontiersctx-start"></a><code>dominance_frontiers(ctx, start)</code><a class="hash-link" href="#dominance_frontiersctx-start" title="Direct link to heading">#</a></h2><p>Returns the dominance frontiers of all nodes of a directed graph.</p><p>The <em>dominance frontier</em> of a node <code>d</code> is the set of all
nodes such that <code>d</code> dominates an immediate
predecessor of a node, but <code>d</code> does not strictly dominate that node.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>start</strong> (<em>mgp.Vertex</em>) – The start node of dominance computation.</li></ul><p><strong>Returns</strong></p><p>A dictionary containing the dominance frontiers of each node reachable from
<code>start</code> as lists.</p><p><strong>Return type</strong></p><p>mgp.Record(node=mgp.Vertex, frontier=mgp.List[mgp.Vertex])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="dominating_setctx-start"></a><code>dominating_set(ctx, start)</code><a class="hash-link" href="#dominating_setctx-start" title="Direct link to heading">#</a></h2><p>Finds a dominating set for the graph <code>G</code>.</p><p>A <em>dominating set</em> for a graph with node set <code>V</code> is a subset <code>D</code> of
<code>V</code> such that every node not in <code>D</code> is adjacent to at least one
member of <code>D</code>.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>start</strong> (<em>mgp.Vertex</em>) – Node to use as a starting point for the algorithm.</li></ul><p><strong>Returns</strong></p><p>A dominating set for <code>G</code>.</p><p><strong>Return type</strong></p><p>mgp.Record(dominating_set=mgp.List[mgp.Vertex])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="edge_bfsctx-source-orientation"></a><code>edge_bfs(ctx, source, orientation)</code><a class="hash-link" href="#edge_bfsctx-source-orientation" title="Direct link to heading">#</a></h2><p>A directed, breadth-first-search of edges in <code>G</code>, beginning at <code>source</code>.</p><p>Return the edges of <code>G</code> in a breadth-first-search order continuing until
all edges are generated.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>source</strong> (<em>mgp.Nullable[mgp.Vertex]</em>) – (default=None)
The node from which the traversal begins. If <code>None</code>, then a source
is chosen arbitrarily and repeatedly until all edges from each node in
the graph are searched.</li></ul><ul><li><strong>orientation</strong> (<em>mgp.Nullable[str]</em>) – (default=None)
For directed graphs and directed multigraphs, edge traversals
need not respect the original orientation of the edges.
When set to ‘reverse’, every edge is traversed in the reverse direction.
When set to ‘ignore’, every edge is treated as undirected.
When set to ‘original’, every edge is treated as directed.
In all three cases, the returned edge tuples add a last entry to
indicate the direction in which that edge was traversed.
If <code>orientation</code> is <code>None</code>, the returned edge has no direction indicated.
The direction is respected, but not reported.</li></ul><p><strong>Returns</strong></p><p>A directed edge indicating the path taken by the breadth-first-search.
For graphs, edge is of the form <code>(u, v)</code> where <code>u</code> and <code>v</code>
are the tail and head of the edge as determined by the traversal.
For multigraphs, edge is of the form <code>(u, v, key)</code>, where <code>key</code> is
the key of the edge. When the graph is directed, then u and <code>v</code>
are always in the order of the actual directed edge.
If <code>orientation</code> is not <code>None</code> then the edge tuple is extended to include
the direction of traversal (‘forward’ or ‘reverse’) on that edge.</p><p><strong>Return type</strong></p><p>mgp.Record(edges=mgp.List[mgp.Edge])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="edge_dfsctx-source-orientation"></a><code>edge_dfs(ctx, source, orientation)</code><a class="hash-link" href="#edge_dfsctx-source-orientation" title="Direct link to heading">#</a></h2><p>A directed, depth-first-search of edges in <code>G</code>, beginning at <code>source</code>.</p><p>Return the edges of <code>G</code> in a depth-first-search order continuing until
all edges are generated.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>source</strong> (<em>mgp.Nullable[mgp.Vertex]</em>) – The node from which the traversal begins. If <code>None</code>, then a source
is chosen arbitrarily and repeatedly until all edges from each node in
the graph are searched.</li></ul><ul><li><strong>orientation</strong> (<em>mgp.Nullable[str]</em>) – (default=None)
For directed graphs and directed multigraphs, edge traversals
need not respect the original orientation of the edges.
When set to ‘reverse’, every edge is traversed in the reverse direction.
When set to ‘ignore’, every edge is treated as undirected.
When set to ‘original’, every edge is treated as directed.
In all three cases, the returned edge tuples add a last entry to
indicate the direction in which that edge was traversed.
If <code>orientation</code> is <code>None</code>, the returned edge has no direction indicated.
The direction is respected, but not reported.</li></ul><p><strong>Returns</strong></p><p>A directed edge indicating the path taken by the depth-first traversal.
For graphs, edge is of the form <code>(u, v)</code> where <code>u</code> and <code>v</code>
are the tail and head of the edge as determined by the traversal.
For multigraphs, edge is of the form <code>(u, v, key)</code>, where <code>key</code> is
the key of the edge. When the graph is directed, then <code>u</code> and <code>v</code>
are always in the order of the actual directed edge.
If <code>orientation</code> is not <code>None</code> then the edge tuple is extended to include
the direction of traversal (‘forward’ or ‘reverse’) on that edge.</p><p><strong>Return type</strong></p><p>mgp.Record(edges=mgp.List[mgp.Edge])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="find_cliquesctx"></a><code>find_cliques(ctx)</code><a class="hash-link" href="#find_cliquesctx" title="Direct link to heading">#</a></h2><p>Returns all maximal cliques in an undirected graph.</p><p>For each node <code>v</code>, a <em>maximal clique</em> for <code>v</code> is a largest complete
subgraph containing <code>v</code>. The largest maximal clique is sometimes
called the <em>maximum clique</em>.</p><p>This function returns an iterator over cliques, each of which is a
list of nodes. It is an iterative implementation, so should not
suffer from recursion depth issues.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><p><strong>Returns</strong></p><p>An iterator over maximal cliques, each of which is a list of
nodes in <code>G</code>. The order of cliques is arbitrary.</p><p><strong>Return type</strong></p><p>mgp.Record(cliques=mgp.List[mgp.List[mgp.Vertex]])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="find_cyclectx-source-orientation"></a><code>find_cycle(ctx, source, orientation)</code><a class="hash-link" href="#find_cyclectx-source-orientation" title="Direct link to heading">#</a></h2><p>Returns a cycle found via depth-first traversal.</p><p>A <em>cycle</em> is a closed path in the graph.
The orientation of directed edges is determined by <code>orientation</code>.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>source</strong> (<em>mgp.Nullable[mgp.List[mgp.Vertex]]</em>) – (default=None)
The node from which the traversal begins. If <code>None</code>, then a source
is chosen arbitrarily and repeatedly until all edges from each node in
the graph are searched.</li></ul><ul><li><strong>orientation</strong> (<em>mgp.Nullable[str]</em>) – (default=None)
For directed graphs and directed multigraphs, edge traversals
need not respect the original orientation of the edges.
When set to ‘reverse’ every edge is traversed in the reverse direction.
When set to ‘ignore’, every edge is treated as undirected.
When set to ‘original’, every edge is treated as directed.
In all three cases, the yielded edge tuples add a last entry to
indicate the direction in which that edge was traversed.
If <code>orientation</code> is <code>None</code>, the yielded edge has no direction indicated.
The direction is respected, but not reported.</li></ul><p><strong>Returns</strong></p><p>A list of directed edges indicating the path taken for the loop.
If no cycle is found, then an exception is raised.
For graphs, an edge is of the form <code>(u, v)</code> where <code>u</code> and <code>v</code>
are the tail and the head of the edge as determined by the traversal.
For multigraphs, an edge is of the form <code>(u, v, key)</code>, where <code>key</code> is
the key of the edge. When the graph is directed, then <code>u</code> and <code>v</code>
are always in the order of the actual directed edge.
If <code>orientation</code> is not <code>None</code> then the edge tuple is extended to include
the direction of traversal (‘forward’ or ‘reverse’) on that edge.</p><p><strong>Return type</strong></p><p>mgp.Record(cycle=mgp.Nullable[mgp.List[mgp.Edge]])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="flow_hierarchyctx-weight"></a><code>flow_hierarchy(ctx, weight)</code><a class="hash-link" href="#flow_hierarchyctx-weight" title="Direct link to heading">#</a></h2><p>Returns the flow hierarchy of a directed network.</p><p><em>Flow hierarchy</em> is defined as the fraction of edges not participating
in cycles in a directed graph.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>weight</strong> (<em>mgp.Nullable[str]</em>) – (default=None)
Attribute to use for node weights. If <code>None</code>, the weight defaults to 1.</li></ul><p><strong>Returns</strong></p><p>Flow hierarchy value.</p><p><strong>Return type</strong></p><p>mgp.Record(flow_hierarchy=float)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="global_efficiencyctx"></a><code>global_efficiency(ctx)</code><a class="hash-link" href="#global_efficiencyctx" title="Direct link to heading">#</a></h2><p>Returns the average global efficiency of the graph.</p><p>The <em>efficiency</em> of a pair of nodes in a graph is the multiplicative
inverse of the shortest path distance between the nodes. The <em>average
global efficiency</em> of a graph is the average efficiency of all pairs of
nodes.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><p><strong>Returns</strong></p><p>The average global efficiency of the graph.</p><p><strong>Return type</strong></p><p>mgp.Record(global_efficiency=float)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="greedy_colorctx-strategy-interchange"></a><code>greedy_color(ctx, strategy, interchange)</code><a class="hash-link" href="#greedy_colorctx-strategy-interchange" title="Direct link to heading">#</a></h2><p>Color a graph using various strategies of greedy graph coloring.</p><p>Attempts to color a graph using as few colors as possible, where no
neighbours of a node can have the same color as the node itself.
The given strategy determines the order in which nodes are colored.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>strategy</strong> (<em>str</em>) – (default=’largest_first’)
The parameter <code>function(G,colors)</code> is a function
(or a string representing a function) that provides
the coloring strategy, by returning nodes in the order they
should be colored. <code>G</code> is the graph, and <code>colors</code> is a
dictionary of the currently assigned colors, keyed by nodes. The
function must return an iterable over all the nodes in <code>G</code>.
If the strategy function is an iterator generator (a function with
<code>yield</code> statements), keep in mind that the <code>colors</code> dictionary
will be updated after each <code>yield</code>, since
this function chooses colors greedily.
If <code>strategy</code> is a string, it must be one of the following,
each of which represents one of the built-in strategy functions.
<code>&#x27;largest_first&#x27;</code><code>&#x27;random_sequential&#x27;</code><code>&#x27;smallest_last&#x27;</code><code>&#x27;independent_set&#x27;</code><code>&#x27;connected_sequential_bfs&#x27;</code><code>&#x27;connected_sequential_dfs&#x27;</code><code>&#x27;connected_sequential&#x27;</code> (alias for the previous strategy)
<code>&#x27;saturation_largest_first&#x27;</code><code>&#x27;DSATUR&#x27;</code> (alias for the previous strategy)</li></ul><ul><li><strong>interchange</strong> (<em>bool</em>) – (default=False)
Will use the color interchange algorithm if set to <code>True</code>.
Note that <code>saturation_largest_first</code> and <code>independent_set</code>
do not work with interchange. Furthermore, if you use
interchange with your own strategy function, you cannot rely
on the values in the <code>colors</code> argument.</li></ul><p><strong>Returns</strong></p><p>A dictionary with keys representing nodes and values representing
corresponding coloring.</p><p><strong>Return type</strong></p><p>mgp.Record(node=mgp.Vertex, color=int)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="has_eulerian_pathctx"></a><code>has_eulerian_path(ctx)</code><a class="hash-link" href="#has_eulerian_pathctx" title="Direct link to heading">#</a></h2><p>Returns <code>True</code> if <code>G</code> has an Eulerian path.</p><p>An <em>Eulerian path</em> is a path in a graph that uses each edge of a graph
exactly once.</p><p>A directed graph has an Eulerian path if:</p><ul><li>at most one vertex has <code>out_degree - in_degree = 1</code>,</li><li>at most one vertex has <code>in_degree - out_degree = 1</code>,</li><li>every other vertex has equal in_degree and out_degree,</li><li>and all of its vertices with nonzero degree belong to a
single connected component of the underlying undirected graph.</li></ul><p>An undirected graph has an Eulerian path if exactly zero or
two vertices have an odd degree and all of its vertices with
nonzero degrees belong to a single connected component.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><p><strong>Returns</strong></p><p><code>True</code> if <code>G</code> has an eulerian path.</p><p><strong>Return type</strong></p><p>mgp.Record(has_eulerian_path=bool)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="has_pathctx-source-target"></a><code>has_path(ctx, source, target)</code><a class="hash-link" href="#has_pathctx-source-target" title="Direct link to heading">#</a></h2><p>Returns <code>True</code> if <code>G</code> has a path from <code>source</code> to <code>target</code>.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>source</strong> (<em>mgp.Vertex</em>) – Starting node for the path.</li></ul><ul><li><strong>target</strong> (<em>mgp.Vertex</em>) – Ending node for the path.</li></ul><p><strong>Returns</strong></p><p><code>True</code> if <code>G</code> has a path from <code>source</code> to <code>target</code>.</p><p><strong>Return type</strong></p><p>mgp.Record(has_path=bool)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="immediate_dominatorsctx-start"></a><code>immediate_dominators(ctx, start)</code><a class="hash-link" href="#immediate_dominatorsctx-start" title="Direct link to heading">#</a></h2><p>Returns the immediate dominators of all nodes of a directed graph.</p><p>The immediate dominator of a node is the unique node that
Strictly dominates a node <code>n</code> but does not strictly dominate any other node
That dominates <code>n</code>.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>start</strong> (<em>mgp.Vertex</em>) – The start node of dominance computation.</li></ul><p><strong>Returns</strong></p><p>A dictionary containing the immediate dominators of each node reachable from
<code>start</code>.</p><p><strong>Return type</strong></p><p>mgp.Record(node=mgp.Vertex, dominator=mgp.Vertex)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="is_arborescencectx"></a><code>is_arborescence(ctx)</code><a class="hash-link" href="#is_arborescencectx" title="Direct link to heading">#</a></h2><p>Returns <code>True</code> if <code>G</code> is an arborescence.</p><p>An <em>arborescence</em> is a directed tree with maximum in-degree equal to 1.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><p><strong>Returns</strong></p><p>A boolean that is <code>True</code> if <code>G</code> is an arborescence.</p><p><strong>Return type</strong></p><p>mgp.Record(is_arborescence=bool)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="is_at_freectx"></a><code>is_at_free(ctx)</code><a class="hash-link" href="#is_at_freectx" title="Direct link to heading">#</a></h2><p>Check if a graph is AT-free.</p><p>The method uses the find_asteroidal_triple method to recognize
an AT-free graph. If no asteroidal triple is found, the graph is
AT-free and <code>True</code> is returned. If at least one asteroidal triple is
found, the graph is not AT-free and <code>False</code> is returned.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><p><strong>Returns</strong></p><p><code>True</code> if <code>G</code> is AT-free and <code>False</code> otherwise.</p><p><strong>Return type</strong></p><p>mgp.Record(is_at_free=bool)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="is_bipartitectx"></a><code>is_bipartite(ctx)</code><a class="hash-link" href="#is_bipartitectx" title="Direct link to heading">#</a></h2><p>Returns <code>True</code> if graph <code>G</code> is bipartite, <code>False</code> if not.</p><p>A <em>bipartite graph</em> (or bigraph) is a graph whose vertices can be
divided into two disjoint and independent sets``u`` and <code>v</code> and such that
every edge connects a vertex in <code>u</code> one in <code>v</code>.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><p><strong>Returns</strong></p><p><code>True</code> if <code>G</code> is bipartite and <code>False</code> otherwise.</p><p><strong>Return type</strong></p><p>mgp.Record(is_bipartite=bool)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="is_branchingctx"></a><code>is_branching(ctx)</code><a class="hash-link" href="#is_branchingctx" title="Direct link to heading">#</a></h2><p>Returns <code>True</code> if <code>G</code> is a branching.</p><p>A <em>branching</em> is a directed forest with maximum in-degree equal to 1.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><p><strong>Returns</strong></p><p>A boolean that is <code>True</code> if <code>G</code> is a branching.</p><p><strong>Return type</strong></p><p>mgp.Record(is_branching=bool)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="is_chordalctx"></a><code>is_chordal(ctx)</code><a class="hash-link" href="#is_chordalctx" title="Direct link to heading">#</a></h2><p>Checks whether <code>G</code> is a chordal graph.</p><p>A graph is <em>chordal</em> if every cycle of length at least 4 has a chord
(an edge joining two nodes not adjacent in the cycle).</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><p><strong>Returns</strong></p><p><code>True</code> if <code>G</code> is a chordal graph and <code>False</code> otherwise.</p><p><strong>Return type</strong></p><p>mgp.Record(is_chordal=bool)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="is_distance_regularctx"></a><code>is_distance_regular(ctx)</code><a class="hash-link" href="#is_distance_regularctx" title="Direct link to heading">#</a></h2><p>Returns <code>True</code> if the graph is distance regular, <code>False</code> otherwise.</p><p>A connected graph <code>G</code> is distance-regular if for any nodes <code>x,y</code>
and any integers <code>i,j=0,1,...,d</code> (where <code>d</code> is the graph
diameter), the number of vertices at distance <code>i</code> from <code>x</code> and
distance <code>j</code> from <code>y</code> depends only on <code>i,j</code> and the graph distance
between <code>x</code> and <code>y</code>, independently of the choice of <code>x</code> and <code>y</code>.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><p><strong>Returns</strong></p><p><code>True</code> if the graph is Distance Regular, <code>False</code> otherwise.</p><p><strong>Return type</strong></p><p>mgp.Record(is_distance_regular=bool)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="is_edge_coverctx-cover"></a><code>is_edge_cover(ctx, cover)</code><a class="hash-link" href="#is_edge_coverctx-cover" title="Direct link to heading">#</a></h2><p>Decides whether a set of edges is a valid edge cover of the graph.</p><p>Given a set of edges, it can be decided whether the set is
an <em>edge covering</em> if checked whether all nodes of the graph
have an edge from the set incident on it.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>cover</strong> (<em>mgp.List[mgp.Edge]</em>) – A list of edges to be checked.</li></ul><p><strong>Returns</strong></p><p>Whether the set of edges is a valid edge cover of the graph.</p><p><strong>Return type</strong></p><p>mgp.Record(is_edge_cover=bool)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="is_eulerianctx"></a><code>is_eulerian(ctx)</code><a class="hash-link" href="#is_eulerianctx" title="Direct link to heading">#</a></h2><p>Returns <code>True</code> if and only if <code>G</code> is Eulerian.</p><p>A graph is <em>Eulerian</em> if it has an Eulerian circuit. An <em>Eulerian
circuit</em> is a closed walk that includes each edge of a graph exactly
once.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><p><strong>Returns</strong></p><p><code>True</code> if <code>G</code> is Eulerian.</p><p><strong>Return type</strong></p><p>mgp.Record(is_eulerian=bool)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="is_forestctx"></a><code>is_forest(ctx)</code><a class="hash-link" href="#is_forestctx" title="Direct link to heading">#</a></h2><p>Returns <code>True</code> if <code>G</code> is a forest.</p><p>A <em>forest</em> is a graph with no undirected cycles.</p><p>For directed graphs, <code>G</code> is a forest if the underlying graph is a forest.
The underlying graph is obtained by treating each directed edge as a single
undirected edge in a multigraph.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><p><strong>Returns</strong></p><p>A boolean that is <code>True</code> if <code>G</code> is a forest.</p><p><strong>Return type</strong></p><p>mgp.Record(is_forest=bool)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="is_isolatectx-n"></a><code>is_isolate(ctx, n)</code><a class="hash-link" href="#is_isolatectx-n" title="Direct link to heading">#</a></h2><p>Determines whether a node is an isolate.</p><p>An <em>isolate</em> is a node with no neighbors (that is, with degree
zero). For directed graphs, this means no in-neighbors and no
out-neighbors.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>n</strong> (<em>mgp.Vertex</em>) – A node in <code>G</code>.</li></ul><p><strong>Returns</strong></p><p><code>True</code> if and only if <code>n</code> has no neighbors.</p><p><strong>Return type</strong></p><p>mgp.Record(is_isolate=bool)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="is_isomorphicctx-nodes1-edges1-nodes2-edges2"></a><code>is_isomorphic(ctx, nodes1, edges1, nodes2, edges2)</code><a class="hash-link" href="#is_isomorphicctx-nodes1-edges1-nodes2-edges2" title="Direct link to heading">#</a></h2><p>Returns <code>True</code> if the graphs <code>G1</code> and <code>G2</code> are isomorphic
and <code>False</code> otherwise.</p><p>The two graphs <code>G1</code> and <code>G2</code> must be the same type.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>nodes1</strong> (<em>mgp.List[mgp.Vertex]</em>) – Nodes in <code>G1</code>.</li></ul><ul><li><strong>edges1</strong> (<em>mgp.List[mgp.Edge]</em>) – Edges in <code>G1</code>.</li></ul><ul><li><strong>nodes2</strong> (<em>mgp.List[mgp.Vertex]</em>) – Nodes in <code>G2</code>.</li></ul><ul><li><strong>edges2</strong> (<em>mgp.List[mgp.Edge]</em>) – Edges in <code>G2</code>.</li></ul><p><strong>Returns</strong></p><p><code>True</code> if the graphs <code>G1</code> and <code>G2</code> are isomorphic
and <code>False</code> otherwise.</p><p><strong>Return type</strong></p><p>mgp.Record(is_isomorphic=bool)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="is_semieulerianctx"></a><code>is_semieulerian(ctx)</code><a class="hash-link" href="#is_semieulerianctx" title="Direct link to heading">#</a></h2><p>Returns <code>True</code> if <code>G</code> is semi-Eulerian.</p><p><code>G</code> is semi-Eulerian if it has an Eulerian path but no Eulerian circuit.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><p><strong>Returns</strong></p><p><code>True</code> if <code>G</code> is semi-Eulerian.</p><p><strong>Return type</strong></p><p>mgp.Record(is_semieulerian=bool)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="is_simple_pathctx-nodes"></a><code>is_simple_path(ctx, nodes)</code><a class="hash-link" href="#is_simple_pathctx-nodes" title="Direct link to heading">#</a></h2><p>Returns <code>True</code> if and only if the given nodes form a simple path in
<code>G</code>.</p><p>A <em>simple path</em> in a graph is a nonempty sequence of nodes in which
no node appears more than once in the sequence and each adjacent
pair of nodes in the sequence is adjacent in the graph.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>nodes</strong> (<em>mgp.List[mgp.Vertex]</em>) – A list of one or more nodes in the graph <code>G</code>.</li></ul><p><strong>Returns</strong></p><p>Whether the given list of nodes represents a simple path in <code>G</code>.</p><p><strong>Return type</strong></p><p>mgp.Record(is_simple_path=bool)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="is_strongly_regularctx"></a><code>is_strongly_regular(ctx)</code><a class="hash-link" href="#is_strongly_regularctx" title="Direct link to heading">#</a></h2><p>Returns <code>True</code> if and only if the given graph is strongly
regular.</p><p>An undirected graph is <em>strongly regular</em> if</p><ul><li>it is regular,</li></ul><ul><li>each pair of adjacent vertices has the same number of neighbors in
common,</li></ul><ul><li>each pair of nonadjacent vertices has the same number of neighbors
in common.</li></ul><p>Each strongly regular graph is a distance-regular graph.
Conversely, if a distance-regular graph has a diameter of two,
then it is a strongly regular graph.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><p><strong>Returns</strong></p><p>Whether <code>G</code> is strongly regular.</p><p><strong>Return type</strong></p><p>mgp.Record(is_strongly_regular=bool)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="is_tournamentctx"></a><code>is_tournament(ctx)</code><a class="hash-link" href="#is_tournamentctx" title="Direct link to heading">#</a></h2><p>Returns <code>True</code> if and only if <code>G</code> is a tournament.</p><p>A <em>tournament</em> is a directed graph, with neither self-loops nor
multi-edges, in which there is exactly one directed edge joining
each pair of distinct nodes.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><p><strong>Returns</strong></p><p>Whether the given graph is a tournament graph.</p><p><strong>Return type</strong></p><p>mgp.Record(is_tournament=bool)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="is_treectx"></a><code>is_tree(ctx)</code><a class="hash-link" href="#is_treectx" title="Direct link to heading">#</a></h2><p>Returns <code>True</code> if <code>G</code> is a tree.</p><p>A <em>tree</em> is a connected graph with no undirected cycles.</p><p>For directed graphs, <code>G</code> is a tree if the underlying graph is a tree. The
underlying graph is obtained by treating each directed edge as a single
undirected edge in a multigraph.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><p><strong>Returns</strong></p><p>A boolean that is <code>True</code> if <code>G</code> is a tree.</p><p><strong>Return type</strong></p><p>mgp.Record(is_tree=bool)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="isolatesctx"></a><code>isolates(ctx)</code><a class="hash-link" href="#isolatesctx" title="Direct link to heading">#</a></h2><p>Returns a list of isolates in the graph.</p><p>An <em>isolate</em> is a node with no neighbors (that is, with degree
zero). For directed graphs, this means no in-neighbors and no
out-neighbors.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><p><strong>Returns</strong></p><p>A list of isolates in <code>G</code>.</p><p><strong>Return type</strong></p><p>mgp.Record(isolates=mgp.List[mgp.Vertex])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="jaccard_coefficientctx-ebunch"></a><code>jaccard_coefficient(ctx, ebunch)</code><a class="hash-link" href="#jaccard_coefficientctx-ebunch" title="Direct link to heading">#</a></h2><p>Compute the Jaccard coefficient of all node pairs in <code>ebunch</code>.</p><p><em>Jaccard coefficient</em> compares members of two sets to see
which members are shared and which are distinct.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>ebunch</strong> (<em>mgp.Nullable<strong>[</strong>mgp.List<strong>[</strong>mgp.List[mgp.Vertex]<strong>]</strong>]</em>) – (default=None)
Jaccard coefficient will be computed for each pair of nodes
given in the iterable. The pairs must be given as 2-tuples
<code>(u, v)</code> where <code>u</code> and <code>v</code> are nodes in the graph.
If <code>ebunch</code> is <code>None</code> then all non-existent edges in the
graph will be used.</li></ul><p><strong>Returns</strong></p><p>An iterator of 3-tuples in the form <code>(u, v, p)</code> where <code>(u, v)</code> is a
pair of nodes and <code>p</code> is their Jaccard coefficient.</p><p><strong>Return type</strong></p><p>mgp.Record(u=mgp.Vertex, v=mgp.Vertex, coef=float)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="k_clique_communitiesctx-k-cliques"></a><code>k_clique_communities(ctx, k, cliques)</code><a class="hash-link" href="#k_clique_communitiesctx-k-cliques" title="Direct link to heading">#</a></h2><p>Find k-clique communities in a graph using the percolation method.</p><p>A <em>k-clique community</em> is the union of all cliques of size <code>k</code> that
can be reached through adjacent (sharing <code>k-1</code> nodes) k-cliques.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>k</strong> (<em>int</em>) – Size of the smallest clique.</li></ul><ul><li><strong>cliques</strong> (<em>mgp.Nullable<strong>[</strong>mgp.List<strong>[</strong>mgp.List[mgp.Vertex]<strong>]</strong>]</em>) – (default=None)
Precomputed cliques (use networkx.find_cliques(G)).</li></ul><p><strong>Returns</strong></p><p>Sets of nodes, one for each k-clique community.</p><p><strong>Return type</strong></p><p>mgp.Record(communities=mgp.List[mgp.List[mgp.Vertex]])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="k_componentsctx-density"></a><code>k_components(ctx, density)</code><a class="hash-link" href="#k_componentsctx-density" title="Direct link to heading">#</a></h2><p>Returns the approximate k-component structure of a graph <code>G</code>.</p><p>A <em>k-component</em> is a maximal subgraph of a graph <code>G</code> that has, at least,
node connectivity <code>k</code>: we need to remove at least <code>k</code> nodes to break it
into more components. k-components have an inherent hierarchical
structure because they are nested in terms of connectivity: a connected
graph can contain several 2-components, each of which can contain
one or more 3-components, and so forth.</p><p>This implementation is based on the fast heuristics to approximate
the k-component structure of a graph. This, in turn, is based on
a fast approximation algorithm for finding good lower bounds of the number
of node independent paths between two nodes.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>min_density</strong> (<em>mgp.Number</em>) – (default=0.95)
Density relaxation threshold.</li></ul><p><strong>Returns</strong></p><p>Dictionary with connectivity level <code>k</code> as key and a list of
sets of nodes that form a k-component of level <code>k</code> as values.</p><p><strong>Return type</strong></p><p>mgp.Record(k=int, components=mgp.List[mgp.List[mgp.Vertex]])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="k_edge_componentsctx-k"></a><code>k_edge_components(ctx, k)</code><a class="hash-link" href="#k_edge_componentsctx-k" title="Direct link to heading">#</a></h2><p>Returns nodes in each maximal k-edge-connected component in <code>G</code>.</p><p>A connected graph is <em>k-edge-connected</em> if it remains connected
whenever fewer than k edges are removed. The edge-connectivity of
a graph is the largest k for which the graph is k-edge-connected.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>k</strong> (<em>int</em>) – Desired edge connectivity.</li></ul><p><strong>Returns</strong></p><p>A list of k-edge-ccs. Each set of returned nodes
will have k-edge-connectivity in the graph <code>G</code>.</p><p><strong>Return type</strong></p><p>mgp.Record(components=mgp.List[mgp.List[mgp.Vertex]])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="local_efficiencyctx"></a><code>local_efficiency(ctx)</code><a class="hash-link" href="#local_efficiencyctx" title="Direct link to heading">#</a></h2><p>Returns the average local efficiency of the graph.</p><p>The <em>efficiency</em> of a pair of nodes in a graph is the multiplicative
inverse of the shortest path distance between the nodes. The <em>local
efficiency</em> of a node in the graph is the average global efficiency of the
subgraph induced by the neighbors of the node. The <em>average local
efficiency</em> is the average of the local efficiencies of each node.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><p><strong>Returns</strong></p><p>The average local efficiency of the graph.</p><p><strong>Return type</strong></p><p>mgp.Record(local_efficiency=float)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="lowest_common_ancestorctx-node1-node2"></a><code>lowest_common_ancestor(ctx, node1, node2)</code><a class="hash-link" href="#lowest_common_ancestorctx-node1-node2" title="Direct link to heading">#</a></h2><p>Compute the lowest common ancestor of the given pair of nodes.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>node1</strong> (<em>mgp.Vertex</em>) – A node in the graph.</li></ul><ul><li><strong>node2</strong> (<em>mgp.Vertex</em>) – A node in the graph.</li></ul><p><strong>Returns</strong></p><p>The lowest common ancestor of <code>node1</code> and <code>node2</code>,
or default if they have no common ancestors.</p><p><strong>Return type</strong></p><p>mgp.Record(ancestor=mgp.Nullable[mgp.Vertex])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="maximal_matchingctx"></a><code>maximal_matching(ctx)</code><a class="hash-link" href="#maximal_matchingctx" title="Direct link to heading">#</a></h2><p>Find a maximal matching in the graph.</p><p>A <em>matching</em> is a subset of edges in which no node occurs more than once.
A <em>maximal matching</em> cannot add more edges and still be a matching.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><p><strong>Returns</strong></p><p>A maximal matching of the graph.</p><p><strong>Return type</strong></p><p>mgp.Record(edges=mgp.List[mgp.Edge])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="minimum_spanning_treectx-weight-algorithm-ignore_nan"></a><code>minimum_spanning_tree(ctx, weight, algorithm, ignore_nan)</code><a class="hash-link" href="#minimum_spanning_treectx-weight-algorithm-ignore_nan" title="Direct link to heading">#</a></h2><p>Returns a minimum spanning tree or forest on an undirected graph <code>G</code>.</p><p>A <em>minimum spanning tree</em> is a subset of the edges of a
connected, undirected graph that connects all of the
vertices together without any cycles.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>weight</strong> (<em>str</em>) – (default=’weight’)
Data key to use for edge weights.</li></ul><ul><li><strong>algorithm</strong> (<em>str</em>) – (default=’kruskal’)
The algorithm to use when finding a minimum spanning tree.
Valid choices are ‘kruskal’, ‘prim’, or ‘boruvka’.</li></ul><ul><li><strong>ignore_nan</strong> (<em>bool</em>) – (default=False)
If <code>NaN</code> is found as an edge weight normally an exception is raised.
If <code>ignore_nan</code> is <code>True</code> then that edge is ignored.</li></ul><p><strong>Returns</strong></p><p>A minimum spanning tree or forest.</p><p><strong>Return type</strong></p><p>mgp.Record(nodes=mgp.List[mgp.Vertex], edges=mgp.List[mgp.Edge])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="multi_source_dijkstra_pathctx-ources-cutoff-weight"></a><code>multi_source_dijkstra_path(ctx, ources, cutoff, weight)</code><a class="hash-link" href="#multi_source_dijkstra_pathctx-ources-cutoff-weight" title="Direct link to heading">#</a></h2><p>Find shortest weighted paths in <code>G</code> from a given set of source
nodes.</p><p>Compute shortest path between any of the source nodes and all other
reachable nodes for a weighted graph.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>sources</strong> (<em>mgp.List[mgp.Vertex]</em>) – Starting nodes for paths. If this is a set containing a
single node, then all paths computed by this function will start
from that node. If there are two or more nodes in the set, the
computed paths may begin from any one of the start nodes.</li></ul><ul><li><strong>cutoff</strong> (<em>mgp.Nullable[int]</em>) – (default=None)
Depth to stop the search. Only return paths with <code>length &lt;= cutoff</code>.</li></ul><ul><li><strong>weight</strong> (<em>string function</em>) – If this is a string, then edge weights will be accessed via the
edge attribute with this key (that is, the weight of the edge
joining <code>u</code> to <code>v</code> will be <code>G.edges[u, v][weight]</code>). If no
such edge attribute exists, the weight of the edge is assumed to
be one. If this is a function, the weight of an edge is the value
returned by the function. The function must accept exactly three
positional arguments: the two endpoints of an edge and the
dictionary of edge attributes for that edge. The function must
return a number.</li></ul><p><strong>Returns</strong></p><p>A dictionary of shortest paths keyed by target.</p><p><strong>Return type</strong></p><p>mgp.Record(target=mgp.Vertex, path=mgp.List[mgp.Vertex])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="multi_source_dijkstra_path_lengthctx-sources-cutoff-weight"></a><code>multi_source_dijkstra_path_length(ctx, sources, cutoff, weight)</code><a class="hash-link" href="#multi_source_dijkstra_path_lengthctx-sources-cutoff-weight" title="Direct link to heading">#</a></h2><p>Find shortest weighted path lengths in <code>G</code> from a given set of
source nodes.</p><p>Compute the shortest path length between any of the source nodes and
all other reachable nodes for a weighted graph.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>sources</strong> (<em>mgp.List[mgp.Vertex]</em>) – Starting nodes for paths. If this is a set containing a
single node, then all paths computed by this function will start
from that node. If there are two or more nodes in the set, the
computed paths may begin from any one of the start nodes.</li></ul><ul><li><strong>cutoff</strong> (<em>mgp.Nullable[int]</em>) – (default=None)
Depth to stop the search. Only return paths with <code>length &lt;= cutoff</code>.</li></ul><ul><li><strong>weight</strong> (<em>str</em>) – If this is a string, then edge weights will be accessed via the
edge attribute with this key (that is, the weight of the edge
joining <code>u</code> to <code>v</code> will be <code>G.edges[u, v][weight]</code>). If no
such edge attribute exists, the weight of the edge is assumed to
be one. If this is a function, the weight of an edge is the value
returned by the function. The function must accept exactly three
positional arguments: the two endpoints of an edge and the
dictionary of edge attributes for that edge. The function must
return a number.</li></ul><p><strong>Returns</strong></p><p>Dict keyed by node to shortest path length to nearest source.</p><p><strong>Return type</strong></p><p>mgp.Record(target=mgp.Vertex, length=mgp.Number)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="node_boundaryctx-nbunch1-bunch2"></a><code>node_boundary(ctx, nbunch1, bunch2)</code><a class="hash-link" href="#node_boundaryctx-nbunch1-bunch2" title="Direct link to heading">#</a></h2><p>Returns the node boundary of <code>nbunch1</code>.</p><p>The <em>node boundary</em> of a set <code>S</code> with respect to a set <code>T</code> is the
set of nodes <code>v</code> in <code>T</code> such that for some <code>u</code> in <code>S</code>, there is an
edge joining <code>u</code> to <code>v</code>. If <code>T</code> is not specified, it is assumed to
be the set of all nodes not in <code>S</code>.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>nbunch1</strong> (<em>mgp.List[mgp.Vertex]</em>) – List of nodes in the graph representing the set of nodes
whose node boundary will be returned. (This is the set <code>S</code> from
the definition above.)</li></ul><ul><li><strong>nbunch2</strong> (<em>mgp.Nullable[mgp.List[mgp.Vertex]]</em>) – List of nodes representing the target (or “exterior”) set of
nodes. (This is the set <code>T</code> from the definition above.) If not
specified, this is assumed to be the set of all nodes in <code>G</code>
not in <code>nbunch1</code>.</li></ul><p><strong>Returns</strong></p><p>The node boundary of <code>nbunch1</code> with respect to <code>nbunch2</code>.</p><p><strong>Return type</strong></p><p>mgp.Record(boundary=mgp.List[mgp.Vertex])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="node_connectivityctx-source-target"></a><code>node_connectivity(ctx, source, target)</code><a class="hash-link" href="#node_connectivityctx-source-target" title="Direct link to heading">#</a></h2><p>Returns an approximation for node connectivity for a graph or digraph <code>G</code>.</p><p><em>Node connectivity</em> is equal to the minimum number of nodes that
must be removed to disconnect <code>G</code> or render it trivial. By Menger’s theorem,
this is equal to the number of node independent paths (paths that
share no nodes other than <code>source</code> and <code>target</code>).</p><p>If <code>source</code> and <code>target</code> nodes are provided, this function returns the
local node connectivity: the minimum number of nodes that must be
removed to break all paths from source to <code>target</code> in <code>G</code>.</p><p>This algorithm is based on a fast approximation that gives a strict lower
bound on the actual number of node independent paths between two nodes.
It works for both directed and undirected graphs.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>source</strong> (<em>mgp.Nullable[mgp.Vertex]</em>) – (default=None)
Source node.</li></ul><ul><li><strong>target</strong> (<em>mgp.Nullable[mgp.Vertex]</em>) – (default=None)
Target node.</li></ul><p><strong>Returns</strong></p><p>Node connectivity of <code>G</code>, or local node connectivity if <code>source</code>
and <code>target</code> are provided.</p><p><strong>Return type</strong></p><p>mgp.Record(connectivity=int)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="node_expansionctx-s"></a><code>node_expansion(ctx, s)</code><a class="hash-link" href="#node_expansionctx-s" title="Direct link to heading">#</a></h2><p>Returns the node expansion of the set <code>S</code>.</p><p>The <em>node expansion</em> is the quotient of the size of the node
boundary of <code>S</code> and the cardinality of <code>S</code>.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>s</strong> (<em>mgp.List[mgp.Vertex]</em>) – A sequence of nodes in <code>G</code>.</li></ul><p><strong>Returns</strong></p><p>The node expansion of the set <code>S</code>.</p><p><strong>Return type</strong></p><p>mgp.Record(node_expansion=mgp.Number)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="non_randomnessctx-k"></a><code>non_randomness(ctx, k)</code><a class="hash-link" href="#non_randomnessctx-k" title="Direct link to heading">#</a></h2><p>Compute the non-randomness of graph <code>G</code>.</p><p>The first returned value <code>non_randomness</code> is the sum of non-randomness
values of all edges within the graph (where the non-randomness of an edge
tends to be small when the two nodes linked by that edge are from two different
communities).</p><p>The second computed value <code>relative_non_randomness</code> is a relative measure
that indicates to what extent graph <code>G</code> is different from random graphs in terms
of probability. When it is close to 0, the graph tends to be more
likely generated by an Erdos Renyi model.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>k</strong> (<em>mgp.Nullable[int]</em>) – (default=None)
The number of communities in <code>G</code>.
If <code>k</code> is not set, the function will use a default community
detection algorithm to set it.</li></ul><p><strong>Returns</strong></p><p>Non-randomness and Relative non-randomness of the graph.</p><p><strong>Return type</strong></p><p>mgp.Record(non_randomness=float, relative_non_randomness=float)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="pagerankctx-alpha-personalization-max_iter-tol-nstart-weight-dangling"></a><code>pagerank(ctx, alpha, personalization, max_iter, tol, nstart, weight, dangling)</code><a class="hash-link" href="#pagerankctx-alpha-personalization-max_iter-tol-nstart-weight-dangling" title="Direct link to heading">#</a></h2><p>Returns the PageRank of the nodes in the graph.</p><p><em>PageRank</em> computes a ranking of the nodes in the graph <code>G</code> based on
the structure of the incoming links. It was originally designed as
an algorithm to rank web pages.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>alpha</strong> (<em>mgp.Number</em>) – (default=0.85)
Damping parameter for PageRank.</li></ul><ul><li><strong>personalization</strong> (<em>mgp.Nullable[str]</em>) – (default=None)
The “personalization vector” consisting of a dictionary with a
subset of graph nodes as a key and maps personalization value
for each subset. At least one personalization value must be non-zero.
If not specified, a nodes personalization value will be zero.
By default, a uniform distribution is used.</li></ul><ul><li><strong>max_iter</strong> (<em>int</em>) – (default=100)
Maximum number of iterations in power method eigenvalue solver.</li></ul><ul><li><strong>tol</strong> (<em>mgp.Number</em>) – (default=1e-06)
Error tolerance used to check convergence in power method solver.</li></ul><ul><li><strong>nstart</strong> (<em>mgp.Nullable[str]</em>) – (default=None)
Starting value of PageRank iteration for each node.</li></ul><ul><li><strong>weight</strong> (<em>mgp.Nullable[str]</em>) – (default=’weight’)
Edge data key to use as weight. If <code>None</code>, weights are set to 1.</li></ul><ul><li><strong>dangling</strong> (<em>mgp.Nullable[str]</em>) – (default=None)
The outedges to be assigned to any “dangling” nodes, i.e., nodes without
any outedges. The dict key is the node the outedge points to and the dict
value is the weight of that outedge. By default, dangling nodes are given
outedges according to the personalization vector (uniform if not
specified). This must be selected to result in an irreducible transition
matrix. It may be common to have the dangling dict to be the same as
the personalization dict.</li></ul><p><strong>Returns</strong></p><p>Dictionary of nodes with PageRank as value.</p><p><strong>Return type</strong></p><p>mgp.Record(node=mgp.Vertex, rank=float)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="reciprocityctx-nodes"></a><code>reciprocity(ctx, nodes)</code><a class="hash-link" href="#reciprocityctx-nodes" title="Direct link to heading">#</a></h2><p>Compute the reciprocity in a directed graph.</p><p>The <em>reciprocity</em> of a directed graph is defined as the ratio
of the number of edges pointing in both directions to the total
number of edges in the graph.</p><p>The reciprocity of a single node <code>u</code> is defined similarly,
it is the ratio of the number of edges in both directions to
the total number of edges attached to node <code>u</code>.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>nodes</strong> (<em>mgp.Nullable[mgp.List[mgp.Vertex]]</em>) – (default=None)
Compute reciprocity for nodes in this container.</li></ul><p><strong>Returns</strong></p><p>Reciprocity keyed by node label.</p><p><strong>Return type</strong></p><p>mgp.Record(node=mgp.Nullable[mgp.Vertex], reciprocity=mgp.Nullable[float])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="shortest_pathctx-source-target-weight-method"></a><code>shortest_path(ctx, source, target, weight, method)</code><a class="hash-link" href="#shortest_pathctx-source-target-weight-method" title="Direct link to heading">#</a></h2><p>Compute shortest paths in the graph.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>source</strong> (<em>mgp.Nullable[mgp.Vertex]</em>) – (default=None)
Starting node for the path. If not specified, compute shortest
paths for each possible starting node.</li></ul><ul><li><strong>target</strong> (<em>mgp.Nullable[mgp.Vertex]</em>) – (default=None)
Ending node for the path. If not specified, compute shortest
paths to all possible nodes.</li></ul><ul><li><strong>weight</strong> (<em>mgp.Nullable[str]</em>) – (default=None)
If <code>None</code>, every edge has weight/distance/cost 1.
If a string, use this edge attribute as the edge weight.
Any edge attribute not present defaults to 1.</li></ul><ul><li><strong>method</strong> (<em>str</em>) – (default=’dijkstra’)
The algorithm used to compute the path.
Supported options: ‘dijkstra’, ‘bellman-ford’.
Other inputs produce a ValueError.
If <code>weight</code> is <code>None</code>, unweighted graph methods are used
and this suggestion is ignored.</li></ul><p><strong>Returns</strong></p><p>All returned paths include both the <code>source</code> and <code>target</code> in the path.
If the <code>source</code> and <code>target</code> are both specified, return a single list
of nodes in a shortest path from the <code>source</code> to the <code>target</code>.
If only the <code>source</code> is specified, return a dictionary keyed by
targets with a list of nodes in a shortest path from the <code>source</code>
to one of the targets.
If only the <code>target</code> is specified, return a dictionary keyed by
sources with a list of nodes in a shortest path from one of the
sources to the <code>target</code>.
If neither the <code>source</code> nor <code>target</code> are specified return a dictionary
of dictionaries with <code>path[source][target]=[list of nodes in path]</code>.</p><p><strong>Return type</strong></p><p>mgp.Record(source=mgp.Vertex, target=mgp.Vertex, path=mgp.List[mgp.Vertex])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="shortest_path_lengthctx-source-target-weight-method"></a><code>shortest_path_length(ctx, source, target, weight, method)</code><a class="hash-link" href="#shortest_path_lengthctx-source-target-weight-method" title="Direct link to heading">#</a></h2><p>Compute shortest path lengths in the graph.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>source</strong> (<em>mgp.Nullable[mgp.Vertex]</em>) – (default=None)
Starting node for the path.
If not specified, compute shortest path lengths using all nodes as
source nodes.</li></ul><ul><li><strong>target</strong> (<em>mgp.Nullable[mgp.Vertex]</em>) – (default=None)
Ending node for the path.
If not specified, compute shortest path lengths using all nodes as
target nodes.</li></ul><ul><li><strong>weight</strong> (<em>mgp.Nullable[str]</em>) – (default=None)
If <code>None</code>, every edge has weight/distance/cost 1.
If a string, use this edge attribute as the edge weight.
Any edge attribute not present defaults to 1.</li></ul><ul><li><strong>method</strong> (<em>str</em>) – (default=’dijkstra’)
The algorithm to use to compute the path length.
Supported options: ‘dijkstra’, ‘bellman-ford’.
Other inputs produce a ValueError.
If <code>weight</code> is <code>None</code>, unweighted graph methods are used
and this suggestion is ignored.</li></ul><p><strong>Returns</strong></p><p>If the <code>source</code> and <code>target</code> are both specified, return the length of
the shortest path from the <code>source</code> to the <code>target</code>.
If only the <code>source</code> is specified, return a dict keyed by <code>target</code>
to the shortest path length from the <code>source</code> to that <code>target</code>.
If only the <code>target</code> is specified, return a dict keyed by <code>source</code>
to the shortest path length from that <code>source</code> to the <code>target</code>.
If neither the <code>source</code> nor <code>target</code> are specified, return an iterator
over (source, dictionary) where dictionary is keyed by <code>target</code> to
shortest path length from <code>source</code> to that <code>target</code>.</p><p><strong>Return type</strong></p><p>mgp.Record(source=mgp.Vertex, target=mgp.Vertex, length=mgp.Number)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="simple_cyclesctx"></a><code>simple_cycles(ctx)</code><a class="hash-link" href="#simple_cyclesctx" title="Direct link to heading">#</a></h2><p>Find simple cycles (elementary circuits) of a directed graph.</p><p>A <em>simple cycle</em>, or <em>elementary circuit</em>, is a closed path where
no node appears twice. Two elementary circuits are distinct if they
are not cyclic permutations of each other.</p><p>This is a nonrecursive, iterator/generator version of Johnson’s
algorithm. There may be better algorithms for some cases.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><p><strong>Returns</strong></p><p>A list of elementary cycles in the graph.
Each cycle is represented by a list of nodes in the cycle.</p><p><strong>Return type</strong></p><p>mgp.Record(cycles=mgp.List[mgp.List[mgp.Vertex]])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="strongly_connected_componentsctx"></a><code>strongly_connected_components(ctx)</code><a class="hash-link" href="#strongly_connected_componentsctx" title="Direct link to heading">#</a></h2><p>Returns nodes in strongly connected components of a graph.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><p><strong>Returns</strong></p><p>A list of lists of nodes, one for each strongly connected
component of <code>G</code>.</p><p><strong>Return type</strong></p><p>mgp.Record(components=mgp.List[mgp.List[mgp.Vertex]])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="topological_sortctx"></a><code>topological_sort(ctx)</code><a class="hash-link" href="#topological_sortctx" title="Direct link to heading">#</a></h2><p>Returns nodes in topologically sorted order.</p><p>A <em>topological sort</em> is a non unique permutation of the nodes such that an
edge from <code>u</code> to <code>v</code> implies that <code>u</code> appears before <code>v</code> in the
topological sort order.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><p><strong>Returns</strong></p><p>A list of nodes in topological sorted order.</p><p><strong>Return type</strong></p><p>mgp.Record(nodes=mgp.Nullable[mgp.List[mgp.Vertex]])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="triadic_censusctx"></a><code>triadic_census(ctx)</code><a class="hash-link" href="#triadic_censusctx" title="Direct link to heading">#</a></h2><p>Determines the triadic census of a directed graph.</p><p>The <em>triadic census</em> is a count of how many of the 16 possible types of
triads are present in a directed graph.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><p><strong>Returns</strong></p><p>Dictionary with triad names as keys and number of occurrences as values.</p><p><strong>Return type</strong></p><p>mgp.Record(triad=str, count=int)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="voronoi_cellsctx-center_nodes-weight"></a><code>voronoi_cells(ctx, center_nodes, weight)</code><a class="hash-link" href="#voronoi_cellsctx-center_nodes-weight" title="Direct link to heading">#</a></h2><p>Returns the Voronoi cells centered at center_nodes with respect
to the shortest-path distance metric.</p><p>If <code>C</code> is a set of nodes in the graph and <code>c</code> is an element of <code>C</code>,
the <em>Voronoi cell</em> centered at a node <code>c</code> is the set of all nodes
<code>v</code> that are closer to <code>c</code> than to any other center node in <code>C</code> with
respect to the shortest-path distance metric.</p><p>For directed graphs, this will compute the “outward” Voronoi cells
in which distance is measured from the center nodes to the target node.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>center_nodes</strong> (<em>mgp.List[mgp.Vertex]</em>) – A nonempty set of nodes in the graph <code>G</code> that represent the
center of the Voronoi cells.</li></ul><ul><li><strong>weight</strong> (<em>str</em>) – (default=’weight’)
The edge attribute (or an arbitrary function) representing the
weight of an edge. This keyword argument is as described in the
documentation for <code>networkx.multi_source_dijkstra_path</code>,
for example.</li></ul><p><strong>Returns</strong></p><p>A mapping from center node to set of all nodes in the graph
closer to that center node than to any other center node. The
keys of the dictionary are the element of <code>center_nodes</code>, and
the values of the dictionary form a partition of the nodes of
<code>G</code>.</p><p><strong>Return type</strong></p><p>mgp.Record(center=mgp.Vertex, cell=mgp.List[mgp.Vertex])</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="wiener_indexctx-weight"></a><code>wiener_index(ctx, weight)</code><a class="hash-link" href="#wiener_indexctx-weight" title="Direct link to heading">#</a></h2><p>Returns the Wiener index of the given graph.</p><p>The <em>Wiener index</em> of a graph is the sum of the shortest-path
distances between each pair of reachable nodes. For pairs of nodes
in undirected graphs, only one orientation of the pair is counted.</p><p><strong>Parameters</strong></p><ul><li><strong>ctx</strong> (<em>mgp.ProcCtx</em>) – The context of the procedure being executed.</li></ul><ul><li><strong>weight</strong> (<em>mgp.Nullable[str]</em>) – (default=None)
The edge attribute to use as distance when computing
shortest-path distances. This is passed directly to the
<code>networkx.shortest_path_length</code> function.</li></ul><p><strong>Returns</strong></p><p>The Wiener index of the graph <code>G</code>.</p><p><strong>Return type</strong></p><p>mgp.Record(wiener_index=mgp.Number)</p></div><footer class="row docusaurus-mt-lg"><div class="col"><a href="https://github.com/memgraph/docs/tree/master/memgraph_versioned_docs/version-1.3.0/reference-guide/networkx/nxalg.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_3DPF"></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/memgraph/1.3.0/reference-guide/networkx/graph-analyzer"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« Graph Analyzer</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/memgraph/1.3.0/reference-guide/networkx/wcc"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Weakly Connected Components »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#all_shortest_pathsctx-source-target-weight-method" class="table-of-contents__link"><code>all_shortest_paths(ctx, source, target, weight, method)</code></a></li><li><a href="#all_simple_pathsctx-source-target-cutoff" class="table-of-contents__link"><code>all_simple_paths(ctx, source, target, cutoff)</code></a></li><li><a href="#ancestorsctx-source" class="table-of-contents__link"><code>ancestors(ctx, source)</code></a></li><li><a href="#betweenness_centralityctx-k-normalized-weight-endpoints-seed" class="table-of-contents__link"><code>betweenness_centrality(ctx, k, normalized, weight, endpoints, seed)</code></a></li><li><a href="#bfs_edgesctx-source-reverse-depth_limit" class="table-of-contents__link"><code>bfs_edges(ctx, source, reverse, depth_limit)</code></a></li><li><a href="#bfs_predecessorsctx-source-depth_limit" class="table-of-contents__link"><code>bfs_predecessors(ctx, source, depth_limit)</code></a></li><li><a href="#bfs_successorsctx-source-depth_limit" class="table-of-contents__link"><code>bfs_successors(ctx, source, depth_limit)</code></a></li><li><a href="#bfs_treectx-source-reverse-depth_limit" class="table-of-contents__link"><code>bfs_tree(ctx, source, reverse, depth_limit)</code></a></li><li><a href="#biconnected_componentsctx" class="table-of-contents__link"><code>biconnected_components(ctx)</code></a></li><li><a href="#bridgesctx-root" class="table-of-contents__link"><code>bridges(ctx, root)</code></a></li><li><a href="#centerctx" class="table-of-contents__link"><code>center(ctx)</code></a></li><li><a href="#chain_decompositionctx-root" class="table-of-contents__link"><code>chain_decomposition(ctx, root)</code></a></li><li><a href="#check_planarityctx" class="table-of-contents__link"><code>check_planarity(ctx)</code></a></li><li><a href="#clusteringctx-nodes-weight" class="table-of-contents__link"><code>clustering(ctx, nodes, weight)</code></a></li><li><a href="#communicabilityctx" class="table-of-contents__link"><code>communicability(ctx)</code></a></li><li><a href="#core_numberctx" class="table-of-contents__link"><code>core_number(ctx)</code></a></li><li><a href="#degree_assortativity_coefficientctx-x-y-weight-nodes" class="table-of-contents__link"><code>degree_assortativity_coefficient(ctx, x, y, weight, nodes)</code></a></li><li><a href="#descendantsctx-source" class="table-of-contents__link"><code>descendants(ctx, source)</code></a></li><li><a href="#dfs_postorder_nodesctx-source-depth_limit" class="table-of-contents__link"><code>dfs_postorder_nodes(ctx, source, depth_limit)</code></a></li><li><a href="#dfs_predecessorsctx-source-depth_limit" class="table-of-contents__link"><code>dfs_predecessors(ctx, source, depth_limit)</code></a></li><li><a href="#dfs_preorder_nodesctx-source-depth_limit" class="table-of-contents__link"><code>dfs_preorder_nodes(ctx, source, depth_limit)</code></a></li><li><a href="#dfs_successorsctx-source-depth_limit" class="table-of-contents__link"><code>dfs_successors(ctx, source, depth_limit)</code></a></li><li><a href="#dfs_treectx-source-depth_limit" class="table-of-contents__link"><code>dfs_tree(ctx, source, depth_limit)</code></a></li><li><a href="#diameterctx" class="table-of-contents__link"><code>diameter(ctx)</code></a></li><li><a href="#dominance_frontiersctx-start" class="table-of-contents__link"><code>dominance_frontiers(ctx, start)</code></a></li><li><a href="#dominating_setctx-start" class="table-of-contents__link"><code>dominating_set(ctx, start)</code></a></li><li><a href="#edge_bfsctx-source-orientation" class="table-of-contents__link"><code>edge_bfs(ctx, source, orientation)</code></a></li><li><a href="#edge_dfsctx-source-orientation" class="table-of-contents__link"><code>edge_dfs(ctx, source, orientation)</code></a></li><li><a href="#find_cliquesctx" class="table-of-contents__link"><code>find_cliques(ctx)</code></a></li><li><a href="#find_cyclectx-source-orientation" class="table-of-contents__link"><code>find_cycle(ctx, source, orientation)</code></a></li><li><a href="#flow_hierarchyctx-weight" class="table-of-contents__link"><code>flow_hierarchy(ctx, weight)</code></a></li><li><a href="#global_efficiencyctx" class="table-of-contents__link"><code>global_efficiency(ctx)</code></a></li><li><a href="#greedy_colorctx-strategy-interchange" class="table-of-contents__link"><code>greedy_color(ctx, strategy, interchange)</code></a></li><li><a href="#has_eulerian_pathctx" class="table-of-contents__link"><code>has_eulerian_path(ctx)</code></a></li><li><a href="#has_pathctx-source-target" class="table-of-contents__link"><code>has_path(ctx, source, target)</code></a></li><li><a href="#immediate_dominatorsctx-start" class="table-of-contents__link"><code>immediate_dominators(ctx, start)</code></a></li><li><a href="#is_arborescencectx" class="table-of-contents__link"><code>is_arborescence(ctx)</code></a></li><li><a href="#is_at_freectx" class="table-of-contents__link"><code>is_at_free(ctx)</code></a></li><li><a href="#is_bipartitectx" class="table-of-contents__link"><code>is_bipartite(ctx)</code></a></li><li><a href="#is_branchingctx" class="table-of-contents__link"><code>is_branching(ctx)</code></a></li><li><a href="#is_chordalctx" class="table-of-contents__link"><code>is_chordal(ctx)</code></a></li><li><a href="#is_distance_regularctx" class="table-of-contents__link"><code>is_distance_regular(ctx)</code></a></li><li><a href="#is_edge_coverctx-cover" class="table-of-contents__link"><code>is_edge_cover(ctx, cover)</code></a></li><li><a href="#is_eulerianctx" class="table-of-contents__link"><code>is_eulerian(ctx)</code></a></li><li><a href="#is_forestctx" class="table-of-contents__link"><code>is_forest(ctx)</code></a></li><li><a href="#is_isolatectx-n" class="table-of-contents__link"><code>is_isolate(ctx, n)</code></a></li><li><a href="#is_isomorphicctx-nodes1-edges1-nodes2-edges2" class="table-of-contents__link"><code>is_isomorphic(ctx, nodes1, edges1, nodes2, edges2)</code></a></li><li><a href="#is_semieulerianctx" class="table-of-contents__link"><code>is_semieulerian(ctx)</code></a></li><li><a href="#is_simple_pathctx-nodes" class="table-of-contents__link"><code>is_simple_path(ctx, nodes)</code></a></li><li><a href="#is_strongly_regularctx" class="table-of-contents__link"><code>is_strongly_regular(ctx)</code></a></li><li><a href="#is_tournamentctx" class="table-of-contents__link"><code>is_tournament(ctx)</code></a></li><li><a href="#is_treectx" class="table-of-contents__link"><code>is_tree(ctx)</code></a></li><li><a href="#isolatesctx" class="table-of-contents__link"><code>isolates(ctx)</code></a></li><li><a href="#jaccard_coefficientctx-ebunch" class="table-of-contents__link"><code>jaccard_coefficient(ctx, ebunch)</code></a></li><li><a href="#k_clique_communitiesctx-k-cliques" class="table-of-contents__link"><code>k_clique_communities(ctx, k, cliques)</code></a></li><li><a href="#k_componentsctx-density" class="table-of-contents__link"><code>k_components(ctx, density)</code></a></li><li><a href="#k_edge_componentsctx-k" class="table-of-contents__link"><code>k_edge_components(ctx, k)</code></a></li><li><a href="#local_efficiencyctx" class="table-of-contents__link"><code>local_efficiency(ctx)</code></a></li><li><a href="#lowest_common_ancestorctx-node1-node2" class="table-of-contents__link"><code>lowest_common_ancestor(ctx, node1, node2)</code></a></li><li><a href="#maximal_matchingctx" class="table-of-contents__link"><code>maximal_matching(ctx)</code></a></li><li><a href="#minimum_spanning_treectx-weight-algorithm-ignore_nan" class="table-of-contents__link"><code>minimum_spanning_tree(ctx, weight, algorithm, ignore_nan)</code></a></li><li><a href="#multi_source_dijkstra_pathctx-ources-cutoff-weight" class="table-of-contents__link"><code>multi_source_dijkstra_path(ctx, ources, cutoff, weight)</code></a></li><li><a href="#multi_source_dijkstra_path_lengthctx-sources-cutoff-weight" class="table-of-contents__link"><code>multi_source_dijkstra_path_length(ctx, sources, cutoff, weight)</code></a></li><li><a href="#node_boundaryctx-nbunch1-bunch2" class="table-of-contents__link"><code>node_boundary(ctx, nbunch1, bunch2)</code></a></li><li><a href="#node_connectivityctx-source-target" class="table-of-contents__link"><code>node_connectivity(ctx, source, target)</code></a></li><li><a href="#node_expansionctx-s" class="table-of-contents__link"><code>node_expansion(ctx, s)</code></a></li><li><a href="#non_randomnessctx-k" class="table-of-contents__link"><code>non_randomness(ctx, k)</code></a></li><li><a href="#pagerankctx-alpha-personalization-max_iter-tol-nstart-weight-dangling" class="table-of-contents__link"><code>pagerank(ctx, alpha, personalization, max_iter, tol, nstart, weight, dangling)</code></a></li><li><a href="#reciprocityctx-nodes" class="table-of-contents__link"><code>reciprocity(ctx, nodes)</code></a></li><li><a href="#shortest_pathctx-source-target-weight-method" class="table-of-contents__link"><code>shortest_path(ctx, source, target, weight, method)</code></a></li><li><a href="#shortest_path_lengthctx-source-target-weight-method" class="table-of-contents__link"><code>shortest_path_length(ctx, source, target, weight, method)</code></a></li><li><a href="#simple_cyclesctx" class="table-of-contents__link"><code>simple_cycles(ctx)</code></a></li><li><a href="#strongly_connected_componentsctx" class="table-of-contents__link"><code>strongly_connected_components(ctx)</code></a></li><li><a href="#topological_sortctx" class="table-of-contents__link"><code>topological_sort(ctx)</code></a></li><li><a href="#triadic_censusctx" class="table-of-contents__link"><code>triadic_census(ctx)</code></a></li><li><a href="#voronoi_cellsctx-center_nodes-weight" class="table-of-contents__link"><code>voronoi_cells(ctx, center_nodes, weight)</code></a></li><li><a href="#wiener_indexctx-weight" class="table-of-contents__link"><code>wiener_index(ctx, weight)</code></a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Documentation</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/memgraph/overview">Memgraph DB</a></li><li class="footer__item"><a class="footer__link-item" href="/memgraph-lab">Memgraph Lab</a></li><li class="footer__item"><a class="footer__link-item" href="/cypher-manual">Cypher manual</a></li><li class="footer__item"><a class="footer__link-item" href="/mage">MAGE</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/memgraphdb" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://discourse.memgraph.com" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Developer Forum<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://twitter.com/memgraphdb" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/memgraph" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://www.youtube.com/channel/UCZ3HOJvHGxtQ_JHxOselBYg" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Youtube<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="margin-bottom--sm"><a href="https://memgraph.com" target="_blank" rel="noopener noreferrer" class="footerLogoLink_MyFc"><img src="/img/Memgraph-logo-white-rgb.png" alt="Memgraph Logo" class="themedImage_1VuW themedImage--light_3UqQ footer__logo"><img src="/img/Memgraph-logo-white-rgb.png" alt="Memgraph Logo" class="themedImage_1VuW themedImage--dark_hz6m footer__logo"></a></div><div class="footer__copyright">Copyright © 2021 Memgraph. Built by developers, for developers!</div></div></div></footer></div>
<script src="/assets/js/runtime~main.e0378192.js"></script>
<script src="/assets/js/main.408798e3.js"></script>
</body>
</html>