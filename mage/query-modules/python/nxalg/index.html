<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.4">
<link rel="search" type="application/opensearchdescription+xml" title="Memgraph Docs" href="/opensearch.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Encode+Sans+Condensed:500,600">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400, 500,600">
<script src="https://docs.memgraph.com/js/load-analytics.js"></script>
<script src="https://kit.fontawesome.com/3a9f2eb5b9.js"></script><title data-react-helmet="true">nxalg | Memgraph Docs</title><meta data-react-helmet="true" property="og:url" content="https://docs.memgraph.com/mage/query-modules/python/nxalg"><meta data-react-helmet="true" name="docsearch:language" content="en"><meta data-react-helmet="true" name="docsearch:version" content="current"><meta data-react-helmet="true" name="docsearch:docusaurus_tag" content="docs-mage-current"><meta data-react-helmet="true" property="og:title" content="nxalg | Memgraph Docs"><meta data-react-helmet="true" name="description" content="&lt;span"><meta data-react-helmet="true" property="og:description" content="&lt;span"><link data-react-helmet="true" rel="shortcut icon" href="/img/social-logo-round-corners.png"><link data-react-helmet="true" rel="canonical" href="https://docs.memgraph.com/mage/query-modules/python/nxalg"><link data-react-helmet="true" rel="alternate" href="https://docs.memgraph.com/mage/query-modules/python/nxalg" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://docs.memgraph.com/mage/query-modules/python/nxalg" hreflang="x-default"><link data-react-helmet="true" rel="preconnect" href="https://BH4D9OD16A-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.e0c227af.css">
<link rel="preload" href="/assets/js/runtime~main.cc99452f.js" as="script">
<link rel="preload" href="/assets/js/main.632830b3.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/memgraph-logo-500x380.png" alt="Memgraph Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/memgraph-logo-500x380.png" alt="Memgraph Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">Docs</b></a><div class="navbar__item dropdown dropdown--hoverable"><a class="navbar__item navbar__link" href="/memgraph/overview">Memgraph DB</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/memgraph/getting-started">Getting started</a></li><li><a class="dropdown__link" href="/memgraph/installation">Installation</a></li><li><a class="dropdown__link" href="/memgraph/import-data">Import data</a></li><li><a class="dropdown__link" href="/memgraph/connect-to-memgraph">Connect to Memgraph</a></li><li><a class="dropdown__link" href="/memgraph/reference-guide">Reference guide</a></li></ul></div><a class="navbar__item navbar__link" href="/memgraph-lab/">Memgraph Lab</a><div class="navbar__item dropdown dropdown--hoverable"><a class="navbar__item navbar__link" href="/cypher-manual/">Cypher manual</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/cypher-manual/">Overview</a></li><li><a class="dropdown__link" href="/cypher-manual/functions">Functions</a></li><li><a class="dropdown__link" href="/cypher-manual/clauses">Clauses</a></li><li><a class="dropdown__link" href="/cypher-manual/other-features">Other features</a></li><li><a class="dropdown__link" href="/cypher-manual/differences">Differences</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/mage">MAGE</a><ul class="dropdown__menu"><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/mage">Overview</a></li><li><a class="dropdown__link" href="/mage/installation">Installation</a></li><li><a class="dropdown__link" href="/mage/usage/calling-procedures">Usage</a></li><li><a class="dropdown__link" href="/mage/contributing">Contributing</a></li><li><a class="dropdown__link" href="/mage/getting-help">Getting help</a></li></ul></div><a class="navbar__item navbar__link" href="/help-center">Help Center</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__item navbar__link" href="/memgraph/overview">1.6.1</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/memgraph/next/overview">Unreleased 🚧</a></li><li><a class="dropdown__link" href="/memgraph/overview">1.6.1</a></li><li><a class="dropdown__link" href="/memgraph/1.6.0/overview">1.6.0</a></li><li><a class="dropdown__link" href="/memgraph/1.5.0/overview">1.5.0</a></li><li><a class="dropdown__link" href="/memgraph/1.4.0/overview">1.4.0</a></li><li><a class="dropdown__link" href="/memgraph/1.3.0/overview">1.3.0</a></li></ul></div><a href="https://github.com/memgraph" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div><div class="searchBox_1Doo"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button" title="Scroll to top"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/mage/">MAGE overview</a></li><li class="menu__list-item"><a class="menu__link" href="/mage/installation">Installation</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Usage</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">Query modules</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/mage/query-modules/cpp/betweenness-centrality">betweenness_centrality</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/mage/query-modules/cpp/biconnected-components">biconnected_components</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/mage/query-modules/cpp/bipartite-matching">bipartite_matching</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/mage/query-modules/cpp/bridges">bridges</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/mage/query-modules/cpp/cycles">cycles</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/mage/query-modules/python/distance-calculator">distance_calculator</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/mage/query-modules/python/graph-analyzer">graph_analyzer</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/mage/query-modules/python/graph-coloring">graph_coloring</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/mage/query-modules/python/nxalg">nxalg</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/mage/query-modules/python/pagerank">pagerank</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/mage/query-modules/python/set-cover">set_cover</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/mage/query-modules/python/tsp">tsp</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/mage/query-modules/python/union-find">union_find</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/mage/query-modules/python/vrp">vrp</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/mage/query-modules/cpp/weakly-connected-components">weakly_connected_components</a></li></ul></li><li class="menu__list-item"><a class="menu__link" href="/mage/contributing">Contributing</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Getting help</a></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="markdown"><header><h1 class="h1Heading_27L5">nxalg</h1></header><p><a href="https://github.com/memgraph/mage/blob/main/python/nxalg.py" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/badge/source-nxalg-FB6E00?logo=github&amp;style=for-the-badge" alt="docs-source"></a></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="abstract"></a>Abstract<a class="hash-link" href="#abstract" title="Direct link to heading">#</a></h2><p>This module, named <strong>nxalg</strong>, provides a comprehensive set of thin wrappers around most of the algorithms present in the <a href="https://networkx.org/" target="_blank" rel="noopener noreferrer">NetworkX</a> package. The wrapper functions now have the capability to create a NetworkX compatible graph-like object that can stream the native database graph directly saving on memory usage significantly.</p><table><thead><tr><th>Trait</th><th>Value</th></tr></thead><tbody><tr><td><strong>Module type</strong></td><td><span style="background-color:#FB6E00;border-radius:2px;color:#fff;padding:0.2rem"><strong>module</strong></span></td></tr><tr><td><strong>Implementation</strong></td><td><span style="background-color:#FB6E00;border-radius:2px;color:#fff;padding:0.2rem"><strong>Python</strong></span></td></tr><tr><td><strong>Graph direction</strong></td><td><span style="background-color:#FB6E00;border-radius:2px;color:#fff;padding:0.2rem"><strong>directed</strong></span>/<span style="background-color:#FB6E00;border-radius:2px;color:#fff;padding:0.2rem"><strong>undirected</strong></span></td></tr><tr><td><strong>Edge weights</strong></td><td><span style="background-color:#FB6E00;border-radius:2px;color:#fff;padding:0.2rem"><strong>weighted</strong></span>/<span style="background-color:#FB6E00;border-radius:2px;color:#fff;padding:0.2rem"><strong>unweighted</strong></span></td></tr><tr><td><strong>Parallelism</strong></td><td><span style="background-color:#FB6E00;border-radius:2px;color:#fff;padding:0.2rem"><strong>sequential</strong></span></td></tr></tbody></table><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="procedures"></a>Procedures<a class="hash-link" href="#procedures" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="all_shortest_pathssource-target-weight-method"></a><code>all_shortest_paths(source, target, weight, method)</code><a class="hash-link" href="#all_shortest_pathssource-target-weight-method" title="Direct link to heading">#</a></h3><p>Compute all shortest simple paths in the graph. A simple path is a path with no repeated nodes.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input"></a>Input:<a class="hash-link" href="#input" title="Direct link to heading">#</a></h4><ul><li><code>source: Vertex</code> ➡ Starting node for the path.</li><li><code>target: Vertex</code> ➡ Ending node for the path.</li><li><code>weight: str(NULL)</code> ➡ If <code>NULL</code>, every edge has weight/distance/cost 1. If a string, use this edge attribute as the edge weight. Any edge attribute not present defaults to 1.</li><li><code>method: str(&quot;dijkstra&quot;)</code> ➡ The algorithm to use to compute the path lengths. Supported options: ‘dijkstra’, ‘bellman-ford’. Other inputs produce a ValueError. If <code>weight</code> is <code>None</code>, unweighted graph methods are used, and this suggestion is ignored.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output"></a>Output:<a class="hash-link" href="#output" title="Direct link to heading">#</a></h4><ul><li><code>paths: List[Vertex]</code> ➡ List of vertices for a certain path.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage"></a>Usage:<a class="hash-link" href="#usage" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH (n:Label), (m:Label)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.all_shortest_paths(n, m) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN paths;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="all_simple_pathssource-target-cutoff"></a><code>all_simple_paths(source, target, cutoff)</code><a class="hash-link" href="#all_simple_pathssource-target-cutoff" title="Direct link to heading">#</a></h3><p>Returns all simple paths in the graph <code>G</code> from source to target. A simple path is a path with no repeated nodes.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-1"></a>Input:<a class="hash-link" href="#input-1" title="Direct link to heading">#</a></h4><ul><li><code>source: Vertex</code> ➡ Starting node for the path.</li><li><code>target: Vertex</code> ➡ Ending node for the path.</li><li><code>cutoff: List[int](NULL)</code> ➡ Depth to stop the search. Only paths of <code>length &lt;= cutoff</code> are returned.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-1"></a>Output:<a class="hash-link" href="#output-1" title="Direct link to heading">#</a></h4><ul><li><code>paths: List[Vertex]</code> ➡ List of vertices for a certain path. If there are no paths between the source and target within the given cutoff there is no output.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-1"></a>Usage:<a class="hash-link" href="#usage-1" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH (n:Label), (m:Label)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.all_simple_paths(n, m, 5) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN paths;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="ancestorssource"></a><code>ancestors(source)</code><a class="hash-link" href="#ancestorssource" title="Direct link to heading">#</a></h3><p>Returns all nodes having a path to <code>source</code> in <code>G</code>.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-2"></a>Input:<a class="hash-link" href="#input-2" title="Direct link to heading">#</a></h4><ul><li><code>source: Vertex</code> ➡ Starting node. Calculates all nodes that have a path to <code>source</code></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-2"></a>Output:<a class="hash-link" href="#output-2" title="Direct link to heading">#</a></h4><ul><li><code>ancestors: List[Vertex]</code> ➡ List of vertices that have a path toward source node</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-2"></a>Usage:<a class="hash-link" href="#usage-2" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH (n:Label)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.ancestors(n) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN ancestors;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="betweenness_centralityk-normalized-weight-endpoints-seed"></a><code>betweenness_centrality(k, normalized, weight, endpoints, seed)</code><a class="hash-link" href="#betweenness_centralityk-normalized-weight-endpoints-seed" title="Direct link to heading">#</a></h3><p>Compute the shortest-path betweenness centrality for nodes. <em>Betweenness centrality</em> is a measure of centrality in a graph based on shortest paths. Centrality identifies the most important nodes within a graph.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-3"></a>Input:<a class="hash-link" href="#input-3" title="Direct link to heading">#</a></h4><ul><li><code>k: str(NULL)</code> ➡ If <code>k</code> is not <code>None</code>, use <code>k</code> node samples to estimate betweenness. The value of <code>k &lt;= n</code> where <code>n</code> is the number of nodes in the graph. Higher values give a better approximation.</li><li><code>normalized: bool(True)</code> ➡  If <code>True</code> the betweenness values are normalized by <code>2/((n-1)(n-2))</code> for graphs, and <code>1/((n-1)(n-2))</code> for directed graphs where <code>n</code> is the number of nodes in <code>G</code>.</li><li><code>weight: str(NULL)</code> ➡  If <code>None</code>, all edge weights are considered equal. Otherwise holds the name of the edge attribute used as weight.</li><li><code>endpoints: bool(False)</code> ➡  If <code>True</code>, includes the endpoints in the shortest path counts.</li><li><code>seed: int(NULL)</code> ➡  Indicator of random number generation state. Note that this is only used if <code>k</code> is not <code>None</code>.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-3"></a>Output:<a class="hash-link" href="#output-3" title="Direct link to heading">#</a></h4><ul><li><code>node: Vertex</code> ➡ Graph vertex for betweenness calculation</li><li><code>betweenness: double</code> ➡ Value of betweenness for a given node</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-3"></a>Usage:<a class="hash-link" href="#usage-3" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.betweenness_centrality(20, True) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN node, betweenness;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="bfs_edgessource-reverse-depth_limit"></a><code>bfs_edges(source, reverse, depth_limit)</code><a class="hash-link" href="#bfs_edgessource-reverse-depth_limit" title="Direct link to heading">#</a></h3><p>Iterate over edges in a breadth-first-search starting at source.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-4"></a>Input:<a class="hash-link" href="#input-4" title="Direct link to heading">#</a></h4><ul><li><code>source: Vertex</code> ➡  Specify starting node for breadth-first search; this function iterates over only those edges in the component reachable from this node.</li><li><code>reverse: bool(False)</code> ➡   If <code>True</code>, traverse a directed graph in the reverse direction.</li><li><code>depth_limit: int(NULL)</code> ➡  Specify the maximum search depth.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-4"></a>Output:<a class="hash-link" href="#output-4" title="Direct link to heading">#</a></h4><ul><li><code>edges: List[Edge]</code> ➡ List of edges in the breadth-first search.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-4"></a>Usage:<a class="hash-link" href="#usage-4" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH (n:Label)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.bfs_edges(n, False) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN edges;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="bfs_predecessorssource-depth_limit"></a><code>bfs_predecessors(source, depth_limit)</code><a class="hash-link" href="#bfs_predecessorssource-depth_limit" title="Direct link to heading">#</a></h3><p>Returns an iterator of predecessors in breadth-first-search from source.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-5"></a>Input:<a class="hash-link" href="#input-5" title="Direct link to heading">#</a></h4><ul><li><code>source: Vertex</code> ➡  Specify starting node for breadth-first search.</li><li><code>depth_limit: int(NULL)</code> ➡  Specify the maximum search depth.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-5"></a>Output:<a class="hash-link" href="#output-5" title="Direct link to heading">#</a></h4><ul><li><code>node: Vertex</code> ➡ Node in a graph</li><li><code>predecessors: List[Vertex]</code> ➡ List of predecessors of given node</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-5"></a>Usage:<a class="hash-link" href="#usage-5" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH (n:Label)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.bfs_predecessors(n, 10) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN node, predecessors;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="bfs_successorssource-depth_limit"></a><code>bfs_successors(source, depth_limit)</code><a class="hash-link" href="#bfs_successorssource-depth_limit" title="Direct link to heading">#</a></h3><p>Returns an iterator of successors in breadth-first-search from source.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-6"></a>Input:<a class="hash-link" href="#input-6" title="Direct link to heading">#</a></h4><ul><li><code>source: Vertex</code> ➡  Specify starting node for breadth-first search.</li><li><code>depth_limit: int(NULL)</code> ➡  Specify the maximum search depth.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-6"></a>Output:<a class="hash-link" href="#output-6" title="Direct link to heading">#</a></h4><ul><li><code>node: Vertex</code> ➡ Node in a graph</li><li><code>successors: List[Vertex]</code> ➡ List of successors of given node</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-6"></a>Usage:<a class="hash-link" href="#usage-6" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH (n:Label)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.bfs_successors(n, 5) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN node, successors;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="bfs_treesource-reverse-depth_limit"></a><code>bfs_tree(source, reverse, depth_limit)</code><a class="hash-link" href="#bfs_treesource-reverse-depth_limit" title="Direct link to heading">#</a></h3><p>Returns an oriented tree constructed from of a breadth-first-search starting at <code>source</code>.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-7"></a>Input:<a class="hash-link" href="#input-7" title="Direct link to heading">#</a></h4><ul><li><code>source: Vertex</code> ➡  Specify starting node for breadth-first search.</li><li><code>reversed: bool(False)</code> ➡  If <code>True</code>, traverse a directed graph in the reverse direction.</li><li><code>depth_limit: int(NULL)</code> ➡  Specify the maximum search depth.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-7"></a>Output:<a class="hash-link" href="#output-7" title="Direct link to heading">#</a></h4><ul><li><code>tree: List[Vertex]</code> ➡ An oriented tree in a list format.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-7"></a>Usage:<a class="hash-link" href="#usage-7" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH (n:Label)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.bfs_tree(n, True, 3) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN n, tree;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="biconnected_components"></a><code>biconnected_components()</code><a class="hash-link" href="#biconnected_components" title="Direct link to heading">#</a></h3><p>Returns a list of sets of nodes, one set for each biconnected
component of the graph</p><p><em>Biconnected components</em> are maximal subgraphs such that the removal of a
node (and all edges incident on that node) will not disconnect the
subgraph. Note that nodes may be part of more than one biconnected
component.  Those nodes are articulation points or cut vertices.  The
removal of articulation points will increase the number of connected
components of the graph.</p><p>Notice that by convention a dyad is considered a biconnected component.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-8"></a>Output:<a class="hash-link" href="#output-8" title="Direct link to heading">#</a></h4><ul><li><code>components: List[List[Vertex]]</code> ➡ A list of sets of nodes, one set for each biconnected component.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-8"></a>Usage:<a class="hash-link" href="#usage-8" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.biconnected_components() YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN components;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="bridgesroot"></a><code>bridges(root)</code><a class="hash-link" href="#bridgesroot" title="Direct link to heading">#</a></h3><p>Returns all bridges in a graph.</p><p>A <em>bridge</em> in a graph is an edge whose removal causes the number of
connected components of the graph to increase.  Equivalently, a bridge is an
edge that does not belong to any cycle.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-8"></a>Input:<a class="hash-link" href="#input-8" title="Direct link to heading">#</a></h4><ul><li><code>root: Vertex(NULL)</code> ➡   A node in the graph <code>G</code>. If specified, only the bridges in the connected components containing this node will be returned.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-9"></a>Output:<a class="hash-link" href="#output-9" title="Direct link to heading">#</a></h4><ul><li><code>bridges: List[Edge]</code> ➡  A list of edges in the graph whose removal disconnects the graph (or causes the number of connected components to increase).</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-9"></a>Usage:<a class="hash-link" href="#usage-9" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.bridges() YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN bridges;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="center"></a><code>center()</code><a class="hash-link" href="#center" title="Direct link to heading">#</a></h3><p>Returns the center of the graph <code>G</code>.</p><p>The <em>center</em> is the set of nodes with eccentricity equal to the radius.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-10"></a>Output:<a class="hash-link" href="#output-10" title="Direct link to heading">#</a></h4><ul><li><code>center: List[Vertex]</code> ➡ List of nodes in center.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-10"></a>Usage:<a class="hash-link" href="#usage-10" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.center() YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN center;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="chain_decompositionroot"></a><code>chain_decomposition(root)</code><a class="hash-link" href="#chain_decompositionroot" title="Direct link to heading">#</a></h3><p>Returns the chain decomposition of a graph.</p><p>The <em>chain decomposition</em> of a graph with respect to a depth-first
search tree is a set of cycles or paths derived from the set of
fundamental cycles of the tree in the following manner. Consider
each fundamental cycle with respect to the given tree, represented
as a list of edges beginning with the non tree edge oriented away
from the root of the tree. For each fundamental cycle, if it
overlaps with any previous fundamental cycle, just take the initial
non-overlapping segment, which is a path instead of a cycle. Each
cycle or path is called a <em>chain</em>.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-9"></a>Input:<a class="hash-link" href="#input-9" title="Direct link to heading">#</a></h4><ul><li><code>root: Vertex[NULL]</code> ➡   Optional. A node in the graph <code>G</code>. If specified, only the chain decomposition for the connected component containing this node will be returned. This node indicates the root of the depth-first Search tree.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-11"></a>Output:<a class="hash-link" href="#output-11" title="Direct link to heading">#</a></h4><ul><li><code>chains: List[List[Edge]]</code> ➡ A list of edges representing a chain. There is no guarantee on the orientation of the edges in each chain (for example, if a chain includes the edge joining nodes 1 and 2, the chain may include either (1, 2) or (2, 1)).</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-11"></a>Usage:<a class="hash-link" href="#usage-11" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH (n:Label)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.chain_decomposition(n) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN chains;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="check_planarity"></a><code>check_planarity()</code><a class="hash-link" href="#check_planarity" title="Direct link to heading">#</a></h3><p>Check if a graph is planar.</p><p>A graph is planar if it can be drawn in a plane without
any edge intersections.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-12"></a>Output:<a class="hash-link" href="#output-12" title="Direct link to heading">#</a></h4><ul><li><code>is_planar: bool</code> ➡ <code>True</code> if the graph is planar.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-12"></a>Usage:<a class="hash-link" href="#usage-12" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.check_planarity() YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN is_planar;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="clusteringnodes-weight"></a><code>clustering(nodes, weight)</code><a class="hash-link" href="#clusteringnodes-weight" title="Direct link to heading">#</a></h3><p>Compute the clustering coefficient for nodes.</p><p>A <em>clustering coefficient</em> is a measure of the degree to which nodes
in a graph tend to cluster together.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-10"></a>Input:<a class="hash-link" href="#input-10" title="Direct link to heading">#</a></h4><ul><li><code>nodes: List[Vertex](NULL)</code> ➡  Compute clustering for nodes in this container.</li><li><code>weight: str(NULL)</code> ➡  The edge attribute that holds the numerical value used as a weight. If <code>None</code>, then each edge has weight 1.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-13"></a>Output:<a class="hash-link" href="#output-13" title="Direct link to heading">#</a></h4><ul><li><code>node: Vertex</code> ➡ Node in graph for calculation of clustering</li><li><code>clustering: double</code> ➡ Clustering coefficient at specified nodes.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-13"></a>Usage:<a class="hash-link" href="#usage-13" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH (n:SpecificLabel)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">WITH COLLECT(n) AS cluster_nodes</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.clustering(cluster_nodes) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN node, clustering;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="communicability"></a><code>communicability()</code><a class="hash-link" href="#communicability" title="Direct link to heading">#</a></h3><p>Returns communicability between all pairs of nodes in <code>G</code>.</p><p>The <em>communicability</em> between pairs of nodes in <code>G</code> is the sum of
closed walks of different lengths starting at node <code>u</code> and ending at node <code>v</code>.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-14"></a>Output:<a class="hash-link" href="#output-14" title="Direct link to heading">#</a></h4><ul><li><code>node1: Vertex</code> ➡ First value in communicability calculation</li><li><code>node2: Vertex</code> ➡ Second value in communicability calculation</li><li><code>communicability: double</code> ➡ Value of communicability between two values.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-14"></a>Usage:<a class="hash-link" href="#usage-14" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.communicability() YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN node1, node2, communicability</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">ORDER BY communicability DESC;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="core_number"></a><code>core_number()</code><a class="hash-link" href="#core_number" title="Direct link to heading">#</a></h3><p>Returns the core number for each vertex.</p><p>A <em>k-core</em> is a maximal subgraph that contains nodes of degree <code>k</code> or more.</p><p>The core number of a node is the largest value <code>k</code> of a k-core containing
that node.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-15"></a>Output:<a class="hash-link" href="#output-15" title="Direct link to heading">#</a></h4><ul><li><code>node: Vertex</code> ➡ Node to calculate k-core for</li><li><code>core: int</code> ➡ Largest value <code>k</code> of a k-core</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-15"></a>Usage:<a class="hash-link" href="#usage-15" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.core_number() YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN node, core</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">ORDER BY core DESC;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="degree_assortativity_coefficientx-y-weight-nodes"></a><code>degree_assortativity_coefficient(x, y, weight, nodes)</code><a class="hash-link" href="#degree_assortativity_coefficientx-y-weight-nodes" title="Direct link to heading">#</a></h3><p>Compute degree assortativity of a graph.</p><p><em>Assortativity</em> measures the similarity of connections
in the graph with respect to the node degree.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-11"></a>Input:<a class="hash-link" href="#input-11" title="Direct link to heading">#</a></h4><ul><li><code>x: str(&quot;out&quot;)</code> ➡  The degree type for source node (directed graphs only). Can be &quot;in&quot; and &quot;out&quot;.</li><li><code>y: str(&quot;in&quot;)</code> ➡  The degree type for target node (directed graphs only). Can be &quot;in&quot; and &quot;out&quot;.</li><li><code>weight: str(NULL)</code> ➡  The edge attribute that holds the numerical value used as a weight.  If <code>None</code>, then each edge has weight 1. The degree is the sum of the edge weights adjacent to the node.</li><li><code>nodes: List[Vertex](NULL)</code> ➡  Compute degree assortativity only for nodes in a container. The default is all nodes.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-16"></a>Output:<a class="hash-link" href="#output-16" title="Direct link to heading">#</a></h4><ul><li><code>assortativity: double</code> ➡ Assortativity of graph by degree.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-16"></a>Usage:<a class="hash-link" href="#usage-16" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.degree_assortativity_coefficient(&#x27;out&#x27;, &#x27;in&#x27;) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN assortativity;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="descendantssource"></a><code>descendants(source)</code><a class="hash-link" href="#descendantssource" title="Direct link to heading">#</a></h3><p>Returns all nodes reachable from <code>source</code> in <code>G</code>.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-12"></a>Input:<a class="hash-link" href="#input-12" title="Direct link to heading">#</a></h4><ul><li><code>source: Vertex</code> ➡  A node in <code>G</code>.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-17"></a>Output:<a class="hash-link" href="#output-17" title="Direct link to heading">#</a></h4><ul><li><code>descendants: List[Vertex]</code> ➡ The descendants of <code>source</code> in <code>G</code>.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-17"></a>Usage:<a class="hash-link" href="#usage-17" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH (source:Label)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.descendants(source) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN descendants;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="dfs_postorder_nodessource-depth_limit"></a><code>dfs_postorder_nodes(source, depth_limit)</code><a class="hash-link" href="#dfs_postorder_nodessource-depth_limit" title="Direct link to heading">#</a></h3><p>Returns nodes in a depth-first-search post-ordering starting at source.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-13"></a>Input:<a class="hash-link" href="#input-13" title="Direct link to heading">#</a></h4><ul><li><code>source: Vertex</code> ➡  Specify the maximum search depth.</li><li><code>depth_limit: int(NULL)</code> ➡  Specify the maximum search depth.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-18"></a>Output:<a class="hash-link" href="#output-18" title="Direct link to heading">#</a></h4><ul><li><code>nodes: List[Vertex]</code> ➡ A list of nodes in a depth-first-search post-ordering.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-18"></a>Usage:<a class="hash-link" href="#usage-18" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH (source:Label)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.dfs_postorder_nodes(source, 10) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN source, nodes;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="dfs_predecessorssource-depth_limit"></a><code>dfs_predecessors(source, depth_limit)</code><a class="hash-link" href="#dfs_predecessorssource-depth_limit" title="Direct link to heading">#</a></h3><p>Returns a dictionary of predecessors in depth-first-search from source.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-14"></a>Input:<a class="hash-link" href="#input-14" title="Direct link to heading">#</a></h4><ul><li><code>source: Vertex</code> ➡  Specify the maximum search depth.</li><li><code>depth_limit: int(NULL)</code> ➡  Specify the maximum search depth.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-19"></a>Output:<a class="hash-link" href="#output-19" title="Direct link to heading">#</a></h4><ul><li><code>node: Vertex</code> ➡ Node we are looking a predecessor for.</li><li><code>predecessor: Vertex</code> ➡ predecessor of a given node.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-19"></a>Usage:<a class="hash-link" href="#usage-19" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH (source:Label)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.dfs_predecessors(source, 10) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN node, predecessor;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="dfs_preorder_nodessource-depth_limit"></a><code>dfs_preorder_nodes(source, depth_limit)</code><a class="hash-link" href="#dfs_preorder_nodessource-depth_limit" title="Direct link to heading">#</a></h3><p>Returns nodes in a depth-first-search pre-ordering starting at source.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-15"></a>Input:<a class="hash-link" href="#input-15" title="Direct link to heading">#</a></h4><ul><li><code>source: Vertex</code> ➡  Specify starting node for depth-first search and return nodes in the component reachable from this node.</li><li><code>depth_limit: int(NULL)</code> ➡  Specify the maximum search depth.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-20"></a>Output:<a class="hash-link" href="#output-20" title="Direct link to heading">#</a></h4><ul><li><code>nodes: List[Vertex]</code> ➡ A list of nodes in a depth-first-search pre-ordering.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-20"></a>Usage:<a class="hash-link" href="#usage-20" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH (source:Label)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.dfs_preorder_nodes(source, 10) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN source, nodes AS preoder_nodes;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="dfs_successorssource-depth_limit"></a><code>dfs_successors(source, depth_limit)</code><a class="hash-link" href="#dfs_successorssource-depth_limit" title="Direct link to heading">#</a></h3><p>Returns a dictionary of successors in depth-first-search from source.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-16"></a>Input:<a class="hash-link" href="#input-16" title="Direct link to heading">#</a></h4><ul><li><code>source: Vertex</code> ➡  Specify starting node for depth-first search and return nodes in the component reachable from this node.</li><li><code>depth_limit: int(NULL)</code> ➡  Specify the maximum search depth.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-21"></a>Output:<a class="hash-link" href="#output-21" title="Direct link to heading">#</a></h4><ul><li><code>node: Vertex</code> ➡ Node to calculate successors</li><li><code>successors: List[Vertex]</code> ➡ Successors of a given nodes</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-21"></a>Usage:<a class="hash-link" href="#usage-21" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH (source:Label)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.dfs_successors(source, 5) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN node, successors;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="dfs_treesource-depth_limit"></a><code>dfs_tree(source, depth_limit)</code><a class="hash-link" href="#dfs_treesource-depth_limit" title="Direct link to heading">#</a></h3><p>Returns an oriented tree constructed from a depth-first-search from source.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-17"></a>Input:<a class="hash-link" href="#input-17" title="Direct link to heading">#</a></h4><ul><li><code>source: Vertex</code> ➡  Specify starting node for depth-first search.</li><li><code>depth_limit: int(NULL)</code> ➡  Specify the maximum search depth.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-22"></a>Output:<a class="hash-link" href="#output-22" title="Direct link to heading">#</a></h4><ul><li><code>tree: List[Vertex]</code> ➡ An oriented tree in a form of a list.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-22"></a>Usage:<a class="hash-link" href="#usage-22" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH (source:Label)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.dfs_tree(source, 7) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN tree;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="diameter"></a><code>diameter()</code><a class="hash-link" href="#diameter" title="Direct link to heading">#</a></h3><p>Returns the diameter of the graph <code>G</code>.</p><p>The diameter is the maximum eccentricity.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-23"></a>Output:<a class="hash-link" href="#output-23" title="Direct link to heading">#</a></h4><ul><li><code>diameter: int</code> ➡ Diameter of graph.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-23"></a>Usage:<a class="hash-link" href="#usage-23" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.diameter() YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN diameter;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="dominance_frontiersstart"></a><code>dominance_frontiers(start)</code><a class="hash-link" href="#dominance_frontiersstart" title="Direct link to heading">#</a></h3><p>Returns the dominance frontiers of all nodes of a directed graph.</p><p>The <em>dominance frontier</em> of a node <code>d</code> is the set of all
nodes such that <code>d</code> dominates an immediate
predecessor of a node, but <code>d</code> does not strictly dominate that node.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-18"></a>Input:<a class="hash-link" href="#input-18" title="Direct link to heading">#</a></h4><ul><li><code>start: Vertex</code> ➡  The start node of dominance computation.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-24"></a>Output:<a class="hash-link" href="#output-24" title="Direct link to heading">#</a></h4><ul><li><code>node: Vertex</code> ➡ Node to calculate frontier.</li><li><code>frontier: List[Vertex]</code> ➡ Dominance frontier for a given node.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-24"></a>Usage:<a class="hash-link" href="#usage-24" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH (source:Label)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.dominance_frontiers(source) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN node, frontier;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="dominating_setstart"></a><code>dominating_set(start)</code><a class="hash-link" href="#dominating_setstart" title="Direct link to heading">#</a></h3><p>Finds a dominating set for the graph <code>G</code>.</p><p>A <em>dominating set</em> for a graph with node set <code>V</code> is a subset <code>D</code> of
<code>V</code> such that every node not in <code>D</code> is adjacent to at least one
member of <code>D</code>.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-19"></a>Input:<a class="hash-link" href="#input-19" title="Direct link to heading">#</a></h4><ul><li><code>start: Vertex</code> ➡  Node to use as a starting point for the algorithm.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-25"></a>Output:<a class="hash-link" href="#output-25" title="Direct link to heading">#</a></h4><ul><li><code>dominating_set: List[Vertex]</code> ➡ A dominating set for <code>G</code>.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-25"></a>Usage:<a class="hash-link" href="#usage-25" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH (source:Label)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.dominating_set(source) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN dominating_set;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="edge_bfssource-orientation"></a><code>edge_bfs(source, orientation)</code><a class="hash-link" href="#edge_bfssource-orientation" title="Direct link to heading">#</a></h3><p>A directed, breadth-first-search of edges in <code>G</code>, beginning at <code>source</code>.</p><p>Return the edges of <code>G</code> in a breadth-first-search order continuing until
all edges are generated.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-20"></a>Input:<a class="hash-link" href="#input-20" title="Direct link to heading">#</a></h4><ul><li><code>source: Vertex</code> ➡  The node from which the traversal begins. If <code>None</code>, then a source is chosen arbitrarily and repeatedly until all edges from each node in the graph are searched.</li><li><code>orientation: str(NULL)</code> ➡  For directed graphs and directed multigraphs, edge traversals need not respect the original orientation of the edges. When set to ‘reverse’, every edge is traversed in the reverse direction. When set to ‘ignore’, every edge is treated as undirected. When set to ‘original’, every edge is treated as directed. In all three cases, the returned edge tuples add a last entry to indicate the direction in which that edge was traversed. If <code>orientation</code> is <code>None</code>, the returned edge has no direction indicated. The direction is respected, but not reported.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-26"></a>Output:<a class="hash-link" href="#output-26" title="Direct link to heading">#</a></h4><ul><li><code>edges: List[Edges]</code> ➡ A directed edge indicating the path taken by the breadth-first-search. For graphs, edge is of the form <code>(u, v)</code> where <code>u</code> and <code>v</code> are the tail and head of the edge as determined by the traversal. For multigraphs, edge is of the form <code>(u, v, key)</code>, where <code>key</code> is the key of the edge. When the graph is directed, then u and <code>v</code> are always in the order of the actual directed edge. If <code>orientation</code> is not <code>None</code> then the edge tuple is extended to include the direction of traversal (‘forward’ or ‘reverse’) on that edge.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-26"></a>Usage:<a class="hash-link" href="#usage-26" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH (source:Label)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.edge_bfs(source, &#x27;ignore&#x27;) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN source, edges;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="edge_dfssource-orientation"></a><code>edge_dfs(source, orientation)</code><a class="hash-link" href="#edge_dfssource-orientation" title="Direct link to heading">#</a></h3><p>A directed, depth-first-search of edges in <code>G</code>, beginning at <code>source</code>.</p><p>Return the edges of <code>G</code> in a depth-first-search order continuing until
all edges are generated.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-21"></a>Input:<a class="hash-link" href="#input-21" title="Direct link to heading">#</a></h4><ul><li><code>source: Vertex(NULL)</code> ➡  The node from which the traversal begins. If <code>None</code>, then a source is chosen arbitrarily and repeatedly until all edges from each node in the graph are searched.</li><li><code>orientation: str(NULL)</code> ➡  For directed graphs and directed multigraphs, edge traversals
need not respect the original orientation of the edges.
When set to ‘reverse’, every edge is traversed in the reverse direction.
When set to ‘ignore’, every edge is treated as undirected.
When set to ‘original’, every edge is treated as directed.
In all three cases, the returned edge tuples add a last entry to
indicate the direction in which that edge was traversed.
If <code>orientation</code> is <code>None</code>, the returned edge has no direction indicated.
The direction is respected, but not reported.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-27"></a>Output:<a class="hash-link" href="#output-27" title="Direct link to heading">#</a></h4><ul><li><code>edges: List[Edge]</code> ➡ A directed edge indicating the path taken by the depth-first traversal.
For graphs, edge is of the form <code>(u, v)</code> where <code>u</code> and <code>v</code>
are the tail and head of the edge as determined by the traversal.
For multigraphs, edge is of the form <code>(u, v, key)</code>, where <code>key</code> is
the key of the edge. When the graph is directed, then <code>u</code> and <code>v</code>
are always in the order of the actual directed edge.
If <code>orientation</code> is not <code>None</code> then the edge tuple is extended to include
the direction of traversal (‘forward’ or ‘reverse’) on that edge.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-27"></a>Usage:<a class="hash-link" href="#usage-27" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH (source:Label)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.edge_dfs(source, &#x27;original&#x27;) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN source, edges;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="find_cliques"></a><code>find_cliques()</code><a class="hash-link" href="#find_cliques" title="Direct link to heading">#</a></h3><p>Returns all maximal cliques in an undirected graph.</p><p>For each node <code>v</code>, a <em>maximal clique</em> for <code>v</code> is the largest complete
subgraph containing <code>v</code>. The largest maximal clique is sometimes
called the <em>maximum clique</em>.</p><p>This function returns an iterator over cliques, each of which is a
list of nodes. It is an iterative implementation, so should not
suffer from recursion depth issues.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-28"></a>Output:<a class="hash-link" href="#output-28" title="Direct link to heading">#</a></h4><ul><li><code>cliques: List[List[Vertex]]</code> ➡ An iterator over maximal cliques, each of which is a list of
nodes in <code>G</code>. The order of cliques is arbitrary.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-28"></a>Usage:<a class="hash-link" href="#usage-28" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.find_cliques() YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN cliques;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="find_cyclesource-orientation"></a><code>find_cycle(source, orientation)</code><a class="hash-link" href="#find_cyclesource-orientation" title="Direct link to heading">#</a></h3><p>Returns a cycle found via depth-first traversal.</p><p>A <em>cycle</em> is a closed path in the graph.
The orientation of directed edges is determined by <code>orientation</code>.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-22"></a>Input:<a class="hash-link" href="#input-22" title="Direct link to heading">#</a></h4><ul><li><code>source: List[Vertex](NULL)</code> ➡  The node from which the traversal begins. If <code>None</code>, then a source is chosen arbitrarily and repeatedly until all edges from each node in the graph are searched.</li><li><code>orientation: str(NULL)</code> ➡  For directed graphs and directed multigraphs, edge traversals
need not respect the original orientation of the edges. When set to ‘reverse’ every edge is traversed in the reverse direction. When set to ‘ignore’, every edge is treated as undirected. When set to ‘original’, every edge is treated as directed. In all three cases, the yielded edge tuples add a last entry to indicate the direction in which that edge was traversed. If <code>orientation</code> is <code>None</code>, the yielded edge has no direction indicated. The direction is respected, but not reported.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-29"></a>Output:<a class="hash-link" href="#output-29" title="Direct link to heading">#</a></h4><ul><li><code>   </code> ➡ A list of directed edges indicating the path taken for the loop. If no cycle is found, then an exception is raised. For graphs, an edge is of the form <code>(u, v)</code> where <code>u</code> and <code>v</code> are the tail and the head of the edge as determined by the traversal. For multigraphs, an edge is of the form <code>(u, v, key)</code>, where <code>key</code> is the key of the edge. When the graph is directed, then <code>u</code> and <code>v</code> are always in the order of the actual directed edge. If <code>orientation</code> is not <code>None</code> then the edge tuple is extended to include the direction of traversal (‘forward’ or ‘reverse’) on that edge.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-29"></a>Usage:<a class="hash-link" href="#usage-29" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH (source:Label)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.find_cycle(source) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN source, edges;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="flow_hierarchyweight"></a><code>flow_hierarchy(weight)</code><a class="hash-link" href="#flow_hierarchyweight" title="Direct link to heading">#</a></h3><p>Returns the flow hierarchy of a directed network.</p><p><em>Flow hierarchy</em> is defined as the fraction of edges not participating in cycles in a directed graph.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-23"></a>Input:<a class="hash-link" href="#input-23" title="Direct link to heading">#</a></h4><ul><li><code>weight: str(NULL)</code> ➡  Attribute to use for node weights. If <code>None</code>, the weight defaults to 1.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-30"></a>Output:<a class="hash-link" href="#output-30" title="Direct link to heading">#</a></h4><ul><li><code>flow_hierarchy: double</code> ➡  Flow hierarchy value.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-30"></a>Usage:<a class="hash-link" href="#usage-30" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.flow_hierarchy() YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN flow_hierarchy;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="global_efficiency"></a><code>global_efficiency()</code><a class="hash-link" href="#global_efficiency" title="Direct link to heading">#</a></h3><p>Returns the average global efficiency of the graph. The <em>efficiency</em> of a pair of nodes in a graph is the multiplicative inverse of the shortest path distance between the nodes. The <em>average global efficiency</em> of a graph is the average efficiency of all pairs of nodes.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-31"></a>Output:<a class="hash-link" href="#output-31" title="Direct link to heading">#</a></h4><ul><li><code>global_efficiency: double</code> ➡  The average global efficiency of the graph.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-31"></a>Usage:<a class="hash-link" href="#usage-31" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.global_efficiency() YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN global_efficiency;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="greedy_colorstrategy-interchange"></a><code>greedy_color(strategy, interchange)</code><a class="hash-link" href="#greedy_colorstrategy-interchange" title="Direct link to heading">#</a></h3><p>Color a graph using various strategies of greedy graph coloring. Attempts to color a graph using as few colors as possible, where no neighbors of a node can have the same color as the node itself. The given strategy determines the order in which nodes are colored.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-24"></a>Input:<a class="hash-link" href="#input-24" title="Direct link to heading">#</a></h4><ul><li><code>strategy</code> ➡  The parameter <code>function(G,colors)</code> is a function (or a string representing a function) that provides the coloring strategy, by returning nodes in the order they should be colored. <code>G</code> is the graph, and <code>colors</code> is a dictionary of the currently assigned colors, keyed by nodes. The function must return an iterable over all the nodes in <code>G</code>. If the strategy function is an iterator generator (a function with
<code>yield</code> statements), keep in mind that the <code>colors</code> dictionary will be updated after each <code>yield</code>, since this function chooses colors greedily. If <code>strategy</code> is a string, it must be one of the following, each of which represents one of the built-in strategy functions.
<code>&#x27;largest_first&#x27;</code><code>&#x27;random_sequential&#x27;</code><code>&#x27;smallest_last&#x27;</code><code>&#x27;independent_set&#x27;</code><code>&#x27;connected_sequential_bfs&#x27;</code><code>&#x27;connected_sequential_dfs&#x27;</code><code>&#x27;connected_sequential&#x27;</code> (alias for the previous strategy)
<code>&#x27;saturation_largest_first&#x27;</code><code>&#x27;DSATUR&#x27;</code> (alias for the previous strategy)</li><li><code>interchange: bool(False)</code> ➡  Will use the color interchange algorithm if set to <code>True</code>. Note that <code>saturation_largest_first</code> and <code>independent_set</code> do not work with interchange. Furthermore, if you use interchange with your own strategy function, you cannot rely on the values in the <code>colors</code> argument.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-32"></a>Output:<a class="hash-link" href="#output-32" title="Direct link to heading">#</a></h4><ul><li><code>node: Vertex</code> ➡ Vertex to color.</li><li><code>color: int</code> ➡ Color index of a certain node.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-32"></a>Usage:<a class="hash-link" href="#usage-32" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.greedy_color(&#x27;connected_sequential_bfs&#x27;) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN node, color;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="has_eulerian_path"></a><code>has_eulerian_path()</code><a class="hash-link" href="#has_eulerian_path" title="Direct link to heading">#</a></h3><p> An <em>Eulerian path</em> is a path in a graph that uses each edge of a graph exactly once.
A directed graph has an Eulerian path if:</p><ul><li>at most one vertex has <code>out_degree - in_degree = 1</code>,</li><li>at most one vertex has <code>in_degree - out_degree = 1</code>,</li><li>every other vertex has equal in_degree and out_degree,</li><li>and all of its vertices with nonzero degree belong to a single connected component of the underlying undirected graph.
An undirected graph has an Eulerian path if exactly zero or two vertices have an odd degree and all of its vertices with nonzero degrees belong to a single connected component.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-33"></a>Output:<a class="hash-link" href="#output-33" title="Direct link to heading">#</a></h4><ul><li><code>has_eulerian_path: bool</code> ➡ <code>True</code> if <code>G</code> has an eulerian path.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-33"></a>Usage:<a class="hash-link" href="#usage-33" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.has_eulerian_path() YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN has_eulerian_path;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="has_pathsource-target"></a><code>has_path(source, target)</code><a class="hash-link" href="#has_pathsource-target" title="Direct link to heading">#</a></h3><p>Returns <code>True</code> if <code>G</code> has a path from <code>source</code> to <code>target</code>.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-25"></a>Input:<a class="hash-link" href="#input-25" title="Direct link to heading">#</a></h4><ul><li><code>source: Vertex</code> ➡  Starting node for the path.</li><li><code>target: Vertex</code> ➡  Ending node for the path.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-34"></a>Output:<a class="hash-link" href="#output-34" title="Direct link to heading">#</a></h4><ul><li><code>has_path: bool</code> ➡  <code>True</code> if <code>G</code> has a path from <code>source</code> to <code>target</code>.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-34"></a>Usage:<a class="hash-link" href="#usage-34" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH (n:Label), (m:Label)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.has_path(n, m) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN has_path;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="immediate_dominatorsstart"></a><code>immediate_dominators(start)</code><a class="hash-link" href="#immediate_dominatorsstart" title="Direct link to heading">#</a></h3><p>Returns the immediate dominators of all nodes of a directed graph. The immediate dominator of a node is the unique node that Strictly dominates a node <code>n</code> but does not strictly dominate any other node That dominates <code>n</code>.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-26"></a>Input:<a class="hash-link" href="#input-26" title="Direct link to heading">#</a></h4><ul><li><code>start: Vertex</code> ➡  The start node of dominance computation.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-35"></a>Output:<a class="hash-link" href="#output-35" title="Direct link to heading">#</a></h4><ul><li><code>node: Vertex</code> ➡  Vertex to calculate dominator for.</li><li><code>dominator: Vertex</code> ➡  Dominator node for certain vertex.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-35"></a>Usage:<a class="hash-link" href="#usage-35" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH (n:Label)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.immediate_dominators(n) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN node, dominator;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="is_arborescence"></a><code>is_arborescence()</code><a class="hash-link" href="#is_arborescence" title="Direct link to heading">#</a></h3><p>Returns <code>True</code> if <code>G</code> is an arborescence. An <em>arborescence</em> is a directed tree with maximum in-degree equal to 1.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-36"></a>Output:<a class="hash-link" href="#output-36" title="Direct link to heading">#</a></h4><ul><li><code>is_arborescence: bool</code> ➡  A boolean that is <code>True</code> if <code>G</code> is an arborescence.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-36"></a>Usage:<a class="hash-link" href="#usage-36" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.is_arborescence() YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN is_arborescence;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="is_at_free"></a><code>is_at_free()</code><a class="hash-link" href="#is_at_free" title="Direct link to heading">#</a></h3><p>Check if a graph is AT-free. The method uses the find_asteroidal_triple method to recognize an AT-free graph. If no asteroidal triple is found, the graph is AT-free and <code>True</code> is returned. If at least one asteroidal triple is found, the graph is not AT-free and <code>False</code> is returned.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-37"></a>Output:<a class="hash-link" href="#output-37" title="Direct link to heading">#</a></h4><ul><li><code>is_at_free: bool</code> ➡  <code>True</code> if <code>G</code> is AT-free and <code>False</code> otherwise.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-37"></a>Usage:<a class="hash-link" href="#usage-37" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.is_at_free() YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN is_at_free;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="is_bipartite"></a><code>is_bipartite()</code><a class="hash-link" href="#is_bipartite" title="Direct link to heading">#</a></h3><p>Returns <code>True</code> if graph <code>G</code> is bipartite, <code>False</code> if not. A <em>bipartite graph</em> (or bigraph) is a graph whose vertices can be divided into two disjoint and independent sets <code>u</code> and <code>v</code> and such that every edge connects a vertex in <code>u</code> one in <code>v</code>.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-38"></a>Output:<a class="hash-link" href="#output-38" title="Direct link to heading">#</a></h4><ul><li><code>is_bipartite: bool</code> ➡  <code>True</code> if <code>G</code> is bipartite and <code>False</code> otherwise.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-38"></a>Usage:<a class="hash-link" href="#usage-38" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.is_bipartite() YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN is_bipartite;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="is_branching"></a><code>is_branching()</code><a class="hash-link" href="#is_branching" title="Direct link to heading">#</a></h3><p>Returns <code>True</code> if <code>G</code> is a branching. A <em>branching</em> is a directed forest with maximum in-degree equal to 1.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-39"></a>Output:<a class="hash-link" href="#output-39" title="Direct link to heading">#</a></h4><ul><li><code>is_branching: bool</code> ➡   A boolean that is <code>True</code> if <code>G</code> is a branching.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-39"></a>Usage:<a class="hash-link" href="#usage-39" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.is_branching() YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN is_branching;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="is_chordal"></a><code>is_chordal()</code><a class="hash-link" href="#is_chordal" title="Direct link to heading">#</a></h3><p>Checks whether <code>G</code> is a chordal graph. A graph is <em>chordal</em> if every cycle of length at least 4 has a chord (an edge joining two nodes not adjacent in the cycle).</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-40"></a>Output:<a class="hash-link" href="#output-40" title="Direct link to heading">#</a></h4><ul><li><code>is_chordal: bool</code> ➡  <code>True</code> if <code>G</code> is a chordal graph and <code>False</code> otherwise.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-40"></a>Usage:<a class="hash-link" href="#usage-40" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.is_chordal() YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN is_chordal;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="is_distance_regular"></a><code>is_distance_regular()</code><a class="hash-link" href="#is_distance_regular" title="Direct link to heading">#</a></h3><p>Returns <code>True</code> if the graph is distance regular, <code>False</code> otherwise. A connected graph <code>G</code> is distance-regular if for any nodes <code>x,y</code> and any integers <code>i,j=0,1,...,d</code> (where <code>d</code> is the graph diameter), the number of vertices at distance <code>i</code> from <code>x</code> and distance <code>j</code> from <code>y</code> depends only on <code>i,j</code> and the graph distance between <code>x</code> and <code>y</code>, independently of the choice of <code>x</code> and <code>y</code>.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-41"></a>Output:<a class="hash-link" href="#output-41" title="Direct link to heading">#</a></h4><ul><li><code>is_distance_regular: bool</code> ➡  <code>True</code> if the graph is Distance Regular, <code>False</code> otherwise.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-41"></a>Usage:<a class="hash-link" href="#usage-41" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.is_distance_regular() YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN is_distance_regular;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="is_edge_covercover"></a><code>is_edge_cover(cover)</code><a class="hash-link" href="#is_edge_covercover" title="Direct link to heading">#</a></h3><p>Decides whether a set of edges is a valid edge cover of the graph. Given a set of edges, it can be decided whether the set is an <em>edge covering</em> if checked whether all nodes of the graph have an edge from the set incident on it.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-27"></a>Input:<a class="hash-link" href="#input-27" title="Direct link to heading">#</a></h4><ul><li><code>cover: List[Edge]</code> ➡   A list of edges to be checked.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-42"></a>Output:<a class="hash-link" href="#output-42" title="Direct link to heading">#</a></h4><ul><li><code>is_edge_cover: bool</code> ➡  Whether the set of edges is a valid edge cover of the graph.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-42"></a>Usage:<a class="hash-link" href="#usage-42" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH (n)-[e]-(m)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">WITH COLLECT(e) AS cover</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.is_edge_cover(cover) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN is_edge_cover;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="is_eulerian"></a><code>is_eulerian()</code><a class="hash-link" href="#is_eulerian" title="Direct link to heading">#</a></h3><p>Returns <code>True</code> if and only if <code>G</code> is Eulerian. A graph is <em>Eulerian</em> if it has an Eulerian circuit. An <em>Eulerian circuit</em> is a closed walk that includes each edge of a graph exactly once.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-43"></a>Output:<a class="hash-link" href="#output-43" title="Direct link to heading">#</a></h4><ul><li><code>is_eulerian: bool</code> ➡  <code>True</code> if <code>G</code> is Eulerian.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-43"></a>Usage:<a class="hash-link" href="#usage-43" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.is_eulerian() YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN is_eulerian;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="is_forest"></a><code>is_forest()</code><a class="hash-link" href="#is_forest" title="Direct link to heading">#</a></h3><p>Returns <code>True</code> if <code>G</code> is a forest. A <em>forest</em> is a graph with no undirected cycles.
For directed graphs, <code>G</code> is a forest if the underlying graph is a forest. The underlying graph is obtained by treating each directed edge as a single undirected edge in a multigraph.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-44"></a>Output:<a class="hash-link" href="#output-44" title="Direct link to heading">#</a></h4><ul><li><code>is_forest: bool</code> ➡  A boolean that is <code>True</code> if <code>G</code> is a forest.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-44"></a>Usage:<a class="hash-link" href="#usage-44" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.is_forest() YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN is_forest;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="is_isolaten"></a><code>is_isolate(n)</code><a class="hash-link" href="#is_isolaten" title="Direct link to heading">#</a></h3><p>Determines whether a node is an isolate.
An <em>isolate</em> is a node with no neighbors (that is, with degree zero). For directed graphs, this means no in-neighbors and no out-neighbors.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-28"></a>Input:<a class="hash-link" href="#input-28" title="Direct link to heading">#</a></h4><ul><li><code>n: Vertex</code> ➡  A node in <code>G</code>.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-45"></a>Output:<a class="hash-link" href="#output-45" title="Direct link to heading">#</a></h4><ul><li><code>is_isolate: bool</code> ➡  <code>True</code> if and only if <code>n</code> has no neighbors.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-45"></a>Usage:<a class="hash-link" href="#usage-45" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH (n)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.is_isolate(n) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN is_isolate;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="is_isomorphicnodes1-edges1-nodes2-edges2"></a><code>is_isomorphic(nodes1, edges1, nodes2, edges2)</code><a class="hash-link" href="#is_isomorphicnodes1-edges1-nodes2-edges2" title="Direct link to heading">#</a></h3><p>Returns <code>True</code> if the graphs <code>G1</code> and <code>G2</code> are isomorphic and <code>False</code> otherwise. The two graphs <code>G1</code> and <code>G2</code> must be the same type.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-29"></a>Input:<a class="hash-link" href="#input-29" title="Direct link to heading">#</a></h4><ul><li><code>nodes1: List[Vertex]</code> ➡  Nodes in <code>G1</code>.</li><li><code>edges1: List[Edge]</code> ➡  Edges in <code>G1</code>.</li><li><code>nodes2: List[Vertex]</code> ➡  Nodes in <code>G2</code>.</li><li><code>edges2: List[Edge]</code> ➡   Edges in <code>G2</code>.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-46"></a>Output:<a class="hash-link" href="#output-46" title="Direct link to heading">#</a></h4><ul><li><code>is_isomorphic: bool</code> ➡  <code>True</code> if the graphs <code>G1</code> and <code>G2</code> are isomorphic and <code>False</code> otherwise.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-46"></a>Usage:<a class="hash-link" href="#usage-46" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH (n:Label1)-[e]-(), (r:Label2)-[f]-()</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">WITH</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">COLLECT(n) AS nodes1</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">COLLECT(e) AS edges1</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">COLLECT(r) AS nodes2</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">COLLECT(f) AS edges2</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.is_isomorphic(nodes1, edges1, nodes2, edges2) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN is_isomorphic;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="is_semieulerian"></a><code>is_semieulerian()</code><a class="hash-link" href="#is_semieulerian" title="Direct link to heading">#</a></h3><p>Returns <code>True</code> if <code>G</code> is semi-Eulerian.</p><p><code>G</code> is semi-Eulerian if it has an Eulerian path but no Eulerian circuit.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-47"></a>Output:<a class="hash-link" href="#output-47" title="Direct link to heading">#</a></h4><ul><li><code>is_semieulerian: bool</code> ➡  <code>True</code> if <code>G</code> is semi-Eulerian.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-47"></a>Usage:<a class="hash-link" href="#usage-47" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.is_semieulerian() YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN is_semieulerian;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="is_simple_pathnodes"></a><code>is_simple_path(nodes)</code><a class="hash-link" href="#is_simple_pathnodes" title="Direct link to heading">#</a></h3><p>Returns <code>True</code> if and only if the given nodes form a simple path in
<code>G</code>.
A <em>simple path</em> in a graph is a nonempty sequence of nodes in which no node appears more than once in the sequence and each adjacent pair of nodes in the sequence is adjacent in the graph.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-30"></a>Input:<a class="hash-link" href="#input-30" title="Direct link to heading">#</a></h4><ul><li><code>nodes: List[Vertex]</code> ➡  A list of one or more nodes in the graph <code>G</code>.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-48"></a>Output:<a class="hash-link" href="#output-48" title="Direct link to heading">#</a></h4><ul><li><code>is_simple_path: bool</code> ➡  Whether the given list of nodes represents a simple path in <code>G</code>.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-48"></a>Usage:<a class="hash-link" href="#usage-48" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH (n:Label)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">WITH COLLECT(n) AS nodes</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.is_simple_path(nodes) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN is_simple_path;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="is_strongly_regular"></a><code>is_strongly_regular()</code><a class="hash-link" href="#is_strongly_regular" title="Direct link to heading">#</a></h3><p>Returns <code>True</code> if and only if the given graph is strongly regular.
An undirected graph is <em>strongly regular</em> if:</p><ul><li>it is regular,</li></ul><ul><li>each pair of adjacent vertices has the same number of neighbors in common,</li></ul><ul><li>each pair of nonadjacent vertices has the same number of neighbors in common.
Each strongly regular graph is a distance-regular graph. Conversely, if a distance-regular graph has a diameter of two, then it is a strongly regular graph.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-49"></a>Output:<a class="hash-link" href="#output-49" title="Direct link to heading">#</a></h4><ul><li><code>is_strongly_regular: bool</code> ➡   Whether <code>G</code> is strongly regular.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-49"></a>Usage:<a class="hash-link" href="#usage-49" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.is_strongly_regular() YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN is_strongly_regular;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="is_tournament"></a><code>is_tournament()</code><a class="hash-link" href="#is_tournament" title="Direct link to heading">#</a></h3><p>Returns <code>True</code> if and only if <code>G</code> is a tournament.
A <em>tournament</em> is a directed graph, with neither self-loops nor multi-edges, in which there is exactly one directed edge joining each pair of distinct nodes.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-50"></a>Output:<a class="hash-link" href="#output-50" title="Direct link to heading">#</a></h4><ul><li><code>is_tournament: bool</code> ➡   Whether the given graph is a tournament graph.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-50"></a>Usage:<a class="hash-link" href="#usage-50" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.is_tournament() YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN is_tournament;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="is_tree"></a><code>is_tree()</code><a class="hash-link" href="#is_tree" title="Direct link to heading">#</a></h3><p>Returns <code>True</code> if <code>G</code> is a tree.
A <em>tree</em> is a connected graph with no undirected cycles.
For directed graphs, <code>G</code> is a tree if the underlying graph is a tree. The underlying graph is obtained by treating each directed edge as a single undirected edge in a multigraph.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-51"></a>Output:<a class="hash-link" href="#output-51" title="Direct link to heading">#</a></h4><ul><li><code>is_tree: bool</code> ➡   A boolean that is <code>True</code> if <code>G</code> is a tree.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-51"></a>Usage:<a class="hash-link" href="#usage-51" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.is_tree() YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN is_tree;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="isolates"></a><code>isolates()</code><a class="hash-link" href="#isolates" title="Direct link to heading">#</a></h3><p>Returns a list of isolates in the graph.
An <em>isolate</em> is a node with no neighbors (that is, with degree zero). For directed graphs, this means no in-neighbors and no out-neighbors.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-52"></a>Output:<a class="hash-link" href="#output-52" title="Direct link to heading">#</a></h4><ul><li><code>isolates: List[Vertex]</code> ➡   A list of isolates in <code>G</code>.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-52"></a>Usage:<a class="hash-link" href="#usage-52" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.isolates() YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN isolates;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="jaccard_coefficientebunch"></a><code>jaccard_coefficient(ebunch)</code><a class="hash-link" href="#jaccard_coefficientebunch" title="Direct link to heading">#</a></h3><p>Compute the Jaccard coefficient of all node pairs in <code>ebunch</code>.</p><p><em>Jaccard coefficient</em> compares members of two sets to see which members are shared and which are distinct.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-31"></a>Input:<a class="hash-link" href="#input-31" title="Direct link to heading">#</a></h4><ul><li><code>ebunch: List[List[Vertex]](NULL)</code> ➡  Jaccard coefficient will be computed for each pair of nodes given in the iterable. The pairs must be given as 2-tuples
<code>(u, v)</code> where <code>u</code> and <code>v</code> are nodes in the graph. If <code>ebunch</code> is <code>None</code> then all non-existent edges in the graph will be used.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-53"></a>Output:<a class="hash-link" href="#output-53" title="Direct link to heading">#</a></h4><ul><li><code>u: Vertex</code> ➡  First node in pair.</li><li><code>v: Vertex</code> ➡  Second node in pair.</li><li><code>coef: Vertex</code> ➡  Jaccard coefficient.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-53"></a>Usage:<a class="hash-link" href="#usage-53" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.jaccard_coefficient() YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN u, v, coef;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="k_clique_communitiesk-cliques"></a><code>k_clique_communities(k, cliques)</code><a class="hash-link" href="#k_clique_communitiesk-cliques" title="Direct link to heading">#</a></h3><p>Find k-clique communities in a graph using the percolation method.
A <em>k-clique community</em> is the union of all cliques of size <code>k</code> that can be reached through adjacent (sharing <code>k-1</code> nodes) k-cliques.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-32"></a>Input:<a class="hash-link" href="#input-32" title="Direct link to heading">#</a></h4><ul><li><code>k: int</code> ➡  Size of the smallest clique.</li><li><code>cliques: List[List[Vertex]](NULL)</code> ➡  Precomputed cliques (use networkx.find_cliques(G)).</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-54"></a>Output:<a class="hash-link" href="#output-54" title="Direct link to heading">#</a></h4><ul><li><code>communities: List[List[Vertex]]</code> ➡   Sets of nodes, one for each k-clique community.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-54"></a>Usage:<a class="hash-link" href="#usage-54" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.k_clique_communities(3) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN communities;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="k_componentsdensity"></a><code>k_components(density)</code><a class="hash-link" href="#k_componentsdensity" title="Direct link to heading">#</a></h3><p>Returns the approximate k-component structure of a graph <code>G</code>.
A <em>k-component</em> is a maximal subgraph of a graph <code>G</code> that has, at least, node connectivity <code>k</code>: we need to remove at least <code>k</code> nodes to break it into more components. k-components have an inherent hierarchical structure because they are nested in terms of connectivity: a connected graph can contain several 2-components, each of which can contain one or more 3-components, and so forth.
This implementation is based on the fast heuristics to approximate the k-component structure of a graph. This, in turn, is based on a fast approximation algorithm for finding good lower bounds of the number of node independent paths between two nodes.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-33"></a>Input:<a class="hash-link" href="#input-33" title="Direct link to heading">#</a></h4><ul><li><code>min_density: double(0.95)</code> ➡   Density relaxation threshold.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-55"></a>Output:<a class="hash-link" href="#output-55" title="Direct link to heading">#</a></h4><ul><li><code>k: int</code> ➡  Connectivity level k</li><li><code>components: List[List[Vertex]]</code> ➡  List of sets of nodes that form a k-component of level <code>k</code> as values.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-55"></a>Usage:<a class="hash-link" href="#usage-55" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.k_components(0.8) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN k, components;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="k_edge_componentsk"></a><code>k_edge_components(k)</code><a class="hash-link" href="#k_edge_componentsk" title="Direct link to heading">#</a></h3><p>Returns nodes in each maximal k-edge-connected component in <code>G</code>.
A connected graph is <em>k-edge-connected</em> if it remains connected whenever fewer than k edges are removed. The edge-connectivity of a graph is the largest k for which the graph is k-edge-connected.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-34"></a>Input:<a class="hash-link" href="#input-34" title="Direct link to heading">#</a></h4><ul><li><code>k: int</code> ➡  Desired edge connectivity.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-56"></a>Output:<a class="hash-link" href="#output-56" title="Direct link to heading">#</a></h4><ul><li><code>components: List[List[Vertex]]</code> ➡   A list of k-edge-ccs. Each set of returned nodes will have k-edge-connectivity in the graph <code>G</code>.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-56"></a>Usage:<a class="hash-link" href="#usage-56" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.k_edge_components(3) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN components;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="local_efficiency"></a><code>local_efficiency()</code><a class="hash-link" href="#local_efficiency" title="Direct link to heading">#</a></h3><p>Returns the average local efficiency of the graph.
The <em>efficiency</em> of a pair of nodes in a graph is the multiplicative inverse of the shortest path distance between the nodes. The <em>local efficiency</em> of a node in the graph is the average global efficiency of the subgraph induced by the neighbors of the node. The <em>average local efficiency</em> is the average of the local efficiencies of each node.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-57"></a>Output:<a class="hash-link" href="#output-57" title="Direct link to heading">#</a></h4><ul><li><code>local_efficiency: double</code> ➡   The average local efficiency of the graph.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-57"></a>Usage:<a class="hash-link" href="#usage-57" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.local_efficiency() YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN local_efficiency;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="lowest_common_ancestornode1-node2"></a><code>lowest_common_ancestor(node1, node2)</code><a class="hash-link" href="#lowest_common_ancestornode1-node2" title="Direct link to heading">#</a></h3><p>Compute the lowest common ancestor of the given pair of nodes.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-35"></a>Input:<a class="hash-link" href="#input-35" title="Direct link to heading">#</a></h4><ul><li><code>node1: Vertex</code> ➡  A node in the graph.</li><li><code>node2: Vertex</code> ➡  A node in the graph.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-58"></a>Output:<a class="hash-link" href="#output-58" title="Direct link to heading">#</a></h4><ul><li><code>ancestor: Vertex</code> ➡  The lowest common ancestor of <code>node1</code> and <code>node2</code>, or default if they have no common ancestors.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-58"></a>Usage:<a class="hash-link" href="#usage-58" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH (n), (m)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">WHERE n != m</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.local_efficiency(n, m) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN n, m, ancestor;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="maximal_matching"></a><code>maximal_matching()</code><a class="hash-link" href="#maximal_matching" title="Direct link to heading">#</a></h3><p> A <em>matching</em> is a subset of edges in which no node occurs more than once. A <em>maximal matching</em> cannot add more edges and still be a matching.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-59"></a>Output:<a class="hash-link" href="#output-59" title="Direct link to heading">#</a></h4><ul><li><code>edges: List[Edge]</code> ➡   A maximal matching of the graph.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-59"></a>Usage:<a class="hash-link" href="#usage-59" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.maximal_matching() YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN edges;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="minimum_spanning_treeweight-algorithm-ignore_nan"></a><code>minimum_spanning_tree(weight, algorithm, ignore_nan)</code><a class="hash-link" href="#minimum_spanning_treeweight-algorithm-ignore_nan" title="Direct link to heading">#</a></h3><p>Returns a minimum spanning tree or forest on an undirected graph <code>G</code>.
A <em>minimum spanning tree</em> is a subset of the edges of a connected, undirected graph that connects all of the vertices together without any cycles.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-36"></a>Input:<a class="hash-link" href="#input-36" title="Direct link to heading">#</a></h4><ul><li><code>weight: str(&quot;weight&quot;)</code> ➡  Data key to use for edge weights.</li><li><code>algorithm: str(&quot;kruskal&quot;)</code> ➡  The algorithm to use when finding a minimum spanning tree. Valid choices are ‘kruskal’, ‘prim’, or ‘boruvka’.</li><li><code>ignore_nan: bool(False)</code> ➡  If <code>NaN</code> is found as an edge weight normally an exception is raised. If <code>ignore_nan</code> is <code>True</code> then that edge is ignored.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-60"></a>Output:<a class="hash-link" href="#output-60" title="Direct link to heading">#</a></h4><ul><li><code>node: List[Vertex]</code> ➡  A minimum spanning tree or forest.</li><li><code>edges: List[Edge]</code> ➡  A minimum spanning tree or forest.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-60"></a>Usage:<a class="hash-link" href="#usage-60" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.minimum_spanning_tree(&quot;weight&quot;, &quot;prim&quot;, TRUE) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN node, edges;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="multi_source_dijkstra_pathsources-cutoff-weight"></a><code>multi_source_dijkstra_path(sources, cutoff, weight)</code><a class="hash-link" href="#multi_source_dijkstra_pathsources-cutoff-weight" title="Direct link to heading">#</a></h3><p>Find shortest weighted paths in G from a given set of source nodes.</p><p>Compute shortest path between any of the source nodes and all other reachable nodes for a weighted graph.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-37"></a>Input:<a class="hash-link" href="#input-37" title="Direct link to heading">#</a></h4><ul><li><code>sources: List[Vertex]</code> ➡  Starting nodes for paths. If this is a set containing a single node, then all paths computed by this function will start from that node. If there are two or more nodes in the set, the computed paths may begin from any one of the start nodes.</li><li><code>cutoff: int(NULL)</code> ➡   Depth to stop the search. Only return paths with <code>length &lt;= cutoff</code>.</li><li><code>weight: str</code> ➡  If this is a string, then edge weights will be accessed via the edge attribute with this key (that is, the weight of the edge joining <code>u</code> to <code>v</code> will be <code>G.edges[u, v][weight]</code>). If no such edge attribute exists, the weight of the edge is assumed to be one. If this is a function, the weight of an edge is the value returned by the function. The function must accept exactly three positional arguments: the two endpoints of an edge and the dictionary of edge attributes for that edge. The function must return a number.</li><li><code>sources: List[Vertex]</code> ➡</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-61"></a>Output:<a class="hash-link" href="#output-61" title="Direct link to heading">#</a></h4><ul><li><code>target: Vertex</code> ➡ Target key for shortest path</li><li><code>path: List[Vertex]</code> ➡  Shortest path in a list</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-61"></a>Usage:<a class="hash-link" href="#usage-61" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH (n:Label)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">COLLECT (n) AS sources</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.multi_source_dijkstra_path(sources, 7) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN target, path;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="multi_source_dijkstra_path_lengthsources-cutoff-weight"></a><code>multi_source_dijkstra_path_length(sources, cutoff, weight)</code><a class="hash-link" href="#multi_source_dijkstra_path_lengthsources-cutoff-weight" title="Direct link to heading">#</a></h3><p>Find shortest weighted path lengths in <code>G</code> from a given set of source nodes.</p><p>Compute the shortest path length between any of the source nodes and all other reachable nodes for a weighted graph.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-38"></a>Input:<a class="hash-link" href="#input-38" title="Direct link to heading">#</a></h4><ul><li><code>sources: List[Vertex]</code> ➡  Starting nodes for paths. If this is a set containing a single node, then all paths computed by this function will start from that node. If there are two or more nodes in the set, the computed paths may begin from any one of the start nodes.</li><li><code>cutoff: int(NULL)</code> ➡  Depth to stop the search. Only return paths with <code>length &lt;= cutoff</code>.</li><li><code>weight: str</code> ➡  If this is a string, then edge weights will be accessed via the edge attribute with this key (that is, the weight of the edge joining <code>u</code> to <code>v</code> will be <code>G.edges[u, v][weight]</code>). If no such edge attribute exists, the weight of the edge is assumed to be one. If this is a function, the weight of an edge is the value returned by the function. The function must accept exactly three positional arguments: the two endpoints of an edge and the dictionary of edge attributes for that edge. The function must return a number.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-62"></a>Output:<a class="hash-link" href="#output-62" title="Direct link to heading">#</a></h4><ul><li><code>target: Vertex</code> ➡ Target key for shortest path</li><li><code>length: double</code> ➡  Shortest path length</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-62"></a>Usage:<a class="hash-link" href="#usage-62" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH (n:Label)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">COLLECT (n) AS sources</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.multi_source_dijkstra_path_length(sources, 5) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN target, length;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="node_boundarynbunch1-bunch2"></a><code>node_boundary(nbunch1, bunch2)</code><a class="hash-link" href="#node_boundarynbunch1-bunch2" title="Direct link to heading">#</a></h3><p>Returns the node boundary of <code>nbunch1</code>.
The <em>node boundary</em> of a set <code>S</code> with respect to a set <code>T</code> is the set of nodes <code>v</code> in <code>T</code> such that for some <code>u</code> in <code>S</code>, there is an edge joining <code>u</code> to <code>v</code>. If <code>T</code> is not specified, it is assumed to be the set of all nodes not in <code>S</code>.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-39"></a>Input:<a class="hash-link" href="#input-39" title="Direct link to heading">#</a></h4><ul><li><code>nbunch1: List[Vertex]</code> ➡  List of nodes in the graph representing the set of nodes whose node boundary will be returned. (This is the set <code>S</code> from the definition above.)</li><li><code>nbunch2: List[Vertex](NULL)</code> ➡  List of nodes representing the target (or “exterior”) set of nodes. (This is the set <code>T</code> from the definition above.) If not specified, this is assumed to be the set of all nodes in <code>G</code> not in <code>nbunch1</code>.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-63"></a>Output:<a class="hash-link" href="#output-63" title="Direct link to heading">#</a></h4><ul><li><code>boundary: List[Vertex]</code> ➡   The node boundary of <code>nbunch1</code> with respect to <code>nbunch2</code>.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-63"></a>Usage:<a class="hash-link" href="#usage-63" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH (n:Label)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">COLLECT (n) AS sources1</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.node_boundary(sources1) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN boundary;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="node_connectivitysource-target"></a><code>node_connectivity(source, target)</code><a class="hash-link" href="#node_connectivitysource-target" title="Direct link to heading">#</a></h3><p>Returns an approximation for node connectivity for a graph or digraph <code>G</code>.</p><p><em>Node connectivity</em> is equal to the minimum number of nodes that must be removed to disconnect <code>G</code> or render it trivial. By Menger’s theorem, this is equal to the number of node independent paths (paths that share no nodes other than <code>source</code> and <code>target</code>).
If <code>source</code> and <code>target</code> nodes are provided, this function returns the local node connectivity: the minimum number of nodes that must be removed to break all paths from source to <code>target</code> in <code>G</code>.
This algorithm is based on a fast approximation that gives a strict lower bound on the actual number of node independent paths between two nodes. It works for both directed and undirected graphs.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-40"></a>Input:<a class="hash-link" href="#input-40" title="Direct link to heading">#</a></h4><ul><li><code>source: Vertex(NULL)</code> ➡  Source node.</li><li><code>target: Vertex(NULL)</code> ➡   Target node.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-64"></a>Output:<a class="hash-link" href="#output-64" title="Direct link to heading">#</a></h4><ul><li><code>connectivity: int</code> ➡  Node connectivity of <code>G</code>, or local node connectivity if <code>source</code> and <code>target</code> are provided.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-64"></a>Usage:<a class="hash-link" href="#usage-64" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH (n:Label), (m:Label)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.node_connectivity(n, m) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN connectivity;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="node_expansions"></a><code>node_expansion(s)</code><a class="hash-link" href="#node_expansions" title="Direct link to heading">#</a></h3><p>Returns the node expansion of the set <code>S</code>.
The <em>node expansion</em> is the quotient of the size of the node boundary of <code>S</code> and the cardinality of <code>S</code>.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-41"></a>Input:<a class="hash-link" href="#input-41" title="Direct link to heading">#</a></h4><ul><li><code>s: List[Vertex]</code> ➡  A sequence of nodes in <code>G</code>.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-65"></a>Output:<a class="hash-link" href="#output-65" title="Direct link to heading">#</a></h4><ul><li><code>node_expansion: double</code> ➡   The node expansion of the set <code>S</code>.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-65"></a>Usage:<a class="hash-link" href="#usage-65" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH (n:Label)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">WITH COLLECT(n) AS s</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.node_expansion(s) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN node_expansion;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="non_randomnessk"></a><code>non_randomness(k)</code><a class="hash-link" href="#non_randomnessk" title="Direct link to heading">#</a></h3><p>Compute the non-randomness of graph <code>G</code>.
The first returned value <code>non_randomness</code> is the sum of non-randomness values of all edges within the graph (where the non-randomness of an edge tends to be small when the two nodes linked by that edge are from two different communities).
The second computed value <code>relative_non_randomness</code> is a relative measure that indicates to what extent graph <code>G</code> is different from random graphs in terms of probability. When it is close to 0, the graph tends to be more likely generated by an Erdos Renyi model.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-42"></a>Input:<a class="hash-link" href="#input-42" title="Direct link to heading">#</a></h4><ul><li><code>k: int(NULL)</code> ➡  The number of communities in <code>G</code>. If <code>k</code> is not set, the function will use a default community detection algorithm to set it.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-66"></a>Output:<a class="hash-link" href="#output-66" title="Direct link to heading">#</a></h4><ul><li><code>non_randomness: double</code> ➡  Non-randomness of a graph</li><li><code>relative_non_randomness: double</code> ➡  Relative non-randomness of a graph</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-66"></a>Usage:<a class="hash-link" href="#usage-66" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.non_randomness() YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN non_randomness, relative_non_randomness;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="pagerankalpha-personalization-max_iter-tol-nstart-weight-dangling"></a><code>pagerank(alpha, personalization, max_iter, tol, nstart, weight, dangling)</code><a class="hash-link" href="#pagerankalpha-personalization-max_iter-tol-nstart-weight-dangling" title="Direct link to heading">#</a></h3><p>Returns the PageRank of the nodes in the graph.</p><p>PageRank computes a ranking of the nodes in the graph G based on the structure of the incoming links. It was originally designed as an algorithm to rank web pages.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-43"></a>Input:<a class="hash-link" href="#input-43" title="Direct link to heading">#</a></h4><ul><li><code>alpha: double(0.85)</code> ➡  Damping parameter for PageRank.</li><li><code>personalization: str(NULL)</code> ➡  The “personalization vector” consisting of a dictionary with a subset of graph nodes as a key and maps personalization value for each subset. At least one personalization value must be non-zero. If not specified, a nodes personalization value will be zero. By default, a uniform distribution is used.</li><li><code>max_iter: int(100)</code> ➡  Maximum number of iterations in power method eigenvalue solver.</li><li><code>tol: double(1e-06)</code> ➡  Error tolerance used to check convergence in power method solver.</li><li><code>nstart: str(NULL)</code> ➡ Starting value of PageRank iteration for each node.</li><li><code>weight: str(&quot;weight&quot;)</code> ➡  Edge data key to use as weight. If <code>None</code>, weights are set to 1.</li><li><code>dangling: str(NULL)</code> ➡  The outedges to be assigned to any “dangling” nodes, i.e., nodes without any outedges. The dict key is the node the outedge points to and the dict value is the weight of that outedge. By default, dangling nodes are given outedges according to the personalization vector (uniform if not specified). This must be selected to result in an irreducible transition matrix. It may be common to have the dangling dict to be the same as the personalization dict.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-67"></a>Output:<a class="hash-link" href="#output-67" title="Direct link to heading">#</a></h4><ul><li><code>node: Vertex</code> ➡ Vertex to calculate PageRank for.</li><li><code>rank: double</code> ➡ Node PageRank.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-67"></a>Usage:<a class="hash-link" href="#usage-67" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.pagerank() YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN node, rank;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="reciprocitynodes"></a><code>reciprocity(nodes)</code><a class="hash-link" href="#reciprocitynodes" title="Direct link to heading">#</a></h3><p>Compute the reciprocity in a directed graph.
The <em>reciprocity</em> of a directed graph is defined as the ratio of the number of edges pointing in both directions to the total number of edges in the graph.
The reciprocity of a single node <code>u</code> is defined similarly, it is the ratio of the number of edges in both directions to the total number of edges attached to node <code>u</code>.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-44"></a>Input:<a class="hash-link" href="#input-44" title="Direct link to heading">#</a></h4><ul><li><code>nodes: List[Vertex]</code> ➡  Compute reciprocity for nodes in this container.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-68"></a>Output:<a class="hash-link" href="#output-68" title="Direct link to heading">#</a></h4><ul><li><code>node: Vertex</code> ➡ Node to calculate reciprocity.</li><li><code>reciprocity: double</code> ➡ Reciprocity value</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-68"></a>Usage:<a class="hash-link" href="#usage-68" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH(n:Label)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">WITH COLLECT(n) AS nodes</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.reciprocity(nodes) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN node, reciprocity;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="shortest_pathsource-target-weight-method"></a><code>shortest_path(source, target, weight, method)</code><a class="hash-link" href="#shortest_pathsource-target-weight-method" title="Direct link to heading">#</a></h3><p>Compute shortest paths in the graph.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-45"></a>Input:<a class="hash-link" href="#input-45" title="Direct link to heading">#</a></h4><ul><li><code>source: Vertex(NULL)</code> ➡  Starting node for the path. If not specified, compute shortest path lengths using all nodes as source nodes.</li><li><code>target: Vertex(NULL)</code> ➡  Ending node for the path. If not specified, compute shortest path lengths using all nodes as target nodes.</li><li><code>weight: str(NULL)</code> ➡  If <code>None</code>, every edge has weight/distance/cost 1. If a string, use this edge attribute as the edge weight. Any edge attribute not present defaults to 1.</li><li><code>method: str(&quot;dijkstra&quot;)</code> ➡  The algorithm to use to compute the path length. Supported options: ‘dijkstra’, ‘bellman-ford’. Other inputs produce a ValueError. If <code>weight</code> is <code>None</code>, unweighted graph methods are used and this suggestion is ignored.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-69"></a>Output:<a class="hash-link" href="#output-69" title="Direct link to heading">#</a></h4><ul><li><code>source: Vertex</code> ➡   Source node.</li><li><code>target: Vertex</code> ➡   Target node.</li><li><code>path: List[Vertex]</code> ➡   All returned paths include both the <code>source</code> and <code>target</code> in the path. If the <code>source</code> and <code>target</code> are both specified, return a single list of nodes in a shortest path from the <code>source</code> to the <code>target</code>. If only the <code>source</code> is specified, return a dictionary keyed by targets with a list of nodes in a shortest path from the <code>source</code> to one of the targets. If only the <code>target</code> is specified, return a dictionary keyed by sources with a list of nodes in a shortest path from one of the sources to the <code>target</code>. If neither the <code>source</code> nor <code>target</code> are specified return a dictionary of dictionaries with <code>path[source][target]=[list of nodes in path]</code>.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-69"></a>Usage:<a class="hash-link" href="#usage-69" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH (n:Label), (m:Label)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.shortest_path(n, m) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN source, target, path;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="shortest_path_lengthsource-target-weight-method"></a><code>shortest_path_length(source, target, weight, method)</code><a class="hash-link" href="#shortest_path_lengthsource-target-weight-method" title="Direct link to heading">#</a></h3><p>Compute shortest path lengths in the graph.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-46"></a>Input:<a class="hash-link" href="#input-46" title="Direct link to heading">#</a></h4><ul><li><code>source: Vertex(NULL)</code> ➡  Starting node for the path. If not specified, compute shortest path lengths using all nodes as source nodes.</li><li><code>target: Vertex(NULL)</code> ➡  Ending node for the path. If not specified, compute shortest path lengths using all nodes as target nodes.</li><li><code>weight: str(NULL)</code> ➡  If <code>None</code>, every edge has weight/distance/cost 1. If a string, use this edge attribute as the edge weight. Any edge attribute not present defaults to 1.</li><li><code>method: str(&quot;dijkstra&quot;)</code> ➡  The algorithm to use to compute the path length. Supported options: ‘dijkstra’, ‘bellman-ford’. Other inputs produce a ValueError. If <code>weight</code> is <code>None</code>, unweighted graph methods are used and this suggestion is ignored.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-70"></a>Output:<a class="hash-link" href="#output-70" title="Direct link to heading">#</a></h4><ul><li><code>source: Vertex</code> ➡   Source node.</li><li><code>target: Vertex</code> ➡   Target node.</li><li><code>length: double</code> ➡   If the <code>source</code> and <code>target</code> are both specified, return the length of the shortest path from the <code>source</code> to the <code>target</code>. If only the <code>source</code> is specified, return a dict keyed by <code>target</code> to the shortest path length from the <code>source</code> to that <code>target</code>. If only the <code>target</code> is specified, return a dict keyed by <code>source</code> to the shortest path length from that <code>source</code> to the <code>target</code>. If neither the <code>source</code> nor <code>target</code> are specified, return an iterator over (source, dictionary) where dictionary is keyed by <code>target</code> to shortest path length from <code>source</code> to that <code>target</code>.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-70"></a>Usage:<a class="hash-link" href="#usage-70" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH (n:Label), (m:Label)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.shortest_path_length(n, m) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN source, target, length;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="simple_cycles"></a><code>simple_cycles()</code><a class="hash-link" href="#simple_cycles" title="Direct link to heading">#</a></h3><p>Find simple cycles (elementary circuits) of a directed graph.
A <em>simple cycle</em>, or <em>elementary circuit</em>, is a closed path where no node appears twice. Two elementary circuits are distinct if they are not cyclic permutations of each other.
This is a nonrecursive, iterator/generator version of Johnson’s algorithm. There may be better algorithms for some cases.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-71"></a>Output:<a class="hash-link" href="#output-71" title="Direct link to heading">#</a></h4><ul><li><code>cycles: List[List[Vertex]]</code> ➡  A list of elementary cycles in the graph. Each cycle is represented by a list of nodes in the cycle.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-71"></a>Usage:<a class="hash-link" href="#usage-71" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.simple_cycles() YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN cycles;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="strongly_connected_components"></a><code>strongly_connected_components()</code><a class="hash-link" href="#strongly_connected_components" title="Direct link to heading">#</a></h3><p>Returns nodes in strongly connected components of a graph.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-72"></a>Output:<a class="hash-link" href="#output-72" title="Direct link to heading">#</a></h4><ul><li><code>components: List[List[Vertex]]</code> ➡   A list of lists of nodes, one for each strongly connected component of <code>G</code>.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-72"></a>Usage:<a class="hash-link" href="#usage-72" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.strongly_connected_components() YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN components;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="topological_sort"></a><code>topological_sort()</code><a class="hash-link" href="#topological_sort" title="Direct link to heading">#</a></h3><p>Returns nodes in topologically sorted order.
A <em>topological sort</em> is a non unique permutation of the nodes such that an edge from <code>u</code> to <code>v</code> implies that <code>u</code> appears before <code>v</code> in the topological sort order.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-73"></a>Output:<a class="hash-link" href="#output-73" title="Direct link to heading">#</a></h4><ul><li><code>nodes: List[Vertex]</code> ➡   A list of nodes in topological sorted order.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-73"></a>Usage:<a class="hash-link" href="#usage-73" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.topological_sort() YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN nodes;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="triadic_census"></a><code>triadic_census()</code><a class="hash-link" href="#triadic_census" title="Direct link to heading">#</a></h3><p>Determines the triadic census of a directed graph. The <em>triadic census</em> is a count of how many of the 16 possible types of triads are present in a directed graph.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-74"></a>Output:<a class="hash-link" href="#output-74" title="Direct link to heading">#</a></h4><ul><li><code>triad: str</code> ➡  Triad name.</li><li><code>count: int</code> ➡  Number of occurrences as value.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-74"></a>Usage:<a class="hash-link" href="#usage-74" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.triadic_census() YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN triad, count;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="voronoi_cellscenter_nodes-weight"></a><code>voronoi_cells(center_nodes, weight)</code><a class="hash-link" href="#voronoi_cellscenter_nodes-weight" title="Direct link to heading">#</a></h3><p>Returns the Voronoi cells centered at center_nodes with respect to the shortest-path distance metric.
If <code>C</code> is a set of nodes in the graph and <code>c</code> is an element of <code>C</code>, the <em>Voronoi cell</em> centered at a node <code>c</code> is the set of all nodes
<code>v</code> that are closer to <code>c</code> than to any other center node in <code>C</code> with respect to the shortest-path distance metric.
For directed graphs, this will compute the “outward” Voronoi cells in which distance is measured from the center nodes to the target node.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-47"></a>Input:<a class="hash-link" href="#input-47" title="Direct link to heading">#</a></h4><ul><li><code>center_nodes: List[Vertex]</code> ➡  A nonempty set of nodes in the graph <code>G</code> that represent the centers of the Voronoi cells.</li><li><code>weight: str(NULL)</code> ➡  The edge attribute (or an arbitrary function) representing the weight of an edge. This keyword argument is as described in the documentation for <code>networkx.multi_source_dijkstra_path</code>, for example.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-75"></a>Output:<a class="hash-link" href="#output-75" title="Direct link to heading">#</a></h4><ul><li><code>center: Vertex</code> ➡ Vertex value of center_nodes.</li><li><code>cell: List[Vertex]</code> ➡  Partition of <code>G</code> closer to that center node.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-75"></a>Usage:<a class="hash-link" href="#usage-75" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">MATCH (n)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">WITH COLLECT(n) AS center_nodes</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.voronoi_cells(center_nodes) YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN center, cell;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="wiener_indexweight"></a><code>wiener_index(weight)</code><a class="hash-link" href="#wiener_indexweight" title="Direct link to heading">#</a></h3><p>Returns the Wiener index of the given graph.
The <em>Wiener index</em> of a graph is the sum of the shortest-path distances between each pair of reachable nodes. For pairs of nodes in undirected graphs, only one orientation of the pair is counted.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="input-48"></a>Input:<a class="hash-link" href="#input-48" title="Direct link to heading">#</a></h4><ul><li><code>weight: str(NULL)</code> ➡ The edge attribute to use as distance when computing shortest-path distances. This is passed directly to the
<code>networkx.shortest_path_length</code> function.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-76"></a>Output:<a class="hash-link" href="#output-76" title="Direct link to heading">#</a></h4><ul><li><code>wiener_index: double</code> ➡  The Wiener index of the graph <code>G</code>.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="usage-76"></a>Usage:<a class="hash-link" href="#usage-76" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cypher"><pre tabindex="0" class="prism-code language-cypher codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CALL nxalg.voronoi_cells() YIELD *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RETURN wiener_index;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div></div><footer class="row docusaurus-mt-lg"><div class="col"><a href="https://github.com/memgraph/docs/tree/master/mage/query-modules/python/nxalg.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_3DPF"></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/mage/query-modules/python/graph-coloring"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« graph_coloring</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/mage/query-modules/python/pagerank"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">pagerank »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#abstract" class="table-of-contents__link">Abstract</a></li><li><a href="#procedures" class="table-of-contents__link">Procedures</a><ul><li><a href="#all_shortest_pathssource-target-weight-method" class="table-of-contents__link"><code>all_shortest_paths(source, target, weight, method)</code></a></li><li><a href="#all_simple_pathssource-target-cutoff" class="table-of-contents__link"><code>all_simple_paths(source, target, cutoff)</code></a></li><li><a href="#ancestorssource" class="table-of-contents__link"><code>ancestors(source)</code></a></li><li><a href="#betweenness_centralityk-normalized-weight-endpoints-seed" class="table-of-contents__link"><code>betweenness_centrality(k, normalized, weight, endpoints, seed)</code></a></li><li><a href="#bfs_edgessource-reverse-depth_limit" class="table-of-contents__link"><code>bfs_edges(source, reverse, depth_limit)</code></a></li><li><a href="#bfs_predecessorssource-depth_limit" class="table-of-contents__link"><code>bfs_predecessors(source, depth_limit)</code></a></li><li><a href="#bfs_successorssource-depth_limit" class="table-of-contents__link"><code>bfs_successors(source, depth_limit)</code></a></li><li><a href="#bfs_treesource-reverse-depth_limit" class="table-of-contents__link"><code>bfs_tree(source, reverse, depth_limit)</code></a></li><li><a href="#biconnected_components" class="table-of-contents__link"><code>biconnected_components()</code></a></li><li><a href="#bridgesroot" class="table-of-contents__link"><code>bridges(root)</code></a></li><li><a href="#center" class="table-of-contents__link"><code>center()</code></a></li><li><a href="#chain_decompositionroot" class="table-of-contents__link"><code>chain_decomposition(root)</code></a></li><li><a href="#check_planarity" class="table-of-contents__link"><code>check_planarity()</code></a></li><li><a href="#clusteringnodes-weight" class="table-of-contents__link"><code>clustering(nodes, weight)</code></a></li><li><a href="#communicability" class="table-of-contents__link"><code>communicability()</code></a></li><li><a href="#core_number" class="table-of-contents__link"><code>core_number()</code></a></li><li><a href="#degree_assortativity_coefficientx-y-weight-nodes" class="table-of-contents__link"><code>degree_assortativity_coefficient(x, y, weight, nodes)</code></a></li><li><a href="#descendantssource" class="table-of-contents__link"><code>descendants(source)</code></a></li><li><a href="#dfs_postorder_nodessource-depth_limit" class="table-of-contents__link"><code>dfs_postorder_nodes(source, depth_limit)</code></a></li><li><a href="#dfs_predecessorssource-depth_limit" class="table-of-contents__link"><code>dfs_predecessors(source, depth_limit)</code></a></li><li><a href="#dfs_preorder_nodessource-depth_limit" class="table-of-contents__link"><code>dfs_preorder_nodes(source, depth_limit)</code></a></li><li><a href="#dfs_successorssource-depth_limit" class="table-of-contents__link"><code>dfs_successors(source, depth_limit)</code></a></li><li><a href="#dfs_treesource-depth_limit" class="table-of-contents__link"><code>dfs_tree(source, depth_limit)</code></a></li><li><a href="#diameter" class="table-of-contents__link"><code>diameter()</code></a></li><li><a href="#dominance_frontiersstart" class="table-of-contents__link"><code>dominance_frontiers(start)</code></a></li><li><a href="#dominating_setstart" class="table-of-contents__link"><code>dominating_set(start)</code></a></li><li><a href="#edge_bfssource-orientation" class="table-of-contents__link"><code>edge_bfs(source, orientation)</code></a></li><li><a href="#edge_dfssource-orientation" class="table-of-contents__link"><code>edge_dfs(source, orientation)</code></a></li><li><a href="#find_cliques" class="table-of-contents__link"><code>find_cliques()</code></a></li><li><a href="#find_cyclesource-orientation" class="table-of-contents__link"><code>find_cycle(source, orientation)</code></a></li><li><a href="#flow_hierarchyweight" class="table-of-contents__link"><code>flow_hierarchy(weight)</code></a></li><li><a href="#global_efficiency" class="table-of-contents__link"><code>global_efficiency()</code></a></li><li><a href="#greedy_colorstrategy-interchange" class="table-of-contents__link"><code>greedy_color(strategy, interchange)</code></a></li><li><a href="#has_eulerian_path" class="table-of-contents__link"><code>has_eulerian_path()</code></a></li><li><a href="#has_pathsource-target" class="table-of-contents__link"><code>has_path(source, target)</code></a></li><li><a href="#immediate_dominatorsstart" class="table-of-contents__link"><code>immediate_dominators(start)</code></a></li><li><a href="#is_arborescence" class="table-of-contents__link"><code>is_arborescence()</code></a></li><li><a href="#is_at_free" class="table-of-contents__link"><code>is_at_free()</code></a></li><li><a href="#is_bipartite" class="table-of-contents__link"><code>is_bipartite()</code></a></li><li><a href="#is_branching" class="table-of-contents__link"><code>is_branching()</code></a></li><li><a href="#is_chordal" class="table-of-contents__link"><code>is_chordal()</code></a></li><li><a href="#is_distance_regular" class="table-of-contents__link"><code>is_distance_regular()</code></a></li><li><a href="#is_edge_covercover" class="table-of-contents__link"><code>is_edge_cover(cover)</code></a></li><li><a href="#is_eulerian" class="table-of-contents__link"><code>is_eulerian()</code></a></li><li><a href="#is_forest" class="table-of-contents__link"><code>is_forest()</code></a></li><li><a href="#is_isolaten" class="table-of-contents__link"><code>is_isolate(n)</code></a></li><li><a href="#is_isomorphicnodes1-edges1-nodes2-edges2" class="table-of-contents__link"><code>is_isomorphic(nodes1, edges1, nodes2, edges2)</code></a></li><li><a href="#is_semieulerian" class="table-of-contents__link"><code>is_semieulerian()</code></a></li><li><a href="#is_simple_pathnodes" class="table-of-contents__link"><code>is_simple_path(nodes)</code></a></li><li><a href="#is_strongly_regular" class="table-of-contents__link"><code>is_strongly_regular()</code></a></li><li><a href="#is_tournament" class="table-of-contents__link"><code>is_tournament()</code></a></li><li><a href="#is_tree" class="table-of-contents__link"><code>is_tree()</code></a></li><li><a href="#isolates" class="table-of-contents__link"><code>isolates()</code></a></li><li><a href="#jaccard_coefficientebunch" class="table-of-contents__link"><code>jaccard_coefficient(ebunch)</code></a></li><li><a href="#k_clique_communitiesk-cliques" class="table-of-contents__link"><code>k_clique_communities(k, cliques)</code></a></li><li><a href="#k_componentsdensity" class="table-of-contents__link"><code>k_components(density)</code></a></li><li><a href="#k_edge_componentsk" class="table-of-contents__link"><code>k_edge_components(k)</code></a></li><li><a href="#local_efficiency" class="table-of-contents__link"><code>local_efficiency()</code></a></li><li><a href="#lowest_common_ancestornode1-node2" class="table-of-contents__link"><code>lowest_common_ancestor(node1, node2)</code></a></li><li><a href="#maximal_matching" class="table-of-contents__link"><code>maximal_matching()</code></a></li><li><a href="#minimum_spanning_treeweight-algorithm-ignore_nan" class="table-of-contents__link"><code>minimum_spanning_tree(weight, algorithm, ignore_nan)</code></a></li><li><a href="#multi_source_dijkstra_pathsources-cutoff-weight" class="table-of-contents__link"><code>multi_source_dijkstra_path(sources, cutoff, weight)</code></a></li><li><a href="#multi_source_dijkstra_path_lengthsources-cutoff-weight" class="table-of-contents__link"><code>multi_source_dijkstra_path_length(sources, cutoff, weight)</code></a></li><li><a href="#node_boundarynbunch1-bunch2" class="table-of-contents__link"><code>node_boundary(nbunch1, bunch2)</code></a></li><li><a href="#node_connectivitysource-target" class="table-of-contents__link"><code>node_connectivity(source, target)</code></a></li><li><a href="#node_expansions" class="table-of-contents__link"><code>node_expansion(s)</code></a></li><li><a href="#non_randomnessk" class="table-of-contents__link"><code>non_randomness(k)</code></a></li><li><a href="#pagerankalpha-personalization-max_iter-tol-nstart-weight-dangling" class="table-of-contents__link"><code>pagerank(alpha, personalization, max_iter, tol, nstart, weight, dangling)</code></a></li><li><a href="#reciprocitynodes" class="table-of-contents__link"><code>reciprocity(nodes)</code></a></li><li><a href="#shortest_pathsource-target-weight-method" class="table-of-contents__link"><code>shortest_path(source, target, weight, method)</code></a></li><li><a href="#shortest_path_lengthsource-target-weight-method" class="table-of-contents__link"><code>shortest_path_length(source, target, weight, method)</code></a></li><li><a href="#simple_cycles" class="table-of-contents__link"><code>simple_cycles()</code></a></li><li><a href="#strongly_connected_components" class="table-of-contents__link"><code>strongly_connected_components()</code></a></li><li><a href="#topological_sort" class="table-of-contents__link"><code>topological_sort()</code></a></li><li><a href="#triadic_census" class="table-of-contents__link"><code>triadic_census()</code></a></li><li><a href="#voronoi_cellscenter_nodes-weight" class="table-of-contents__link"><code>voronoi_cells(center_nodes, weight)</code></a></li><li><a href="#wiener_indexweight" class="table-of-contents__link"><code>wiener_index(weight)</code></a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Documentation</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/memgraph/overview">Memgraph DB</a></li><li class="footer__item"><a class="footer__link-item" href="/memgraph-lab">Memgraph Lab</a></li><li class="footer__item"><a class="footer__link-item" href="/cypher-manual">Cypher manual</a></li><li class="footer__item"><a class="footer__link-item" href="/mage">MAGE</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/memgraphdb" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://discourse.memgraph.com" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Developer Forum<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://twitter.com/memgraphdb" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/memgraph" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://www.youtube.com/channel/UCZ3HOJvHGxtQ_JHxOselBYg" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Youtube<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="margin-bottom--sm"><a href="https://memgraph.com" target="_blank" rel="noopener noreferrer" class="footerLogoLink_MyFc"><img src="/img/Memgraph-logo-white-rgb.png" alt="Memgraph Logo" class="themedImage_1VuW themedImage--light_3UqQ footer__logo"><img src="/img/Memgraph-logo-white-rgb.png" alt="Memgraph Logo" class="themedImage_1VuW themedImage--dark_hz6m footer__logo"></a></div><div class="footer__copyright">Copyright © 2021 Memgraph. Built by developers, for developers!</div></div></div></footer></div>
<script src="/assets/js/runtime~main.cc99452f.js"></script>
<script src="/assets/js/main.632830b3.js"></script>
</body>
</html>