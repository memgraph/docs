"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[62037],{3905:(e,d,a)=>{a.d(d,{Zo:()=>p,kt:()=>c});var t=a(67294);function n(e,d,a){return d in e?Object.defineProperty(e,d,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[d]=a,e}function i(e,d){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);d&&(t=t.filter((function(d){return Object.getOwnPropertyDescriptor(e,d).enumerable}))),a.push.apply(a,t)}return a}function o(e){for(var d=1;d<arguments.length;d++){var a=null!=arguments[d]?arguments[d]:{};d%2?i(Object(a),!0).forEach((function(d){n(e,d,a[d])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(d){Object.defineProperty(e,d,Object.getOwnPropertyDescriptor(a,d))}))}return e}function l(e,d){if(null==e)return{};var a,t,n=function(e,d){if(null==e)return{};var a,t,n={},i=Object.keys(e);for(t=0;t<i.length;t++)a=i[t],d.indexOf(a)>=0||(n[a]=e[a]);return n}(e,d);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)a=i[t],d.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var r=t.createContext({}),s=function(e){var d=t.useContext(r),a=d;return e&&(a="function"==typeof e?e(d):o(o({},d),e)),a},p=function(e){var d=s(e.components);return t.createElement(r.Provider,{value:d},e.children)},N={inlineCode:"code",wrapper:function(e){var d=e.children;return t.createElement(t.Fragment,{},d)}},u=t.forwardRef((function(e,d){var a=e.components,n=e.mdxType,i=e.originalType,r=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=s(a),c=n,m=u["".concat(r,".").concat(c)]||u[c]||N[c]||i;return a?t.createElement(m,o(o({ref:d},p),{},{components:a})):t.createElement(m,o({ref:d},p))}));function c(e,d){var a=arguments,n=d&&d.mdxType;if("string"==typeof e||n){var i=a.length,o=new Array(i);o[0]=u;var l={};for(var r in d)hasOwnProperty.call(d,r)&&(l[r]=d[r]);l.originalType=e,l.mdxType="string"==typeof e?e:n,o[1]=l;for(var s=2;s<i;s++)o[s]=a[s];return t.createElement.apply(null,o)}return t.createElement.apply(null,a)}u.displayName="MDXCreateElement"},17795:(e,d,a)=>{a.r(d),a.d(d,{Highlight:()=>u,assets:()=>p,contentTitle:()=>r,default:()=>m,frontMatter:()=>l,metadata:()=>s,toc:()=>N});var t=a(87462),n=(a(67294),a(3905)),i=a(65488),o=a(85162);const l={id:"node-similarity",title:"node_similarity",sidebar_label:"node_similarity"},r=void 0,s={unversionedId:"query-modules/python/node-similarity",id:"query-modules/python/node-similarity",title:"node_similarity",description:"docs-source",source:"@site/mage/query-modules/python/node-similarity.md",sourceDirName:"query-modules/python",slug:"/query-modules/python/node-similarity",permalink:"/docs/mage/query-modules/python/node-similarity",draft:!1,editUrl:"https://github.com/memgraph/docs/tree/master/mage/query-modules/python/node-similarity.md",tags:[],version:"current",frontMatter:{id:"node-similarity",title:"node_similarity",sidebar_label:"node_similarity"},sidebar:"mage",previous:{title:"node2vec_online",permalink:"/docs/mage/query-modules/python/node2vec-online"},next:{title:"nxalg",permalink:"/docs/mage/query-modules/python/nxalg"}},p={},N=[{value:"Abstract",id:"abstract",level:2},{value:"Procedures",id:"procedures",level:2},{value:"<code>cosine(node1, node2, mode)</code>",id:"cosinenode1-node2-mode",level:3},{value:"Input:",id:"input",level:4},{value:"Output:",id:"output",level:4},{value:"Usage:",id:"usage",level:4},{value:"<code>jaccard(node1, node2, mode)</code>",id:"jaccardnode1-node2-mode",level:3},{value:"Input:",id:"input-1",level:4},{value:"Output:",id:"output-1",level:4},{value:"Usage:",id:"usage-1",level:4},{value:"<code>overlap(node1, node2, mode)</code>",id:"overlapnode1-node2-mode",level:3},{value:"Input:",id:"input-2",level:4},{value:"Output:",id:"output-2",level:4},{value:"Usage:",id:"usage-2",level:4},{value:"Example - cosine similarity",id:"example---cosine-similarity",level:2},{value:"Example - Jaccard similarity",id:"example---jaccard-similarity",level:2},{value:"Example - overlap similarity",id:"example---overlap-similarity",level:2}],u=e=>{let{children:d,color:a}=e;return(0,n.kt)("span",{style:{backgroundColor:a,borderRadius:"2px",color:"#fff",padding:"0.2rem"}},d)},c={toc:N,Highlight:u};function m(e){let{components:d,...l}=e;return(0,n.kt)("wrapper",(0,t.Z)({},c,l,{components:d,mdxType:"MDXLayout"}),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/memgraph/mage/blob/main/python/node_similarity.py"},(0,n.kt)("img",{parentName:"a",src:"https://img.shields.io/badge/source-node_similarity-FB6E00?logo=github&style=for-the-badge",alt:"docs-source"}))),(0,n.kt)("h2",{id:"abstract"},"Abstract"),(0,n.kt)("p",null,"If we're interested in how similar two nodes in a graph are, we'll want to get a numerical value that represents the ",(0,n.kt)("em",null,"node similarity")," between those two nodes. There are many node similarity measures and currently this module contains the following: "),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"cosine similarity"),(0,n.kt)("li",{parentName:"ul"},"Jaccard similarity "),(0,n.kt)("li",{parentName:"ul"},"overlap similarity")),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"The cosine similarity")," is computed using the following formula:"),(0,n.kt)("a",{href:"https://www.codecogs.com/eqnedit.php?latex=Cosine(A,B)&space;=&space;\\frac{|A&space;\\cap&space;B|}&space;{\\sqrt{|A|&space;\\cdot&space;|B|}}",target:"_blank"},(0,n.kt)("img",{src:"https://latex.codecogs.com/gif.latex?Cosine(A,B)&space;=&space;\\frac{|A&space;\\cap&space;B|}&space;{\\sqrt{|A|&space;\\cdot&space;|B|}}",title:"Cosine(A,B) = \\frac{|A \\cap B|} {\\sqrt{|A| \\cdot |B|}}"})),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"The Jaccard similarity")," is computed using the following formula:"),(0,n.kt)("a",{href:"https://www.codecogs.com/eqnedit.php?latex=Jaccard(A,B)&space;=&space;\\frac{|A&space;\\cap&space;B|}&space;{|A|&space;&plus;&space;|B|&space;-&space;|A&space;\\cap&space;B|}",target:"_blank"},(0,n.kt)("img",{src:"https://latex.codecogs.com/gif.latex?Jaccard(A,B)&space;=&space;\\frac{|A&space;\\cap&space;B|}&space;{|A|&space;&plus;&space;|B|&space;-&space;|A&space;\\cap&space;B|}",title:"Jaccard(A,B) = \\frac{|A \\cap B|} {|A| + |B| - |A \\cap B|}"})),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"The overalap similarity")," is computed using the following formula:"),(0,n.kt)("a",{href:"https://www.codecogs.com/eqnedit.php?latex=Overlap(A,B)&space;=&space;\\frac{|A&space;\\cap&space;B|}&space;{min(|A|,&space;|B|)}",target:"_blank"},(0,n.kt)("img",{src:"https://latex.codecogs.com/gif.latex?Overlap(A,B)&space;=&space;\\frac{|A&space;\\cap&space;B|}&space;{min(|A|,&space;|B|)}",title:"Overlap(A,B) = \\frac{|A \\cap B|} {min(|A|, |B|)}"})),(0,n.kt)("p",null,"Set A represents all neighbors of one node, set B represents all neighbors of the other node. In all the given formulas, the numerator is the cardinality of the intersection of set A and set B (in other words, the cardinality of the common neighbors set). The denominator differs but requires the cardinality of sets A and B in some way."),(0,n.kt)("p",null,"The algorithm is implemented so that it ignores whether the graph is directed or undirected and treats the edges as if they were undirected. It also ignores multiple edges between two nodes and treats them as if there were only one edge."),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Trait"),(0,n.kt)("th",{parentName:"tr",align:null},"Value"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("strong",{parentName:"td"},"Module type")),(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)(u,{color:"#FB6E00",mdxType:"Highlight"},(0,n.kt)("strong",{parentName:"td"},"algorithm")))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("strong",{parentName:"td"},"Implementation")),(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)(u,{color:"#FB6E00",mdxType:"Highlight"},(0,n.kt)("strong",{parentName:"td"},"Python")))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("strong",{parentName:"td"},"Graph direction")),(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)(u,{color:"#FB6E00",mdxType:"Highlight"},(0,n.kt)("strong",{parentName:"td"},"undirected")))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("strong",{parentName:"td"},"Edge weights")),(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)(u,{color:"#FB6E00",mdxType:"Highlight"},(0,n.kt)("strong",{parentName:"td"},"unweighted")))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("strong",{parentName:"td"},"Parallelism")),(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)(u,{color:"#FB6E00",mdxType:"Highlight"},(0,n.kt)("strong",{parentName:"td"},"sequential")))))),(0,n.kt)("h2",{id:"procedures"},"Procedures"),(0,n.kt)("h3",{id:"cosinenode1-node2-mode"},(0,n.kt)("inlineCode",{parentName:"h3"},"cosine(node1, node2, mode)")),(0,n.kt)("h4",{id:"input"},"Input:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"node1: Union[Vertex, Tuple[Vertex]")," \u27a1 The first node or a tuple of nodes."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"node2: Union[Vertex, Tuple[Vertex]]")," \u27a1 The second node or a tuple of nodes."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},'mode: string (default="cartesian")'),' \u27a1 If the given arguments are tuples, this argument determines whether to calculate the similarity between nodes pairwise ("pairwise") or calculate the similarity between one and each node ("cartesian"). The default value is "cartesian".')),(0,n.kt)("h4",{id:"output"},"Output:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"node1: Vertex")," \u27a1 The first node."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"node2: Vertex")," \u27a1 The second node."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"similarity: float")," \u27a1  The cosine similarity between the first and the second node.")),(0,n.kt)("h4",{id:"usage"},"Usage:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (m)\nWITH COLLECT(m) AS nodes1\nMATCH (n)\nWITH COLLECT(n) AS nodes2, nodes1\nCALL node_similarity.cosine(nodes1, nodes2) YIELD node1, node2, similarity\nRETURN node1, node2, similarity\n")),(0,n.kt)("h3",{id:"jaccardnode1-node2-mode"},(0,n.kt)("inlineCode",{parentName:"h3"},"jaccard(node1, node2, mode)")),(0,n.kt)("h4",{id:"input-1"},"Input:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"node1: Union[Vertex, Tuple[Vertex]")," \u27a1 The first node or a tuple of nodes."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"node2: Union[Vertex, Tuple[Vertex]]")," \u27a1 The second node or a tuple of nodes."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},'mode: string (default="cartesian")'),' \u27a1 If the given arguments are tuples, this argument determines whether to calculate the similarity between nodes pairwise ("pairwise") or calculate the similarity between one and each node ("cartesian"). The default value is "cartesian".')),(0,n.kt)("h4",{id:"output-1"},"Output:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"node1: Vertex")," \u27a1 The first node."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"node2: Vertex")," \u27a1 The second node."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"similarity: float")," \u27a1  The Jaccard similarity between the first and the second node.")),(0,n.kt)("h4",{id:"usage-1"},"Usage:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-cypher"},'MATCH (m)\nWITH COLLECT(m) AS nodes1\nMATCH (n)\nWITH COLLECT(n) AS nodes2, nodes1\nCALL node_similarity.jaccard(nodes1, nodes2, "cartesian") YIELD node1, node2, similarity\nRETURN node1, node2, similarity\n')),(0,n.kt)("h3",{id:"overlapnode1-node2-mode"},(0,n.kt)("inlineCode",{parentName:"h3"},"overlap(node1, node2, mode)")),(0,n.kt)("h4",{id:"input-2"},"Input:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"node1: Union[Vertex, Tuple[Vertex]")," \u27a1 The first node or a tuple of nodes."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"node2: Union[Vertex, Tuple[Vertex]]")," \u27a1 The second node or a tuple of nodes."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},'mode: string (default="cartesian")'),' \u27a1 If the given arguments are tuples, this argument determines whether to calculate the similarity between nodes pairwise ("pairwise") or calculate the similarity between one and each node ("cartesian"). The default value is "cartesian".')),(0,n.kt)("h4",{id:"output-2"},"Output:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"node1: Vertex")," \u27a1 The first node."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"node2: Vertex")," \u27a1 The second node."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"similarity: float")," \u27a1  The overlap similarity between the first and the second node.")),(0,n.kt)("h4",{id:"usage-2"},"Usage:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-cypher"},'MATCH (m)\nWITH COLLECT(m) AS nodes1\nMATCH (n)\nWITH COLLECT(n) AS nodes2, nodes1\nCALL node_similarity.overlap(nodes1, nodes2, "pairwise") YIELD node1, node2, similarity\nRETURN node1, node2, similarity\n')),(0,n.kt)("h2",{id:"example---cosine-similarity"},"Example - cosine similarity"),(0,n.kt)(i.Z,{groupId:"example1",defaultValue:"visualization",values:[{label:"Step 1: Input graph",value:"visualization"},{label:"Step 2: Cypher load commands",value:"cypher"},{label:"Step 3: Running command",value:"run"},{label:"Step 4: Results",value:"result"}],mdxType:"Tabs"},(0,n.kt)(o.Z,{value:"visualization",mdxType:"TabItem"},(0,n.kt)("img",{src:a(82389).Z})),(0,n.kt)(o.Z,{value:"cypher",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-cypher"},"MERGE (a:Node {id: 0}) MERGE (b:Node {id: 2}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 0}) MERGE (b:Node {id: 3}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 0}) MERGE (b:Node {id: 4}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 0}) MERGE (b:Node {id: 5}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 1}) MERGE (b:Node {id: 0}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 1}) MERGE (b:Node {id: 1}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 1}) MERGE (b:Node {id: 2}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 2}) MERGE (b:Node {id: 1}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 2}) MERGE (b:Node {id: 4}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 2}) MERGE (b:Node {id: 5}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 4}) MERGE (b:Node {id: 0}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 4}) MERGE (b:Node {id: 1}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 5}) MERGE (b:Node {id: 2}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 5}) MERGE (b:Node {id: 3}) CREATE (a)-[:RELATION]->(b);\n"))),(0,n.kt)(o.Z,{value:"run",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (m)\nWITH COLLECT(m) AS nodes1\nMATCH (n)\nWITH COLLECT(n) AS nodes2, nodes1\nCALL node_similarity.cosine(nodes1, nodes2) YIELD node1, node2, similarity AS cosine_similarity\nRETURN node1, node2, cosine_similarity;\n"))),(0,n.kt)(o.Z,{value:"result",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-plaintext"},"+-------------------+-------------------+-------------------+\n| node1             | node2             | cosine_similarity |\n+-------------------+-------------------+-------------------+\n| (:Node {id: 0})   | (:Node {id: 0})   | 1                 |\n| (:Node {id: 0})   | (:Node {id: 2})   | 0.67082           |\n| (:Node {id: 0})   | (:Node {id: 3})   | 0.316228          |\n| (:Node {id: 0})   | (:Node {id: 4})   | 0.516398          |\n| (:Node {id: 0})   | (:Node {id: 5})   | 0.516398          |\n| (:Node {id: 0})   | (:Node {id: 1})   | 0.67082           |\n| (:Node {id: 2})   | (:Node {id: 0})   | 0.67082           |\n| (:Node {id: 2})   | (:Node {id: 2})   | 1                 |\n| (:Node {id: 2})   | (:Node {id: 3})   | 0.707107          |\n| (:Node {id: 2})   | (:Node {id: 4})   | 0.57735           |\n| (:Node {id: 2})   | (:Node {id: 5})   | 0.288675          |\n| (:Node {id: 2})   | (:Node {id: 1})   | 0.75              |\n| (:Node {id: 3})   | (:Node {id: 0})   | 0.316228          |\n| (:Node {id: 3})   | (:Node {id: 2})   | 0.707107          |\n| (:Node {id: 3})   | (:Node {id: 3})   | 1                 |\n| (:Node {id: 3})   | (:Node {id: 4})   | 0.408248          |\n| (:Node {id: 3})   | (:Node {id: 5})   | 0.408248          |\n| (:Node {id: 3})   | (:Node {id: 1})   | 0.353553          |\n| (:Node {id: 4})   | (:Node {id: 0})   | 0.516398          |\n| (:Node {id: 4})   | (:Node {id: 2})   | 0.57735           |\n| (:Node {id: 4})   | (:Node {id: 3})   | 0.408248          |\n| (:Node {id: 4})   | (:Node {id: 4})   | 1                 |\n| (:Node {id: 4})   | (:Node {id: 5})   | 0.666667          |\n| (:Node {id: 4})   | (:Node {id: 1})   | 0.866025          |\n| (:Node {id: 5})   | (:Node {id: 0})   | 0.516398          |\n| (:Node {id: 5})   | (:Node {id: 2})   | 0.288675          |\n| (:Node {id: 5})   | (:Node {id: 3})   | 0.408248          |\n| (:Node {id: 5})   | (:Node {id: 4})   | 0.666667          |\n| (:Node {id: 5})   | (:Node {id: 5})   | 1                 |\n| (:Node {id: 5})   | (:Node {id: 1})   | 0.57735           |\n| (:Node {id: 1})   | (:Node {id: 0})   | 0.67082           |\n| (:Node {id: 1})   | (:Node {id: 2})   | 0.75              |\n| (:Node {id: 1})   | (:Node {id: 3})   | 0.353553          |\n| (:Node {id: 1})   | (:Node {id: 4})   | 0.866025          |\n| (:Node {id: 1})   | (:Node {id: 5})   | 0.57735           |\n| (:Node {id: 1})   | (:Node {id: 1})   | 1                 |\n+-------------------+-------------------+-------------------+\n\n")))),(0,n.kt)("h2",{id:"example---jaccard-similarity"},"Example - Jaccard similarity"),(0,n.kt)(i.Z,{groupId:"example2",defaultValue:"visualization",values:[{label:"Step 1: Input graph",value:"visualization"},{label:"Step 2: Cypher load commands",value:"cypher"},{label:"Step 3: Running command",value:"run"},{label:"Step 4: Results",value:"result"}],mdxType:"Tabs"},(0,n.kt)(o.Z,{value:"visualization",mdxType:"TabItem"},(0,n.kt)("img",{src:a(82389).Z})),(0,n.kt)(o.Z,{value:"cypher",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-cypher"},"MERGE (a:Node {id: 0}) MERGE (b:Node {id: 2}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 0}) MERGE (b:Node {id: 3}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 0}) MERGE (b:Node {id: 4}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 0}) MERGE (b:Node {id: 5}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 1}) MERGE (b:Node {id: 0}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 1}) MERGE (b:Node {id: 1}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 1}) MERGE (b:Node {id: 2}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 2}) MERGE (b:Node {id: 1}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 2}) MERGE (b:Node {id: 4}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 2}) MERGE (b:Node {id: 5}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 4}) MERGE (b:Node {id: 0}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 4}) MERGE (b:Node {id: 1}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 5}) MERGE (b:Node {id: 2}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 5}) MERGE (b:Node {id: 3}) CREATE (a)-[:RELATION]->(b);\n"))),(0,n.kt)(o.Z,{value:"run",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (m)\nWITH COLLECT(m) AS nodes1\nMATCH (n)\nWITH COLLECT(n) AS nodes2, nodes1\nCALL node_similarity.jaccard(nodes1, nodes2) YIELD node1, node2, similarity AS jaccard_similarity\nRETURN node1, node2, jaccard_similarity;\n"))),(0,n.kt)(o.Z,{value:"result",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-plaintext"},"+--------------------+--------------------+--------------------+\n| node1              | node2              | jaccard_similarity |\n+--------------------+--------------------+--------------------+\n| (:Node {id: 0})    | (:Node {id: 0})    | 1                  |\n| (:Node {id: 0})    | (:Node {id: 2})    | 0.5                |\n| (:Node {id: 0})    | (:Node {id: 3})    | 0.166667           |\n| (:Node {id: 0})    | (:Node {id: 4})    | 0.333333           |\n| (:Node {id: 0})    | (:Node {id: 5})    | 0.333333           |\n| (:Node {id: 0})    | (:Node {id: 1})    | 0.5                |\n| (:Node {id: 2})    | (:Node {id: 0})    | 0.5                |\n| (:Node {id: 2})    | (:Node {id: 2})    | 1                  |\n| (:Node {id: 2})    | (:Node {id: 3})    | 0.5                |\n| (:Node {id: 2})    | (:Node {id: 4})    | 0.4                |\n| (:Node {id: 2})    | (:Node {id: 5})    | 0.166667           |\n| (:Node {id: 2})    | (:Node {id: 1})    | 0.6                |\n| (:Node {id: 3})    | (:Node {id: 0})    | 0.166667           |\n| (:Node {id: 3})    | (:Node {id: 2})    | 0.5                |\n| (:Node {id: 3})    | (:Node {id: 3})    | 1                  |\n| (:Node {id: 3})    | (:Node {id: 4})    | 0.25               |\n| (:Node {id: 3})    | (:Node {id: 5})    | 0.25               |\n| (:Node {id: 3})    | (:Node {id: 1})    | 0.2                |\n| (:Node {id: 4})    | (:Node {id: 0})    | 0.333333           |\n| (:Node {id: 4})    | (:Node {id: 2})    | 0.4                |\n| (:Node {id: 4})    | (:Node {id: 3})    | 0.25               |\n| (:Node {id: 4})    | (:Node {id: 4})    | 1                  |\n| (:Node {id: 4})    | (:Node {id: 5})    | 0.5                |\n| (:Node {id: 4})    | (:Node {id: 1})    | 0.75               |\n| (:Node {id: 5})    | (:Node {id: 0})    | 0.333333           |\n| (:Node {id: 5})    | (:Node {id: 2})    | 0.166667           |\n| (:Node {id: 5})    | (:Node {id: 3})    | 0.25               |\n| (:Node {id: 5})    | (:Node {id: 4})    | 0.5                |\n| (:Node {id: 5})    | (:Node {id: 5})    | 1                  |\n| (:Node {id: 5})    | (:Node {id: 1})    | 0.4                |\n| (:Node {id: 1})    | (:Node {id: 0})    | 0.5                |\n| (:Node {id: 1})    | (:Node {id: 2})    | 0.6                |\n| (:Node {id: 1})    | (:Node {id: 3})    | 0.2                |\n| (:Node {id: 1})    | (:Node {id: 4})    | 0.75               |\n| (:Node {id: 1})    | (:Node {id: 5})    | 0.4                |\n| (:Node {id: 1})    | (:Node {id: 1})    | 1                  |\n+--------------------+--------------------+--------------------+\n\n")))),(0,n.kt)("h2",{id:"example---overlap-similarity"},"Example - overlap similarity"),(0,n.kt)(i.Z,{groupId:"example3",defaultValue:"visualization",values:[{label:"Step 1: Input graph",value:"visualization"},{label:"Step 2: Cypher load commands",value:"cypher"},{label:"Step 3: Running command",value:"run"},{label:"Step 4: Results",value:"result"}],mdxType:"Tabs"},(0,n.kt)(o.Z,{value:"visualization",mdxType:"TabItem"},(0,n.kt)("img",{src:a(82389).Z})),(0,n.kt)(o.Z,{value:"cypher",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-cypher"},"MERGE (a:Node {id: 0}) MERGE (b:Node {id: 2}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 0}) MERGE (b:Node {id: 3}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 0}) MERGE (b:Node {id: 4}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 0}) MERGE (b:Node {id: 5}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 1}) MERGE (b:Node {id: 0}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 1}) MERGE (b:Node {id: 1}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 1}) MERGE (b:Node {id: 2}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 2}) MERGE (b:Node {id: 1}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 2}) MERGE (b:Node {id: 4}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 2}) MERGE (b:Node {id: 5}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 4}) MERGE (b:Node {id: 0}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 4}) MERGE (b:Node {id: 1}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 5}) MERGE (b:Node {id: 2}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 5}) MERGE (b:Node {id: 3}) CREATE (a)-[:RELATION]->(b);\n"))),(0,n.kt)(o.Z,{value:"run",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (m)\nWITH COLLECT(m) AS nodes1\nMATCH (n)\nWITH COLLECT(n) AS nodes2, nodes1\nCALL node_similarity.overlap(nodes1, nodes2) YIELD node1, node2, similarity AS overlap_similarity\nRETURN node1, node2, overlap_similarity;\n"))),(0,n.kt)(o.Z,{value:"result",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-plaintext"},"+--------------------+--------------------+--------------------+\n| node1              | node2              | overlap_similarity |\n+--------------------+--------------------+--------------------+\n| (:Node {id: 0})    | (:Node {id: 0})    | 1                  |\n| (:Node {id: 0})    | (:Node {id: 2})    | 0.75               |\n| (:Node {id: 0})    | (:Node {id: 3})    | 0.5                |\n| (:Node {id: 0})    | (:Node {id: 4})    | 0.666667           |\n| (:Node {id: 0})    | (:Node {id: 5})    | 0.666667           |\n| (:Node {id: 0})    | (:Node {id: 1})    | 0.75               |\n| (:Node {id: 2})    | (:Node {id: 0})    | 0.75               |\n| (:Node {id: 2})    | (:Node {id: 2})    | 1                  |\n| (:Node {id: 2})    | (:Node {id: 3})    | 1                  |\n| (:Node {id: 2})    | (:Node {id: 4})    | 0.666667           |\n| (:Node {id: 2})    | (:Node {id: 5})    | 0.333333           |\n| (:Node {id: 2})    | (:Node {id: 1})    | 0.75               |\n| (:Node {id: 3})    | (:Node {id: 0})    | 0.5                |\n| (:Node {id: 3})    | (:Node {id: 2})    | 1                  |\n| (:Node {id: 3})    | (:Node {id: 3})    | 1                  |\n| (:Node {id: 3})    | (:Node {id: 4})    | 0.5                |\n| (:Node {id: 3})    | (:Node {id: 5})    | 0.5                |\n| (:Node {id: 3})    | (:Node {id: 1})    | 0.5                |\n| (:Node {id: 4})    | (:Node {id: 0})    | 0.666667           |\n| (:Node {id: 4})    | (:Node {id: 2})    | 0.666667           |\n| (:Node {id: 4})    | (:Node {id: 3})    | 0.5                |\n| (:Node {id: 4})    | (:Node {id: 4})    | 1                  |\n| (:Node {id: 4})    | (:Node {id: 5})    | 0.666667           |\n| (:Node {id: 4})    | (:Node {id: 1})    | 1                  |\n| (:Node {id: 5})    | (:Node {id: 0})    | 0.666667           |\n| (:Node {id: 5})    | (:Node {id: 2})    | 0.333333           |\n| (:Node {id: 5})    | (:Node {id: 3})    | 0.5                |\n| (:Node {id: 5})    | (:Node {id: 4})    | 0.666667           |\n| (:Node {id: 5})    | (:Node {id: 5})    | 1                  |\n| (:Node {id: 5})    | (:Node {id: 1})    | 0.666667           |\n| (:Node {id: 1})    | (:Node {id: 0})    | 0.75               |\n| (:Node {id: 1})    | (:Node {id: 2})    | 0.75               |\n| (:Node {id: 1})    | (:Node {id: 3})    | 0.5                |\n| (:Node {id: 1})    | (:Node {id: 4})    | 1                  |\n| (:Node {id: 1})    | (:Node {id: 5})    | 0.666667           |\n| (:Node {id: 1})    | (:Node {id: 1})    | 1                  |\n+--------------------+--------------------+--------------------+\n\n")))))}m.isMDXComponent=!0},85162:(e,d,a)=>{a.d(d,{Z:()=>o});var t=a(67294),n=a(86010);const i="tabItem_Ymn6";function o(e){let{children:d,hidden:a,className:o}=e;return t.createElement("div",{role:"tabpanel",className:(0,n.Z)(i,o),hidden:a},d)}},65488:(e,d,a)=>{a.d(d,{Z:()=>c});var t=a(87462),n=a(67294),i=a(86010),o=a(72389),l=a(67392),r=a(7094),s=a(12466);const p="tabList__CuJ",N="tabItem_LNqP";function u(e){var d;const{lazy:a,block:o,defaultValue:u,values:c,groupId:m,className:E}=e,h=n.Children.map(e.children,(e=>{if((0,n.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),b=c??h.map((e=>{let{props:{value:d,label:a,attributes:t}}=e;return{value:d,label:a,attributes:t}})),T=(0,l.l)(b,((e,d)=>e.value===d.value));if(T.length>0)throw new Error(`Docusaurus error: Duplicate values "${T.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const y=null===u?u:u??(null==(d=h.find((e=>e.props.default)))?void 0:d.props.value)??h[0].props.value;if(null!==y&&!b.some((e=>e.value===y)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${y}" but none of its children has the corresponding value. Available values are: ${b.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:g,setTabGroupChoices:k}=(0,r.U)(),[R,v]=(0,n.useState)(y),A=[],{blockElementScrollPositionUntilNextRender:f}=(0,s.o5)();if(null!=m){const e=g[m];null!=e&&e!==R&&b.some((d=>d.value===e))&&v(e)}const C=e=>{const d=e.currentTarget,a=A.indexOf(d),t=b[a].value;t!==R&&(f(d),v(t),null!=m&&k(m,String(t)))},M=e=>{var d;let a=null;switch(e.key){case"Enter":C(e);break;case"ArrowRight":{const d=A.indexOf(e.currentTarget)+1;a=A[d]??A[0];break}case"ArrowLeft":{const d=A.indexOf(e.currentTarget)-1;a=A[d]??A[A.length-1];break}}null==(d=a)||d.focus()};return n.createElement("div",{className:(0,i.Z)("tabs-container",p)},n.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":o},E)},b.map((e=>{let{value:d,label:a,attributes:o}=e;return n.createElement("li",(0,t.Z)({role:"tab",tabIndex:R===d?0:-1,"aria-selected":R===d,key:d,ref:e=>A.push(e),onKeyDown:M,onClick:C},o,{className:(0,i.Z)("tabs__item",N,null==o?void 0:o.className,{"tabs__item--active":R===d})}),a??d)}))),a?(0,n.cloneElement)(h.filter((e=>e.props.value===R))[0],{className:"margin-top--md"}):n.createElement("div",{className:"margin-top--md"},h.map(((e,d)=>(0,n.cloneElement)(e,{key:d,hidden:e.props.value!==R})))))}function c(e){const d=(0,o.Z)();return n.createElement(u,(0,t.Z)({key:String(d)},e))}},82389:(e,d,a)=>{a.d(d,{Z:()=>t});const t=a.p+"assets/images/node-similarity-1-5fd5e2699b4725c45d85f6d49b3d8114.png"}}]);