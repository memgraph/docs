"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[11475],{3905:function(e,t,n){n.d(t,{Zo:function(){return h},kt:function(){return m}});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},h=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),u=p(n),m=i,g=u["".concat(l,".").concat(m)]||u[m]||d[m]||r;return n?a.createElement(g,o(o({ref:t},h),{},{components:n})):a.createElement(g,o({ref:t},h))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},56387:function(e,t,n){n.r(t),n.d(t,{assets:function(){return h},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return s},metadata:function(){return p},toc:function(){return d}});var a=n(87462),i=n(63366),r=(n(67294),n(3905)),o=["components"],s={id:"built-in-graph-algorithms",title:"Built-in graph algorithms",sidebar_label:"Built-in graph algorithms"},l=void 0,p={unversionedId:"reference-guide/built-in-graph-algorithms",id:"version-2.3.1/reference-guide/built-in-graph-algorithms",title:"Built-in graph algorithms",description:"Graph algorithms are a set of instructions that traverse (visits nodes of) a",source:"@site/memgraph_versioned_docs/version-2.3.1/reference-guide/graph-algorithms.md",sourceDirName:"reference-guide",slug:"/reference-guide/built-in-graph-algorithms",permalink:"/docs/memgraph/reference-guide/built-in-graph-algorithms",editUrl:"https://github.com/memgraph/docs/tree/master/memgraph_versioned_docs/version-2.3.1/reference-guide/graph-algorithms.md",tags:[],version:"2.3.1",frontMatter:{id:"built-in-graph-algorithms",title:"Built-in graph algorithms",sidebar_label:"Built-in graph algorithms"},sidebar:"memgraph",previous:{title:"Reference guide overview",permalink:"/docs/memgraph/reference-guide"},next:{title:"Controlling memory usage",permalink:"/docs/memgraph/reference-guide/memory-control"}},h={},d=[{value:"Depth-first search",id:"depth-first-search",level:2},{value:"Getting various results",id:"getting-various-results",level:3},{value:"Filtering by relationships type and direction",id:"filtering-by-relationships-type-and-direction",level:3},{value:"Constraining the path&#39;s length",id:"constraining-the-paths-length",level:3},{value:"Constraining the expansion based on property values",id:"constraining-the-expansion-based-on-property-values",level:3},{value:"Breadth-first search",id:"breadth-first-search",level:2},{value:"Getting various results",id:"getting-various-results-1",level:3},{value:"Filtering by relationships type and direction",id:"filtering-by-relationships-type-and-direction-1",level:3},{value:"Constraining the path&#39;s length",id:"constraining-the-paths-length-1",level:3},{value:"Constraining the expansion based on property values",id:"constraining-the-expansion-based-on-property-values-1",level:3},{value:"Weighted Shortest Path",id:"weighted-shortest-path",level:2},{value:"Getting various results",id:"getting-various-results-2",level:3},{value:"Filtering by relationships type and direction",id:"filtering-by-relationships-type-and-direction-2",level:3},{value:"Constraining the path&#39;s length",id:"constraining-the-paths-length-2",level:3},{value:"Constraining the expansion based on property values",id:"constraining-the-expansion-based-on-property-values-2",level:3}],u={toc:d};function m(e){var t=e.components,n=(0,i.Z)(e,o);return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Graph algorithms are a set of instructions that traverse (visits nodes of) a\ngraph and find specific nodes, paths, or a path between two nodes. Some of these\nalgorithms are built into Memgraph and don't require any additional libraries:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#depth-first-search"},"Depth-first search (DFS)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#breadth-first-search"},"Breadth-first search (BFS)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#weighted-shortest-path"},"Weighted shortest path (WSP)"))),(0,r.kt)("p",null,"Below you can find examples of how to use these algorithms, and you can try them out\nin the ",(0,r.kt)("a",{parentName:"p",href:"https://playground.memgraph.com/sandbox/europe-backpacking"},"Playground\nsandbox")," using the\nEurope backpacking dataset, or adjust them to the dataset of your choice. "),(0,r.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"Memgraph has a lot more graph algorithms to offer besides these three, and they\nare all a part of ",(0,r.kt)("a",{parentName:"p",href:"/mage"},"MAGE")," - Memgraph Advanced Graph Extensions, an\nopen-source repository that contains graph algorithms and modules written in the\nform of query modules that can be used to tackle the most interesting and\nchallenging graph analytics problems. Check the ",(0,r.kt)("a",{parentName:"p",href:"/mage/algorithms"},"full list of algorithms"),". "))),(0,r.kt)("h2",{id:"depth-first-search"},"Depth-first search"),(0,r.kt)("p",null,"Depth-first search (DFS) is an algorithm for traversing through the graph. The\nalgorithm starts at the root node and explores each neighboring node as far as\npossible. The moment it reaches a dead-end, it backtracks until it finds a new,\nundiscovered node, then traverses from that node to find more undiscovered\nnodes. In that way, the algorithm visits each node in the graph."),(0,r.kt)("p",null,"DFS in Memgraph has been implemented based on the relationship expansion syntax\nwhich allows it to find multiple relationships between two nodes if such exist.\nBelow are several examples of how to use the DFS in Memgraph."),(0,r.kt)("h3",{id:"getting-various-results"},"Getting various results"),(0,r.kt)("p",null,"The following query will show all the paths from node ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," to node ",(0,r.kt)("inlineCode",{parentName:"p"},"m"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH path=(n {id: 0})-[*]->(m {id: 8}) \nRETURN path;\n")),(0,r.kt)("p",null,"To get the list of all relationships, add a variable in the square brackets and\nreturn it as a result:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (n {id: 0})-[relationships *]->(m {id: 8}) \nRETURN relationships;\n")),(0,r.kt)("p",null,"To get the list of path nodes, use the ",(0,r.kt)("inlineCode",{parentName:"p"},"nodes()")," function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH path=(n {id: 0})-[*]->(m {id: 8}) \nRETURN path,nodes(path);\n")),(0,r.kt)("h3",{id:"filtering-by-relationships-type-and-direction"},"Filtering by relationships type and direction"),(0,r.kt)("p",null,"You can filter relationships by type by defining the type after the relationship\nlist variable, and you decide the direction by adding or removing an arrow from\nthe dash."),(0,r.kt)("p",null,"In the following example, the algorithm will traverse only across ",(0,r.kt)("inlineCode",{parentName:"p"},"CloseTo")," type\nof relationships:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH path=(n {id: 0})-[relationships:CloseTo *]->(m {id: 8}) \nRETURN path,relationships;\n")),(0,r.kt)("p",null,"Be careful when using algorithms, especially DFS, without defining a direction.\nDepending on the size of the dataset, the execution of the query can cause a\ntimeout. "),(0,r.kt)("h3",{id:"constraining-the-paths-length"},"Constraining the path's length"),(0,r.kt)("p",null,"The constraints on the path length are defined after the asterisk sign. The\nfollowing query will return all the results when the path is equal to or shorter\nthan 5 hops:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH path=(n {id: 0})-[relationships * ..5]->(m {id: 8}) \nRETURN path,relationships;\n")),(0,r.kt)("p",null,"This query will return all the paths that are equal to or longer than 3, and\nequal to or shorter than 5 hops:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH path=(n {id: 0})-[relationships * 3..5]->(m {id: 8}) \nRETURN path,relationships;\n")),(0,r.kt)("h3",{id:"constraining-the-expansion-based-on-property-values"},"Constraining the expansion based on property values"),(0,r.kt)("p",null,"Depth-first expansion allows an arbitrary expression filter that determines if\nan expansion is allowed over a certain relationship to a certain node. The\nfilter is defined as a lambda function over ",(0,r.kt)("inlineCode",{parentName:"p"},"r")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"n"),", which denotes the\nrelationship expanded over and node expanded to in the depth-first search. "),(0,r.kt)("p",null,"In the following example, expansion is allowed over relationships with an ",(0,r.kt)("inlineCode",{parentName:"p"},"eu_border"),"\nproperty equal to ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," and to nodes with a ",(0,r.kt)("inlineCode",{parentName:"p"},"drinks_USD")," property less than ",(0,r.kt)("inlineCode",{parentName:"p"},"15"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH path=(n {id: 0})-[* (r, n | r.eu_border = false AND n.drinks_USD < 15)]->(m {id: 8}) \nRETURN path;\n")),(0,r.kt)("h2",{id:"breadth-first-search"},"Breadth-first search"),(0,r.kt)("p",null,"In breadth-first search (BFS) traversal starts from a single node, and the order of\nvisited nodes is decided based on nodes' breadth (distance from the source\nnode). This means that when a certain node is visited, it can be safely assumed\nthat all nodes that are fewer relationships away from the source node have\nalready been visited, resulting in the shortest path from the source node to the\nnewly visited node. "),(0,r.kt)("p",null,"BFS in Memgraph has been implemented based on the relationship expansion syntax.\nThere are a few benefits of the breadth-first expansion approach, instead of\na specialized function. For one, it is possible to inject expressions that\nfilter nodes and relationships along the path itself, not just the final\ndestination node. Furthermore, it's possible to find multiple paths to multiple\ndestination nodes. Also, it is possible to simply go through a node's\nneighborhood in breadth-first manner."),(0,r.kt)("p",null,"Currently, it isn't possible to get all the shortest paths to a single node using\nMemgraph's breadth-first expansion. Below are several examples of how to use the BFS\nin Memgraph."),(0,r.kt)("h3",{id:"getting-various-results-1"},"Getting various results"),(0,r.kt)("p",null,"The following query will show the shortest path between nodes ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"m")," as a\ngraph result."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH path=(n {id: 0})-[*BFS]->(m {id: 8}) \nRETURN path;\n")),(0,r.kt)("p",null,"To get the list of relationships, add a variable before the ",(0,r.kt)("inlineCode",{parentName:"p"},"*BFS")," and return\nit as a result:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (n {id: 0})-[relationships *BFS]->(m {id: 8}) \nRETURN relationships;\n")),(0,r.kt)("p",null,"To get a list of path nodes use the ",(0,r.kt)("inlineCode",{parentName:"p"},"nodes()")," function. You can then return the\nresults as a list, or use the ",(0,r.kt)("inlineCode",{parentName:"p"},"UNWIND")," clause to return individual node\nproperties:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH path=(n {id: 0})-[*BFS]->(m {id: 8}) \nRETURN nodes(path);\n")),(0,r.kt)("h3",{id:"filtering-by-relationships-type-and-direction-1"},"Filtering by relationships type and direction"),(0,r.kt)("p",null,"You can filter relationships by type by defining the type after the relationship\nlist variable, and you decide the direction by adding or removing an arrow from\nthe dash."),(0,r.kt)("p",null,"In the following example, the algorithm will traverse only across ",(0,r.kt)("inlineCode",{parentName:"p"},"CloseTo")," type\nof relationships regardless of the direction:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (n {id: 0})-[relationships:CloseTo *BFS]-(m {id: 8}) \nRETURN relationships;\n")),(0,r.kt)("h3",{id:"constraining-the-paths-length-1"},"Constraining the path's length"),(0,r.kt)("p",null,"The constraints on the path length are defined after the *BFS. The following\nquery will return a result only if the path is equal to or shorter than 5 hops:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (n {id: 0})-[relationships:CloseTo *BFS ..5]->(m {id: 8}) \nRETURN relationships;\n")),(0,r.kt)("p",null,"The result will be returned only if the path is equal to or longer than 3, and\nequal to or shorter than 5 hops:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (n {id: 0})-[relationships:CloseTo *BFS 3..5]-(m {id: 15}) \nRETURN relationships;\n")),(0,r.kt)("h3",{id:"constraining-the-expansion-based-on-property-values-1"},"Constraining the expansion based on property values"),(0,r.kt)("p",null,"Breadth-first expansion allows an arbitrary expression filter that determines if\nan expansion is allowed over a certain relationship to a certain node. The\nfilter is defined as a lambda function over ",(0,r.kt)("inlineCode",{parentName:"p"},"r")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"n"),", which denotes the\nrelationship expanded over and node expanded to in the breadth-first search. "),(0,r.kt)("p",null,"In the following example, expansion is allowed over relationships with an ",(0,r.kt)("inlineCode",{parentName:"p"},"eu_border"),"\nproperty equal to ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," and to nodes with a ",(0,r.kt)("inlineCode",{parentName:"p"},"drinks_USD")," property less than ",(0,r.kt)("inlineCode",{parentName:"p"},"15"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH path=(n {id: 0})-[*BFS (r, n | r.eu_border = false AND n.drinks_USD < 15)]-(m {id: 8}) \nRETURN path;\n")),(0,r.kt)("h2",{id:"weighted-shortest-path"},"Weighted Shortest Path"),(0,r.kt)("p",null,"In graph theory, the weighted shortest path problem is the problem of finding a path\nbetween two nodes in a graph such that the sum of the weights of relationships\nconnecting nodes, or the sum of the weight of some node property on the path, is\nminimized."),(0,r.kt)("p",null,"One of the most important algorithms for finding weighted shortest paths is\n",(0,r.kt)("strong",{parentName:"p"},"Dijkstra's algorithm"),". In Memgraph it has been implemented based on the\nrelationship expansion syntax. In the brackets following the ",(0,r.kt)("inlineCode",{parentName:"p"},"*WSHORTEST"),"\nalgorithm definition, you need to define what relationship or node property\ncarries the weight, for example, ",(0,r.kt)("inlineCode",{parentName:"p"},"[*WSHORTEST (r, n | r.weight)]"),". Below are\nseveral examples of how to use the WSHORTEST in Memgraph."),(0,r.kt)("h3",{id:"getting-various-results-2"},"Getting various results"),(0,r.kt)("p",null,"To find the weighted shortest path between nodes based on the value of the\n",(0,r.kt)("inlineCode",{parentName:"p"},"total_USD")," node property, traversing only across ",(0,r.kt)("inlineCode",{parentName:"p"},"CloseTo")," relationships and\nreturn the result as a graph, use the following query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH path=(n {id: 0})-[:CloseTo *WSHORTEST (r, n | n.total_USD)]-(m {id: 15})\nRETURN path;\n")),(0,r.kt)("p",null,"In the above example, the weight is a property of a node, but you can also\nuse weight of some relationship property:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH path=(n {id: 0})-[:Type *WSHORTEST (r, n | r.weight)]-(m {id: 9})\nRETURN path;\n")),(0,r.kt)("p",null,"To get the list of relationships, add a variable before the ",(0,r.kt)("inlineCode",{parentName:"p"},"*WSHORTEST")," and\nreturn it as a result:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (n {id: 0})-[relationships:CloseTo *WSHORTEST (r, n | n.total_USD)]-(m {id: 9})\nRETURN relationships;\n")),(0,r.kt)("p",null,"To get the path nodes, use the ",(0,r.kt)("inlineCode",{parentName:"p"},"nodes()")," function. You can then return the\nresults as a list, or use the ",(0,r.kt)("inlineCode",{parentName:"p"},"UNWIND")," clause to return individual node\nproperties:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH path=(n {id: 0})-[relationships:CloseTo *WSHORTEST (r, n | n.total_USD)]-(m {id: 9})\nUNWIND (nodes(path)) AS node\nRETURN node.id;\n")),(0,r.kt)("p",null,"To get the total weight, add a variable at the end of the expansion expression: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH path=(n {id: 0})-[relationships:CloseTo *WSHORTEST (r, n | n.total_USD) total_weight]-(m {id: 9})\nRETURN nodes(path), total_weight;\n")),(0,r.kt)("p",null,"Remember that in the case when weight is taken from the node property, the value\nof the last node is not taken into the total weight. "),(0,r.kt)("h3",{id:"filtering-by-relationships-type-and-direction-2"},"Filtering by relationships type and direction"),(0,r.kt)("p",null,"You can filter relationships by type by defining the type after the relationship\nlist variable, and you decide the direction by adding or removing an arrow from\nthe dash."),(0,r.kt)("p",null,"In the following example, the algorithm will traverse only across ",(0,r.kt)("inlineCode",{parentName:"p"},"CloseTo")," type\nof relationships:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH path=(n {id: 0})-[relationships:CloseTo *WSHORTEST (r, n | n.total_USD)]->(m {id: 46})\nRETURN relationships;\n")),(0,r.kt)("h3",{id:"constraining-the-paths-length-2"},"Constraining the path's length"),(0,r.kt)("p",null,"Memgraph's implementation of the Dijkstra's algorithm uses a modified version of\nthis algorithm that can handle length restriction and is based on the relationship\nexpansion syntax. The length restriction parameter is optional, and when it's not\nset, it can increase the complexity of algorithm execution. It is important to note\nthat the term \"length\" in this context denotes the number of traversed\nrelationships and not the sum of their weights."),(0,r.kt)("p",null,"The following example will find the shortest path with a maximum length of 4\nrelationships between nodes ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"m"),". "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH path=(n {id: 0})-[:CloseTo *WSHORTEST 4 (r, n | n.total_USD) total_weight]-(m {id: 46})\nRETURN path,total_weight;\n")),(0,r.kt)("h3",{id:"constraining-the-expansion-based-on-property-values-2"},"Constraining the expansion based on property values"),(0,r.kt)("p",null,"Weighted shortest path expansion allows an arbitrary expression filter that\ndetermines if an expansion is allowed over a certain relationship to a certain\nnode. The filter is defined as a lambda function over ",(0,r.kt)("inlineCode",{parentName:"p"},"r")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"n"),", which denotes\nthe relationship expanded over and node expanded to in finding the weighted shortest path. "),(0,r.kt)("p",null,"In the following example, expansion is allowed over relationships with an ",(0,r.kt)("inlineCode",{parentName:"p"},"eu_border"),"\nproperty equal to ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," and to nodes with a ",(0,r.kt)("inlineCode",{parentName:"p"},"drinks_USD")," property less than ",(0,r.kt)("inlineCode",{parentName:"p"},"15"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH path=(n {id: 0})-[*WSHORTEST (r, n | n.total_USD) total_weight (r, n | r.eu_border = false AND n.drinks_USD < 15)]-(m {id: 46})\nRETURN path,total_weight;\n")))}m.isMDXComponent=!0}}]);