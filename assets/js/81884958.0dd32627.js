"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[85217],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>c});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),m=d(n),c=r,h=m["".concat(s,".").concat(c)]||m[c]||p[c]||i;return n?a.createElement(h,l(l({ref:t},u),{},{components:n})):a.createElement(h,l({ref:t},u))}));function c(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var d=2;d<i;d++)l[d]=n[d];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},38440:(e,t,n)=>{n.r(t),n.d(t,{Highlight:()=>c,assets:()=>p,contentTitle:()=>d,default:()=>g,frontMatter:()=>s,metadata:()=>u,toc:()=>m});var a=n(87462),r=(n(67294),n(3905)),i=n(74866),l=n(85162),o=n(83523);const s={id:"node2vec",title:"node2vec",sidebar_label:"node2vec"},d=void 0,u={unversionedId:"query-modules/python/node2vec",id:"query-modules/python/node2vec",title:"node2vec",description:"The node2vec is a semi-supervised algorithmic framework for learning",source:"@site/mage/query-modules/python/node2vec.md",sourceDirName:"query-modules/python",slug:"/query-modules/python/node2vec",permalink:"/docs/mage/query-modules/python/node2vec",draft:!1,editUrl:"https://github.com/memgraph/docs/tree/master/mage/query-modules/python/node2vec.md",tags:[],version:"current",frontMatter:{id:"node2vec",title:"node2vec",sidebar_label:"node2vec"},sidebar:"mage",previous:{title:"node_classification_with_gnn",permalink:"/docs/mage/query-modules/python/node-classification-with-gnn"},next:{title:"node2vec_online",permalink:"/docs/mage/query-modules/python/node2vec-online"}},p={},m=[{value:"Procedures",id:"procedures",level:2},{value:"<code>get_embeddings( is_directed, p, q, num_walks, walk_length, vector_size, alpha, window, min_count, seed, workers, min_alpha, sg, hs, negative, epochs,)</code>",id:"get_embeddings-is_directed-p-q-num_walks-walk_length-vector_size-alpha-window-min_count-seed-workers-min_alpha-sg-hs-negative-epochs",level:3},{value:"Input:",id:"input",level:4},{value:"Output:",id:"output",level:4},{value:"Usage:",id:"usage",level:4},{value:"<code>set_embeddings( is_directed, p, q, num_walks, walk_length, vector_size, alpha, window, min_count, seed, workers, min_alpha, sg, hs, negative, epochs,)</code>",id:"set_embeddings-is_directed-p-q-num_walks-walk_length-vector_size-alpha-window-min_count-seed-workers-min_alpha-sg-hs-negative-epochs",level:3},{value:"Input:",id:"input-1",level:4},{value:"Output:",id:"output-1",level:4},{value:"Usage:",id:"usage-1",level:4},{value:"<code>help()</code>",id:"help",level:3},{value:"Output:",id:"output-2",level:4},{value:"Usage:",id:"usage-2",level:4},{value:"Example",id:"example",level:2}],c=e=>{let{children:t,color:n}=e;return(0,r.kt)("span",{style:{backgroundColor:n,borderRadius:"2px",color:"#fff",padding:"0.2rem"}},t)},h={toc:m,Highlight:c};function g(e){let{components:t,...s}=e;return(0,r.kt)("wrapper",(0,a.Z)({},h,s,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The ",(0,r.kt)("strong",{parentName:"p"},"node2vec")," is a semi-supervised algorithmic framework for learning\ncontinuous feature representations for nodes in networks. The algorithm\ngenerates a mapping of nodes to a low-dimensional space of features that\nmaximizes the likelihood of preserving network neighborhoods of nodes. By using\na biased random walk procedure, it enables exploring diverse neighborhoods. In\ntasks such as multi-label classification and link prediction, node2vec shows\ngreat results."),(0,r.kt)("p",null,"The ",(0,r.kt)("strong",{parentName:"p"},"node2vec")," algorithm was inspired by a similar ",(0,r.kt)("strong",{parentName:"p"},"NLP")," technique. The same\nway as a document is an ordered sequence of words, by sampling sequences of\nnodes from the underlying network and turning a network into an ordered sequence\nof nodes. Although the idea of sampling is easy, choosing the actual strategy\ncan be challenging and dependant on the techniques that will be applied\nafterward."),(0,r.kt)("p",null,"Capturing information in networks often shuttles between two kinds of\nsimilarities: ",(0,r.kt)("strong",{parentName:"p"},"homophily")," and ",(0,r.kt)("strong",{parentName:"p"},"structural equivalence"),". Under the\n",(0,r.kt)("strong",{parentName:"p"},"homophily")," hypothesis, nodes that are highly interconnected and belong to\nsimilar network clusters or communities should be embedded closely together. In\ncontrast, under the ",(0,r.kt)("strong",{parentName:"p"},"structural equivalence")," hypothesis, nodes that have\nsimilar structural roles in networks should be embedded closely together (e.g.,\nnodes that act as hubs of their corresponding communities)."),(0,r.kt)("p",null,"The current implementation easily captures ",(0,r.kt)("strong",{parentName:"p"},"homophily")," or ",(0,r.kt)("strong",{parentName:"p"},"structural\nequivalence")," by changing hyperparameters."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"BFS")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"DFS")," strategies play a key role in producing representations that\nreflect either of the above equivalences. The neighborhoods sampled by ",(0,r.kt)("inlineCode",{parentName:"p"},"BFS"),"\nlead to embeddings that correspond closely to structural equivalence. The\nopposite is true for ",(0,r.kt)("inlineCode",{parentName:"p"},"DFS"),". It can explore larger parts of the network as it\ncan move further away from the source node. Therefore, ",(0,r.kt)("inlineCode",{parentName:"p"},"DFS")," sampled walks\naccurately reflect a macro-view of the neighborhood, which is essential in\ninferring communities based on homophily."),(0,r.kt)("p",null,"By having different parameters:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"return parameter ",(0,r.kt)("inlineCode",{parentName:"strong"},"p"))),(0,r.kt)("li",{parentName:"ul"},"and ",(0,r.kt)("strong",{parentName:"li"},"in-out parameter",(0,r.kt)("inlineCode",{parentName:"strong"},"q")))),(0,r.kt)("p",null,"one decides whether to prioritize the ",(0,r.kt)("inlineCode",{parentName:"p"},"BFS")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"DFS")," strategy when sampling. If\n",(0,r.kt)("inlineCode",{parentName:"p"},"p")," is smaller than 1, then we create more ",(0,r.kt)("inlineCode",{parentName:"p"},"BFS")," like walks and we capture more\n",(0,r.kt)("strong",{parentName:"p"},"structural equivalence"),". The opposite is true if ",(0,r.kt)("inlineCode",{parentName:"p"},"q")," is smaller than 1. Then we\ncapture ",(0,r.kt)("inlineCode",{parentName:"p"},"DFS")," like walks and ",(0,r.kt)("strong",{parentName:"p"},"homophily"),"."),(0,r.kt)("p",null,(0,r.kt)("sup",{parentName:"p",id:"fnref-1"},(0,r.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1"))," ",(0,r.kt)("a",{parentName:"p",href:"https://arxiv.org/abs/1607.00653"},"Scalable Feature Learning for Networks"),",\nA. Grover, J. Leskovec"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/memgraph/mage/blob/main/python/node2vec.py"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/badge/source-node2vec-FB6E00?logo=github&style=for-the-badge",alt:"docs-source"}))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Trait"),(0,r.kt)("th",{parentName:"tr",align:null},"Value"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Module type")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)(c,{color:"#FB6E00",mdxType:"Highlight"},(0,r.kt)("strong",{parentName:"td"},"module")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Implementation")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)(c,{color:"#FB6E00",mdxType:"Highlight"},(0,r.kt)("strong",{parentName:"td"},"Python")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Graph direction")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)(c,{color:"#FB6E00",mdxType:"Highlight"},(0,r.kt)("strong",{parentName:"td"},"directed/undirected")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Edge weights")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)(c,{color:"#FB6E00",mdxType:"Highlight"},(0,r.kt)("strong",{parentName:"td"},"weighted/unweighted")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Parallelism")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)(c,{color:"#FB6E00",mdxType:"Highlight"},(0,r.kt)("strong",{parentName:"td"},"sequential")))))),(0,r.kt)("admonition",{title:"Too slow?",type:"note"},(0,r.kt)("p",{parentName:"admonition"},"If this algorithm implementation is too slow for your use case, ",(0,r.kt)("a",{parentName:"p",href:"mailto:tech@memgraph.com"},"contact us")," and request a rewrite to C++ !")),(0,r.kt)("h2",{id:"procedures"},"Procedures"),(0,r.kt)(o.ZP,{mdxType:"RunOnSubgraph"}),(0,r.kt)("h3",{id:"get_embeddings-is_directed-p-q-num_walks-walk_length-vector_size-alpha-window-min_count-seed-workers-min_alpha-sg-hs-negative-epochs"},(0,r.kt)("inlineCode",{parentName:"h3"},"get_embeddings( is_directed, p, q, num_walks, walk_length, vector_size, alpha, window, min_count, seed, workers, min_alpha, sg, hs, negative, epochs,)")),(0,r.kt)("h4",{id:"input"},"Input:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"is_directed : boolean")," \u27a1 If ",(0,r.kt)("inlineCode",{parentName:"li"},"True"),", graph is treated as directed, else not\ndirected"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"p : float")," \u27a1 Return hyperparameter for calculating transition probabilities."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"q : float")," \u27a1 In-out hyperparameter for calculating transition probabilities."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"num_walks : integer")," \u27a1 Number of walks per node in walk sampling."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"walk_length : integer")," \u27a1 Length of one walk in walk sampling."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"vector_size : integer")," \u27a1 Dimensionality of the word vectors."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"window : integer")," \u27a1 Maximum distance between the current and predicted word\nwithin a sentence."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"min_count : integer")," \u27a1 Ignores all words with total frequency lower than this."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"workers : integer")," \u27a1 Use these many worker threads to train the model (=faster\ntraining with multicore machines)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"sg : {0, 1}")," \u27a1 Training algorithm: 1 for skip-gram; otherwise CBOW."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"hs : {0, 1}")," \u27a1 If 1, hierarchical softmax will be used for model training. If\n0, and ",(0,r.kt)("inlineCode",{parentName:"li"},"negative")," is non-zero, negative sampling will be used."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"negative : integer"),' \u27a1 If > 0, negative sampling will be used, the integer for\nnegative specifies how many "noise words" should be drawn (usually\nbetween 5-20). If set to 0, no negative sampling is used.'),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"cbow_mean : {0, 1}")," \u27a1 If 0, use the sum of the context word vectors. If 1,\nuse the mean, only applies when cbow is used."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"alpha : float")," \u27a1 The initial learning rate."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"min_alpha : float")," \u27a1 Learning rate will linearly drop to ",(0,r.kt)("inlineCode",{parentName:"li"},"min_alpha")," as\ntraining progresses."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"seed : integer")," \u27a1 Seed for the random number generator. Initial vectors for each\nword are seeded with a hash of the concatenation of word + ",(0,r.kt)("inlineCode",{parentName:"li"},"str(seed)"),".")),(0,r.kt)("h4",{id:"output"},"Output:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"nodes: mgp.List[mgp.Vertex]")," \u27a1 List of nodes for which embeddings were\ncalculated"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"embeddings: mgp.List[mgp.List[mgp.Number]])")," \u27a1 Corresponding list of\nembeddings")),(0,r.kt)("h4",{id:"usage"},"Usage:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL node2vec_online.get_embeddings(False, 2.0, 0.5, 4, 5, 100, 0.025, 5, 1, 1, 1, 0.0001, 1, 0, 5, 5);\n")),(0,r.kt)("h3",{id:"set_embeddings-is_directed-p-q-num_walks-walk_length-vector_size-alpha-window-min_count-seed-workers-min_alpha-sg-hs-negative-epochs"},(0,r.kt)("inlineCode",{parentName:"h3"},"set_embeddings( is_directed, p, q, num_walks, walk_length, vector_size, alpha, window, min_count, seed, workers, min_alpha, sg, hs, negative, epochs,)")),(0,r.kt)("h4",{id:"input-1"},"Input:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"is_directed : boolean")," \u27a1 If ",(0,r.kt)("inlineCode",{parentName:"li"},"True"),", graph is treated as directed, else not\ndirected"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"p : float")," \u27a1 Return hyperparameter for calculating transition probabilities."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"q : float")," \u27a1 In-out hyperparameter for calculating transition probabilities."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"num_walks : integer")," \u27a1 Number of walks per node in walk sampling."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"walk_length : integer")," \u27a1 Length of one walk in walk sampling."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"vector_size : integer")," \u27a1 Dimensionality of the word vectors."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"window : integer")," \u27a1 Maximum distance between the current and predicted word\nwithin a sentence."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"min_count : integer")," \u27a1 Ignores all words with total frequency lower than this."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"workers : integer")," \u27a1 Use these many worker threads to train the model (=faster\ntraining with multicore machines)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"sg : {0, 1}")," \u27a1 Training algorithm: 1 for skip-gram; otherwise CBOW."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"hs : {0, 1}")," \u27a1 If 1, hierarchical softmax will be used for model training. If\n0, and ",(0,r.kt)("inlineCode",{parentName:"li"},"negative")," is non-zero, negative sampling will be used."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"negative : integer"),' \u27a1 If > 0, negative sampling will be used, the int for\nnegative specifies how many "noise words" should be drawn (usually\nbetween 5-20). If set to 0, no negative sampling is used.'),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"cbow_mean : {0, 1}")," \u27a1 If 0, use the sum of the context word vectors. If 1,\nuse the mean, only applies when cbow is used."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"alpha : float")," \u27a1 The initial learning rate."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"min_alpha : float")," \u27a1 Learning rate will linearly drop to ",(0,r.kt)("inlineCode",{parentName:"li"},"min_alpha")," as\ntraining progresses."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"seed : integer")," \u27a1 Seed for the random number generator. Initial vectors for each\nword are seeded with a hash of the concatenation of word + ",(0,r.kt)("inlineCode",{parentName:"li"},"str(seed)"),".")),(0,r.kt)("h4",{id:"output-1"},"Output:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"nodes: mgp.List[mgp.Vertex]")," \u27a1 List of nodes for which embeddings were\ncalculated"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"embeddings: mgp.List[mgp.List[mgp.Number]])")," \u27a1 Corresponding list of\nembeddings")),(0,r.kt)("h4",{id:"usage-1"},"Usage:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL node2vec_online.get_embeddings(False, 2.0, 0.5, 4, 5, 100, 0.025, 5, 1, 1, 1, 0.0001, 1, 0, 5, 5);\n")),(0,r.kt)("h3",{id:"help"},(0,r.kt)("inlineCode",{parentName:"h3"},"help()")),(0,r.kt)("h4",{id:"output-2"},"Output:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"name: string")," \u27a1 Name of available functions"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"value: string")," \u27a1 Documentation for every function")),(0,r.kt)("h4",{id:"usage-2"},"Usage:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL node2vec_online.help();\n")),(0,r.kt)("h2",{id:"example"},"Example"),(0,r.kt)(i.Z,{groupId:"example",defaultValue:"visualization",values:[{label:"Step 1: Input graph",value:"visualization"},{label:"Step 2: Load commands",value:"cypher-load"},{label:"Step 3: Set embeddings",value:"set-embeddings"},{label:"Step 4: Running command",value:"run"},{label:"Step 5: Results",value:"result"}],mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"visualization",mdxType:"TabItem"},(0,r.kt)("img",{src:n(72700).Z})),(0,r.kt)(l.Z,{value:"cypher-load",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"MERGE (n:Node {id: 1}) MERGE (m:Node {id: 6}) CREATE (n)-[:RELATION]->(m);\nMERGE (n:Node {id: 2}) MERGE (m:Node {id: 6}) CREATE (n)-[:RELATION]->(m);\nMERGE (n:Node {id: 10}) MERGE (m:Node {id: 5}) CREATE (n)-[:RELATION]->(m);\nMERGE (n:Node {id: 5}) MERGE (m:Node {id: 2}) CREATE (n)-[:RELATION]->(m);\n\nMERGE (n:Node {id: 9}) MERGE (m:Node {id: 7}) CREATE (n)-[:RELATION]->(m);\nMERGE (n:Node {id: 7}) MERGE (m:Node {id: 3}) CREATE (n)-[:RELATION]->(m);\nMERGE (n:Node {id: 3}) MERGE (m:Node {id: 6}) CREATE (n)-[:RELATION]->(m);\n\nMERGE (n:Node {id: 9}) MERGE (m:Node {id: 8}) CREATE (n)-[:RELATION]->(m);\nMERGE (n:Node {id: 8}) MERGE (m:Node {id: 4}) CREATE (n)-[:RELATION]->(m);\nMERGE (n:Node {id: 4}) MERGE (m:Node {id: 6}) CREATE (n)-[:RELATION]->(m);\n"))),(0,r.kt)(l.Z,{value:"set-embeddings",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL node2vec.set_embeddings(False, 2.0, 0.5, 4, 5, 2) YIELD *;\n"))),(0,r.kt)(l.Z,{value:"run",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (n)\nRETURN n.id as node, n.embedding as embedding\nORDER BY n.id;\n"))),(0,r.kt)(l.Z,{value:"result",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-plaintext"},"+-------------------------+-------------------------+\n| node                    | embedding               |\n+-------------------------+-------------------------+\n| 1                       | [-0.243723, -0.0916009] |\n| 2                       | [0.25442, 0.449585]     |\n| 3                       | [0.322331, 0.448404]    |\n| 4                       | [0.143389, 0.0492275]   |\n| 5                       | [-0.465552, -0.35653]   |\n| 6                       | [-0.0272922, 0.0111898] |\n| 7                       | [0.368725, -0.0773199]  |\n| 8                       | [-0.414683, -0.472285]  |\n| 9                       | [-0.226683, 0.328159]   |\n| 10                      | [-0.251244, -0.189218]  |\n+-------------------------+-------------------------+\n")))))}g.isMDXComponent=!0},83523:(e,t,n)=>{n.d(t,{ZP:()=>l});var a=n(87462),r=(n(67294),n(3905));const i={toc:[]};function l(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},i,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"If you want to execute this algorithm on graph projections, subgraphs or portions\nof the graph, be sure to check out the guide on\n",(0,r.kt)("a",{parentName:"p",href:"/mage/how-to-guides/run-a-subgraph-module"},"How to run a MAGE module on subgraphs"),".")))}l.isMDXComponent=!0},85162:(e,t,n)=>{n.d(t,{Z:()=>l});var a=n(67294),r=n(86010);const i="tabItem_Ymn6";function l(e){let{children:t,hidden:n,className:l}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(i,l),hidden:n},t)}},74866:(e,t,n)=>{n.d(t,{Z:()=>y});var a=n(87462),r=n(67294),i=n(86010),l=n(12466),o=n(16550),s=n(91980),d=n(67392),u=n(50012);function p(e){return function(e){return r.Children.map(e,(e=>{if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:r}}=e;return{value:t,label:n,attributes:a,default:r}}))}function m(e){const{values:t,children:n}=e;return(0,r.useMemo)((()=>{const e=t??p(n);return function(e){const t=(0,d.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function c(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function h(e){let{queryString:t=!1,groupId:n}=e;const a=(0,o.k6)(),i=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,s._X)(i),(0,r.useCallback)((e=>{if(!i)return;const t=new URLSearchParams(a.location.search);t.set(i,e),a.replace({...a.location,search:t.toString()})}),[i,a])]}function g(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,i=m(e),[l,o]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!c({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:i}))),[s,d]=h({queryString:n,groupId:a}),[p,g]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,i]=(0,u.Nk)(n);return[a,(0,r.useCallback)((e=>{n&&i.set(e)}),[n,i])]}({groupId:a}),k=(()=>{const e=s??p;return c({value:e,tabValues:i})?e:null})();(0,r.useLayoutEffect)((()=>{k&&o(k)}),[k]);return{selectedValue:l,selectValue:(0,r.useCallback)((e=>{if(!c({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);o(e),d(e),g(e)}),[d,g,i]),tabValues:i}}var k=n(72389);const f="tabList__CuJ",N="tabItem_LNqP";function b(e){let{className:t,block:n,selectedValue:o,selectValue:s,tabValues:d}=e;const u=[],{blockElementScrollPositionUntilNextRender:p}=(0,l.o5)(),m=e=>{const t=e.currentTarget,n=u.indexOf(t),a=d[n].value;a!==o&&(p(t),s(a))},c=e=>{var t;let n=null;switch(e.key){case"Enter":m(e);break;case"ArrowRight":{const t=u.indexOf(e.currentTarget)+1;n=u[t]??u[0];break}case"ArrowLeft":{const t=u.indexOf(e.currentTarget)-1;n=u[t]??u[u.length-1];break}}null==(t=n)||t.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":n},t)},d.map((e=>{let{value:t,label:n,attributes:l}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:o===t?0:-1,"aria-selected":o===t,key:t,ref:e=>u.push(e),onKeyDown:c,onClick:m},l,{className:(0,i.Z)("tabs__item",N,null==l?void 0:l.className,{"tabs__item--active":o===t})}),n??t)})))}function w(e){let{lazy:t,children:n,selectedValue:a}=e;if(n=Array.isArray(n)?n:[n],t){const e=n.find((e=>e.props.value===a));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},n.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function v(e){const t=g(e);return r.createElement("div",{className:(0,i.Z)("tabs-container",f)},r.createElement(b,(0,a.Z)({},e,t)),r.createElement(w,(0,a.Z)({},e,t)))}function y(e){const t=(0,k.Z)();return r.createElement(v,(0,a.Z)({key:String(t)},e))}},72700:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/node2vec-2638f0e20136a1f858affb1be4013687.png"}}]);