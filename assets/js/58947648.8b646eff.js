"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[47103],{3905:(e,t,r)=>{r.d(t,{Zo:()=>c,kt:()=>u});var n=r(67294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function l(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?l(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):l(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},l=Object.keys(e);for(n=0;n<l.length;n++)r=l[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)r=l[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var s=n.createContext({}),p=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},c=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,l=e.originalType,s=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),m=p(r),u=a,h=m["".concat(s,".").concat(u)]||m[u]||d[u]||l;return r?n.createElement(h,o(o({ref:t},c),{},{components:r})):n.createElement(h,o({ref:t},c))}));function u(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=r.length,o=new Array(l);o[0]=m;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:a,o[1]=i;for(var p=2;p<l;p++)o[p]=r[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}m.displayName="MDXCreateElement"},68871:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>l,metadata:()=>i,toc:()=>p});var n=r(87462),a=(r(67294),r(3905));const l={sidebar_label:"nx_translator",title:"gqlalchemy.transformations.translators.nx_translator"},o=void 0,i={unversionedId:"reference/transformations/translators/nx_translator",id:"reference/transformations/translators/nx_translator",title:"gqlalchemy.transformations.translators.nx_translator",description:"Translates data from Memgraph to NX graph and vice-versa.",source:"@site/gqlalchemy/reference/transformations/translators/nx_translator.md",sourceDirName:"reference/transformations/translators",slug:"/reference/transformations/translators/nx_translator",permalink:"/docs/gqlalchemy/reference/transformations/translators/nx_translator",draft:!1,editUrl:"https://github.com/memgraph/docs/tree/master/gqlalchemy/reference/transformations/translators/nx_translator.md",tags:[],version:"current",frontMatter:{sidebar_label:"nx_translator",title:"gqlalchemy.transformations.translators.nx_translator"},sidebar:"gqlalchemy",previous:{title:"pyg_translator",permalink:"/docs/gqlalchemy/reference/transformations/translators/pyg_translator"},next:{title:"utilities",permalink:"/docs/gqlalchemy/reference/utilities"}},s={},p=[{value:"Methods",id:"methods",level:3},{value:"<code>__init__</code>",id:"__init__",level:4},{value:"Input",id:"input",level:5},{value:"<code>to_cypher_queries</code>",id:"to_cypher_queries",level:4},{value:"Input",id:"input-1",level:5},{value:"Example",id:"example",level:4},{value:"nx_graph_to_memgraph_parallel",id:"nx_graph_to_memgraph_parallel",level:4},{value:"<code>get_instance</code>",id:"get_instance",level:4},{value:"Example",id:"example-1",level:4},{value:"NetworkXCypherBuilder Objects",id:"networkxcypherbuilder-objects",level:2},{value:"yield_queries",id:"yield_queries",level:4},{value:"yield_query_groups",id:"yield_query_groups",level:4}],c={toc:p};function d(e){let{components:t,...r}=e;return(0,a.kt)("wrapper",(0,n.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Translates data from Memgraph to NX graph and vice-versa.\nUses original IDs from Memgraph. Labels are encoded as properties. Since Networkx allows nodes to have properties of different dimensionality, this module stores properties as dictionary entries. All properties are saved to the NetworkX data structure."),(0,a.kt)("h3",{id:"methods"},"Methods"),(0,a.kt)("h4",{id:"__init__"},(0,a.kt)("inlineCode",{parentName:"h4"},"__init__")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'def __init__(self, \n    default_node_label="NODE",\n    default_edge_type="RELATIONSHIP",\n    host: str = mg_consts.MG_HOST,\n    port: int = mg_consts.MG_PORT,\n    username: str = mg_consts.MG_USERNAME,\n    password: str = mg_consts.MG_PASSWORD,\n    encrypted: bool = mg_consts.MG_ENCRYPTED,\n    client_name: str = mg_consts.MG_CLIENT_NAME,\n    lazy: bool = mg_consts.MG_LAZY,\n    ) -> None\n')),(0,a.kt)("p",null,"Initializes translator object with given parameters."),(0,a.kt)("h5",{id:"input"},"Input"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"default_node_label: str=NODE")," -> Default node label that will be given to nodes when no other can be inferred."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"default_edge_type: str=RELATIONSHIP")," -> Default edge type that will be given to edges when no other can be inferred."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"host: str=127.0.0.1")," -> Host connection info for connecting to the Memgraph instance."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"port: int=7687")," -> Port connection info for connecting to the Memgraph instance."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},'username: str=""')," -> Username connection info for connecting to the Memgraph instance."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},'password: str=""')," -> Password connection info for connecting to the Memgraph instance."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"encrypted: bool=False")," -> Encrypted flag for connecting to the Memgraph instance."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"client_name: str=GQLAlchemy")," -> Client name used for connecting to the Memgraph instance."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"lazy: bool=False")," -> Lazy flag for connecting to the Memgraph instance.")),(0,a.kt)("h4",{id:"to_cypher_queries"},(0,a.kt)("inlineCode",{parentName:"h4"},"to_cypher_queries")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def to_cypher_queries(self, graph) -> None\n")),(0,a.kt)("p",null,"Generates Cypher queries from a given NetworkX graph."),(0,a.kt)("h5",{id:"input-1"},"Input"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"graph")," -> ",(0,a.kt)("inlineCode",{parentName:"li"},"NetworkX")," graph representation.")),(0,a.kt)("h4",{id:"example"},"Example"),(0,a.kt)("p",null,"Use the following query to transfer ",(0,a.kt)("inlineCode",{parentName:"p"},"NxGraph")," to Cypher queries and execute them in Memgraph:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"memgraph = Memgraph()\nnx_graph = NxGraph(...)\nfor query in NxTranslator().to_cypher_queries(nx_graph):\n    memgraph.execute(query)\n")),(0,a.kt)("h4",{id:"nx_graph_to_memgraph_parallel"},"nx","_","graph","_","to","_","memgraph","_","parallel"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'def nx_graph_to_memgraph_parallel(graph: nx.Graph, host: str = "127.0.0.1", port: int = 7687, username: str = "", password: str = "", encrypted: bool = False, config: NetworkXCypherConfig = None) -> None\n')),(0,a.kt)("p",null,"Generates Cypher queries and inserts data into Memgraph in parallel."),(0,a.kt)("h4",{id:"get_instance"},(0,a.kt)("inlineCode",{parentName:"h4"},"get_instance")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def get_instance(self) -> dgl.DGLHeteroGraph\n")),(0,a.kt)("p",null,"Creates a ",(0,a.kt)("inlineCode",{parentName:"p"},"NetworkX")," instance of the graph from the data residing inside Memgraph. Since ",(0,a.kt)("inlineCode",{parentName:"p"},"NetworkX")," doesn't support labels as Memgraph does, labels are encoded as node and edge properties. All nodes and relationships are transferred, even if they are not connected with any other node (they're isolated)."),(0,a.kt)("h4",{id:"example-1"},"Example"),(0,a.kt)("p",null,"Use the following block of code to create an instance of the ",(0,a.kt)("inlineCode",{parentName:"p"},"NetworkX")," graph from the data residing inside ",(0,a.kt)("inlineCode",{parentName:"p"},"Memgraph"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"nx_translator = NxTranslator()\nnx_graph = nx_translator.get_instance()\n")),(0,a.kt)("h2",{id:"networkxcypherbuilder-objects"},"NetworkXCypherBuilder Objects"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"class NetworkXCypherBuilder()\n")),(0,a.kt)("h4",{id:"yield_queries"},"yield","_","queries"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def yield_queries(graph: nx.Graph) -> Iterator[str]\n")),(0,a.kt)("p",null,"Generates Cypher queries for creating a graph."),(0,a.kt)("h4",{id:"yield_query_groups"},"yield","_","query","_","groups"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def yield_query_groups(graph: nx.Graph) -> List[Iterator[str]]\n")),(0,a.kt)("p",null,"Generates Cypher queries that can be used to create a graph by query groups."))}d.isMDXComponent=!0}}]);