"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[19953],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>h});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=r.createContext({}),s=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=s(e.components);return r.createElement(p.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,p=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),d=s(n),h=a,u=d["".concat(p,".").concat(h)]||d[h]||c[h]||o;return n?r.createElement(u,i(i({ref:t},m),{},{components:n})):r.createElement(u,i({ref:t},m))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=d;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var s=2;s<o;s++)i[s]=n[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},52397:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var r=n(87462),a=(n(67294),n(3905));const o={sidebar_label:"import",title:"gqlalchemy.transformations.importing.import"},i=void 0,l={unversionedId:"reference/transformations/importing/import",id:"reference/transformations/importing/import",title:"gqlalchemy.transformations.importing.import",description:"GQLAlchemy supports importing data from various sources. This includes importing from graph objects stored in NetworkX, DGL and PyG format or various other table sources like S3 or Azure Blob storage. Files stored in the local file system can be in CSV, Parquet, ORC or Feather format. GQLAlchemy will parse the data and import it into the Memgraph database.",source:"@site/gqlalchemy/reference/transformations/importing/import.md",sourceDirName:"reference/transformations/importing",slug:"/reference/transformations/importing/import",permalink:"/docs/gqlalchemy/reference/transformations/importing/import",draft:!1,editUrl:"https://github.com/memgraph/docs/tree/master/gqlalchemy/reference/transformations/importing/import.md",tags:[],version:"current",frontMatter:{sidebar_label:"import",title:"gqlalchemy.transformations.importing.import"},sidebar:"gqlalchemy",previous:{title:"export",permalink:"/docs/gqlalchemy/reference/transformations/export"},next:{title:"loaders",permalink:"/docs/gqlalchemy/reference/transformations/importing/loaders"}},p={},s=[{value:"Importer",id:"importer",level:2},{value:"GraphImporter",id:"graphimporter",level:2},{value:"Methods",id:"methods",level:3},{value:"<code>__init__</code>",id:"__init__",level:4},{value:"Input",id:"input",level:5},{value:"<code>translate</code>",id:"translate",level:4},{value:"Input",id:"input-1",level:5},{value:"Example",id:"example",level:3},{value:"TableToGraphImporter",id:"tabletographimporter",level:2},{value:"Methods",id:"methods-1",level:3},{value:"<code>__init__</code>",id:"__init__-1",level:4},{value:"<code>translate</code>",id:"translate-1",level:4},{value:"Input",id:"input-2",level:5}],m={toc:s};function c(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"GQLAlchemy supports importing data from various sources. This includes importing from graph objects stored in NetworkX, DGL and PyG format or various other table sources like S3 or Azure Blob storage. Files stored in the local file system can be in CSV, Parquet, ORC or Feather format. GQLAlchemy will parse the data and import it into the Memgraph database."),(0,a.kt)("h2",{id:"importer"},"Importer"),(0,a.kt)("p",null,"An abstract importer that doesn't implement any strategy for translating a graph but provides an interface that other objects can implement. Each ",(0,a.kt)("inlineCode",{parentName:"p"},"Importer")," has a reference to the specific translator object, which is used for translating a graph of a specific type into Memgraph data. This translator does all the dirty work, so check out docs about ",(0,a.kt)("a",{parentName:"p",href:"/docs/gqlalchemy/reference/transformations/translators/dgl_translator"},(0,a.kt)("inlineCode",{parentName:"a"},"DGLTranslator")),", ",(0,a.kt)("a",{parentName:"p",href:"/docs/gqlalchemy/reference/transformations/translators/pyg_translator"},(0,a.kt)("inlineCode",{parentName:"a"},"PyGTranslator"))," and ",(0,a.kt)("a",{parentName:"p",href:"/docs/gqlalchemy/reference/transformations/translators/nx_translator"},(0,a.kt)("inlineCode",{parentName:"a"},"NxTranslator"))," to find out implementation details."),(0,a.kt)("h2",{id:"graphimporter"},"GraphImporter"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"GraphImporter")," is one such object that implements ",(0,a.kt)("inlineCode",{parentName:"p"},"Importer"),". It is used an entry class which creates correct translator object, translated input graph to cypher queries and inserts them into the database. Currently supported formats to import from are ",(0,a.kt)("inlineCode",{parentName:"p"},"NetworkX"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"DGL")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"PyG"),"."),(0,a.kt)("h3",{id:"methods"},"Methods"),(0,a.kt)("h4",{id:"__init__"},(0,a.kt)("inlineCode",{parentName:"h4"},"__init__")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'def __init__(self, \n    graph_type: str, \n    default_node_label="NODE",\n    default_edge_type="RELATIONSHIP",\n    host: str = mg_consts.MG_HOST,\n    port: int = mg_consts.MG_PORT,\n    username: str = mg_consts.MG_USERNAME,\n    password: str = mg_consts.MG_PASSWORD,\n    encrypted: bool = mg_consts.MG_ENCRYPTED,\n    client_name: str = mg_consts.MG_CLIENT_NAME,\n    lazy: bool = mg_consts.MG_LAZY,\n    ) -> None\n')),(0,a.kt)("p",null,"Creates neccessary translator object based on a graph type provided."),(0,a.kt)("h5",{id:"input"},"Input"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"graph_type: str")," -> Graph source type object. Can be one of the following: ","[",(0,a.kt)("inlineCode",{parentName:"li"},"DGL"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"NX"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"PYG"),"]"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"default_node_label: str=NODE")," -> Default node label that will be given to nodes when no other can be inferred."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"default_edge_type: str=RELATIONSHIP")," -> Default edge type that will be given to edges when no other can be inferred."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"host: str=127.0.0.1")," -> Host connection info for connecting to the Memgraph instance."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"port: int=7687")," -> Port connection info for connecting to the Memgraph instance."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},'username: str=""')," -> Username connection info for connecting to the Memgraph instance."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},'password: str=""')," -> Password connection info for connecting to the Memgraph instance."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"encrypted: bool=False")," -> Encrypted flag for connecting to the Memgraph instance."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"client_name: str=GQLAlchemy")," -> Client name used for connecting to the Memgraph instance."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"lazy: bool=False")," -> Lazy flag for connecting to the Memgraph instance.")),(0,a.kt)("h4",{id:"translate"},(0,a.kt)("inlineCode",{parentName:"h4"},"translate")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def translate(self, graph) -> None\n")),(0,a.kt)("p",null,"Collects Cypher queries using the underlying translator and inserts them into Memgraph DB."),(0,a.kt)("h5",{id:"input-1"},"Input"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"graph")," -> ",(0,a.kt)("inlineCode",{parentName:"li"},"DGL"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"PyG")," or ",(0,a.kt)("inlineCode",{parentName:"li"},"NX")," graph instance.")),(0,a.kt)("h3",{id:"example"},"Example"),(0,a.kt)("p",null,"The following code can be used to transfer data from DGL graph into Memgraph DB."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'importer = GraphImporter("dgl")\ngraph = DGLGraph(...) # create instance of the DGL graph\nimporter.translate(graph)  # in this step, queries are inserted into the Memgraph database\n')),(0,a.kt)("h2",{id:"tabletographimporter"},"TableToGraphImporter"),(0,a.kt)("p",null,"Implements a translation of table data to graph data and imports it to Memgraph."),(0,a.kt)("h3",{id:"methods-1"},"Methods"),(0,a.kt)("h4",{id:"__init__-1"},(0,a.kt)("inlineCode",{parentName:"h4"},"__init__")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def __init__(self,\n    data_loader: DataLoader,\n    data_configuration: Dict[str, Any],\n    memgraph: Optional[Memgraph] = None)\n")),(0,a.kt)("p",null,"Loads the configuration from the ",(0,a.kt)("inlineCode",{parentName:"p"},"data_configuration")," and saves references to the ",(0,a.kt)("inlineCode",{parentName:"p"},"data_loader")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"memgraph"),"."),(0,a.kt)("h4",{id:"translate-1"},(0,a.kt)("inlineCode",{parentName:"h4"},"translate")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def translate(self, drop_database_on_start: bool = True) -> None\n")),(0,a.kt)("p",null,"Performs the translation between the table data source and Memgraph database. The method uses indexes and triggers to speed up the translation process."),(0,a.kt)("h5",{id:"input-2"},"Input"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"drop_database_on_start: bool = True")," -> Indicate whether or not the database should be dropped prior to the start of the translations.")))}c.isMDXComponent=!0}}]);