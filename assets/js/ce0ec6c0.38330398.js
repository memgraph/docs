"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[23385],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>c});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=r.createContext({}),u=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=u(e.components);return r.createElement(p.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},s=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,p=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),s=u(n),c=o,h=s["".concat(p,".").concat(c)]||s[c]||d[c]||a;return n?r.createElement(h,i(i({ref:t},m),{},{components:n})):r.createElement(h,i({ref:t},m))}));function c(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=s;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var u=2;u<a;u++)i[u]=n[u];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}s.displayName="MDXCreateElement"},31757:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>l,toc:()=>u});var r=n(87462),o=(n(67294),n(3905));const a={id:"create-a-new-module-cpp",title:"How to create a query module in C++",sidebar_label:"Create a C++ query module"},i=void 0,l={unversionedId:"how-to-guides/create-a-new-module-cpp",id:"how-to-guides/create-a-new-module-cpp",title:"How to create a query module in C++",description:"Query modules can be implemented using the [C++",source:"@site/mage/how-to-guides/create-a-new-module-cpp.md",sourceDirName:"how-to-guides",slug:"/how-to-guides/create-a-new-module-cpp",permalink:"/docs/mage/how-to-guides/create-a-new-module-cpp",draft:!1,editUrl:"https://github.com/memgraph/docs/tree/master/mage/how-to-guides/create-a-new-module-cpp.md",tags:[],version:"current",frontMatter:{id:"create-a-new-module-cpp",title:"How to create a query module in C++",sidebar_label:"Create a C++ query module"},sidebar:"mage",previous:{title:"Create a Python query module",permalink:"/docs/mage/how-to-guides/create-a-new-module-python"},next:{title:"Run a query module",permalink:"/docs/mage/how-to-guides/run-a-query-module"}},p={},u=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Developing a module",id:"developing-a-module",level:2},{value:"Main algorithm",id:"main-algorithm",level:3},{value:"Initialization of the module",id:"initialization-of-the-module",level:3},{value:"Shutdown of the module",id:"shutdown-of-the-module",level:3},{value:"Terminate procedure execution",id:"terminate-procedure-execution",level:3},{value:"Importing, querying and testing a module",id:"importing-querying-and-testing-a-module",level:2}],m={toc:u};function d(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Query modules can be implemented using the ",(0,o.kt)("a",{parentName:"p",href:"/memgraph/reference-guide/query-modules/api/cpp-api"},"C++\nAPI"),"\nprovided by Memgraph with automatic memory management.\nIn this tutorial, we will learn how to develop a query\nmodule in C++ on the example of the ",(0,o.kt)("strong",{parentName:"p"},"random walk algorithm"),"."),(0,o.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,o.kt)("p",null,"There are three options for installing and working with Memgraph MAGE:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Pulling the ",(0,o.kt)("inlineCode",{parentName:"strong"},"memgraph/memgraph-mage")," image"),": check the ",(0,o.kt)("inlineCode",{parentName:"li"},"Docker Hub"),(0,o.kt)("a",{parentName:"li",href:"/docs/mage/installation/docker-hub"},"installation guide"),"."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Building a Docker image from the MAGE repository"),": check the ",(0,o.kt)("inlineCode",{parentName:"li"},"Docker\nbuild")," ",(0,o.kt)("a",{parentName:"li",href:"/docs/mage/installation/docker-build"},"installation guide"),"."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Building MAGE from source"),": check the ",(0,o.kt)("inlineCode",{parentName:"li"},"Build from source on Linux"),(0,o.kt)("a",{parentName:"li",href:"/docs/mage/installation/source"},"installation guide"),".")),(0,o.kt)("h2",{id:"developing-a-module"},"Developing a module"),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"These instructions are the same for every MAGE installation option: ",(0,o.kt)("em",{parentName:"p"},"Docker\nHub"),", ",(0,o.kt)("em",{parentName:"p"},"Docker build")," and ",(0,o.kt)("em",{parentName:"p"},"Build from source on Linux"),".")),(0,o.kt)("p",null,"Position yourself in the ",(0,o.kt)("strong",{parentName:"p"},"MAGE repository")," you cloned earlier. Once you are\nthere, enter the ",(0,o.kt)("inlineCode",{parentName:"p"},"cpp")," subdirectory and create a new directory called\n",(0,o.kt)("inlineCode",{parentName:"p"},"random_walk_module")," with the ",(0,o.kt)("inlineCode",{parentName:"p"},"random_walk_module.cpp")," file inside it."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-plaintext"},"cpp\n\u2514\u2500\u2500 random_walk_module\n    \u2514\u2500\u2500 random_walk_module.cpp\n")),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"To make sure the module is linked with the rest of MAGE\u2019s code, we need to add a\n",(0,o.kt)("inlineCode",{parentName:"p"},"CMakeLists.txt")," script in the new directory and register our module in the\n",(0,o.kt)("inlineCode",{parentName:"p"},"cpp/CMakelists.txt")," script as well. Refer to the existing scripts in MAGE\u2019s\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/memgraph/mage/tree/main/cpp"},"query modules"),".")),(0,o.kt)("p",null,"Our ",(0,o.kt)("inlineCode",{parentName:"p"},"random_walk")," module contains a single procedure ",(0,o.kt)("inlineCode",{parentName:"p"},"get")," which implements the\nalgorithm. The procedure takes two input parameters: the starting node and the\nnumber of steps (10 by default), and it returns the generated random walk in the\nform of a list of ",(0,o.kt)("inlineCode",{parentName:"p"},"step | node")," entries, one for each step.\nAll in all, we can define its signature as ",(0,o.kt)("inlineCode",{parentName:"p"},"get(start: Node, steps: int = 10)\n-> [step: int | node: Node]"),"."),(0,o.kt)("p",null,"Let\u2019s take a look at the structure of our query module."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <mg_utils.hpp>\n\nvoid RandomWalk(mgp_list *args, mgp_graph *memgraph_graph,\n                     mgp_result *result, mgp_memory *memory);\n\nextern "C" int mgp_init_module(struct mgp_module *module,\n                               struct mgp_memory *memory);\n\nextern "C" int mgp_shutdown_module() { return 0; }\n\n')),(0,o.kt)("p",null,"In the first line, we include ",(0,o.kt)("inlineCode",{parentName:"p"},"mg_utils.hpp"),". This header contains declarations\nof the public C++ API provided by Memgraph, which we need to connect the algorithm\nto Memgraph and work with the data stored within."),(0,o.kt)("p",null,"Next, we are going to implement the random walk algorithm\u2019s logic in the\n",(0,o.kt)("inlineCode",{parentName:"p"},"RandomWalk")," function, which will be the callback for the invocations of our\nopenCypher procedure. Callback functions such as this one all need to have the\nsame signature, but they can be arbitrarily named (e.g. in query modules\ncontaining multiple callback functions)."),(0,o.kt)("p",null,"Query modules using the C++ API must have the ",(0,o.kt)("inlineCode",{parentName:"p"},"mgp_init_module")," &\n",(0,o.kt)("inlineCode",{parentName:"p"},"mgp_shutdown_module")," functions. The ",(0,o.kt)("inlineCode",{parentName:"p"},"mgp_init_module")," function\u2019s main purpose\nis to register procedures so that they can be called from Cypher query language, and with\n",(0,o.kt)("inlineCode",{parentName:"p"},"mgp_shutdown_module")," you may reset any global states or release global\nresources."),(0,o.kt)("admonition",{type:"warning"},(0,o.kt)("p",{parentName:"admonition"},"WARNING: Exceptions, if thrown, must never leave the scope of your module! You\nshould have a top-level exception handler that returns an error value and\npotentially logs the error message as well. Exceptions crossing the module\nboundary may cause all sorts of unexpected issues.")),(0,o.kt)("h3",{id:"main-algorithm"},"Main algorithm"),(0,o.kt)("p",null,"The main implementation of the ",(0,o.kt)("inlineCode",{parentName:"p"},"RandomWalk")," algorithm is implemented in the code snippet below."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'const char *kReturnStep = "step";\nconst char *kReturnNode = "node";\n\nvoid RandomWalk(mgp_list *args, mgp_graph *memgraph_graph, mgp_result *result, mgp_memory *memory) {\n  mgp::memory = memory;\n\n  const auto arguments = mgp::List(args);\n  const auto record_factory = mgp::RecordFactory(result);\n\n  const auto start = arguments[0].ValueNode();\n  const auto n_steps = arguments[1].ValueInt();\n\n  srand(time(NULL));\n\n  auto current_nodes = mgp::List();\n  current_nodes.AppendExtend(mgp::Value(start));\n\n  std::int64_t step = 0;\n  while (step <= n_steps) {\n    auto current_node = current_nodes[current_nodes.Size() - 1].ValueNode();\n\n    auto neighbours = mgp::List();\n    for (const auto relationship : current_node.OutRelationships()) {\n      neighbours.AppendExtend(mgp::Value(relationship));\n    }\n\n    if (neighbours.Size() == 0) {\n      break;\n    }\n\n    const auto next_node = neighbours[rand() % neighbours.Size()].ValueRelationship().To();\n\n    current_nodes.AppendExtend(mgp::Value(next_node));\n    step++;\n  }\n\n  for (std::int64_t i = 0; i < current_nodes.Size(); i++) {\n    auto record = record_factory.NewRecord();\n    record.Insert(kReturnStep, i);\n    record.Insert(kReturnNode, current_nodes[i].ValueNode());\n  }\n}\n')),(0,o.kt)("p",null,"Upon being called, ",(0,o.kt)("inlineCode",{parentName:"p"},"RandomWalk")," receives the list of arguments (",(0,o.kt)("inlineCode",{parentName:"p"},"args"),") passed\nin the query. The parameter ",(0,o.kt)("inlineCode",{parentName:"p"},"result")," is used for recording the results of the\nprocedure, and its context is provided by ",(0,o.kt)("inlineCode",{parentName:"p"},"graph")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"memory"),"."),(0,o.kt)("p",null,"With the C++ API, we next retrieve the argument values from ",(0,o.kt)("inlineCode",{parentName:"p"},"args")," by putting\nthem into a list, so we can use the indexing (",(0,o.kt)("inlineCode",{parentName:"p"},"[]"),") operator. In the code above,\nthe retrieving of arguments is done in these lines"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"  const auto start = arguments[0].ValueNode();\n  const auto n_steps = arguments[1].ValueInt();\n")),(0,o.kt)("p",null,"The arguments are raw values at the time of their fetching from the list, so types\nare assigned to them with ",(0,o.kt)("inlineCode",{parentName:"p"},"ValueNode()")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"ValueInt()")," for extra operability and\nexpressiveness within the algorithm."),(0,o.kt)("p",null,"For managing results during the execution of the algorithm,\nan instance of ",(0,o.kt)("inlineCode",{parentName:"p"},"RecordFactory")," is used. Insertion of results into the record factory is done like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"    auto record = record_factory.NewRecord();\n    record.Insert(kReturnStep, i);\n    record.Insert(kReturnNode, current_nodes[i].ValueNode());\n")),(0,o.kt)("p",null,"In this code snippet, the result consists of an integer and the corresponding next node\nof the random walk algorithm. The types of the results are not arbitrary, as they are\nregistered in the initialization module, further below."),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"Analogous methods for other supported data types are outlined in the\n",(0,o.kt)("a",{parentName:"p",href:"/memgraph/reference-guide/query-modules/api/cpp-api"},"C++ API reference"),".")),(0,o.kt)("h3",{id:"initialization-of-the-module"},"Initialization of the module"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"mgp_init_module")," function has as its main duty the registration of\nprocedure(s), which can then be invoked in Cypher query language. With the C++ API, we add our\nprocedure and its inputs and outputs."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'const char *kProcedureGet = "get";\nconst char *kParameterStart = "start";\nconst char *kParameterSteps = "steps";\nconst char *kReturnStep = "step";\nconst char *kReturnNode = "node";\n\nextern "C" int mgp_init_module(struct mgp_module *module, struct mgp_memory *memory) {\n  mgp::memory = memory;\n\n  std::int64_t default_steps = 10;\n  try {\n    mgp::AddProcedure(RandomWalk, \n                      kProcedureGet, \n                      mgp::ProcedureType::Read,\n                      {\n                        mgp::Parameter(kParameterStart, mgp::Type::Node),\n                        mgp::Parameter(kParameterSteps, mgp::Type::Int, default_steps)\n                      },\n                      {\n                        mgp::Return(kReturnStep, mgp::Type::Int),\n                        mgp::Return(kReturnNode, mgp::Type::Node)\n                      }, \n                      module,\n                      memory);\n  } catch (const std::exception &e) {\n    return 1;\n  }\n  return 0;\n}\n')),(0,o.kt)("p",null,"We add the procedure to the module by specifying:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"function callback")," used for executing the logic of the procedure (",(0,o.kt)("inlineCode",{parentName:"li"},"RandomWalk"),")"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"name of the procedure")," used in Cypher Query Language (",(0,o.kt)("inlineCode",{parentName:"li"},"kProcedureGet"),")"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"type of the procedure"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"mgp::Procedure::Read")," for read-only procedures"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"mgp::Procedure::Write")," for write procedures"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"vector of input parameters")," wrapped in ",(0,o.kt)("inlineCode",{parentName:"li"},"mgp::Parameter")," object with name (string) and type (",(0,o.kt)("inlineCode",{parentName:"li"},"mgp::Type"),")"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"vector of output results")," wrapped in ",(0,o.kt)("inlineCode",{parentName:"li"},"mgp::Return")," object with name (string) and type (",(0,o.kt)("inlineCode",{parentName:"li"},"mgp::Type"),")"),(0,o.kt)("li",{parentName:"ul"},"passed ",(0,o.kt)("inlineCode",{parentName:"li"},"module")," object"),(0,o.kt)("li",{parentName:"ul"},"passed ",(0,o.kt)("inlineCode",{parentName:"li"},"memory")," object")),(0,o.kt)("p",null,"Although this example registers a single procedure ",(0,o.kt)("inlineCode",{parentName:"p"},"get"),", you can have multiple\ndifferent procedures in one module, each of which can be invoked using the\n",(0,o.kt)("inlineCode",{parentName:"p"},"CALL <module>.<procedure> ...")," syntax (",(0,o.kt)("inlineCode",{parentName:"p"},"<module>")," being the name of the shared\nlibrary). Since we compile our example to ",(0,o.kt)("inlineCode",{parentName:"p"},"random_walk.so"),", the module is called\n",(0,o.kt)("inlineCode",{parentName:"p"},"random_walk"),"."),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"As the procedure name is defined upon registration, it can differ from its\nrespective callback.")),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"As the ",(0,o.kt)("inlineCode",{parentName:"p"},"memory")," argument is only alive throughout the execution of\n",(0,o.kt)("inlineCode",{parentName:"p"},"mgp_init_module"),", do not allocate any global resources with it. If you still do\nneed to set up a global state, you may do so in the ",(0,o.kt)("inlineCode",{parentName:"p"},"mgp_init_module")," using the\nstandard global allocators.")),(0,o.kt)("h3",{id:"shutdown-of-the-module"},"Shutdown of the module"),(0,o.kt)("p",null,"Finally, you may want to reset any global state or release global resources,\nwhich is done in the following function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'extern "C" int mgp_shutdown_module() {\n   return 0;\n}\n')),(0,o.kt)("h3",{id:"terminate-procedure-execution"},"Terminate procedure execution"),(0,o.kt)("p",null,"Just as the execution of a Cypher query can be terminated with ",(0,o.kt)("a",{parentName:"p",href:"/memgraph/reference-guide/transactions"},(0,o.kt)("inlineCode",{parentName:"a"},'TERMINATE\nTRANSACTIONS "id";'))," query, the execution of the procedure can as well, if it takes\ntoo long to yield a response or gets stuck in an infinite loop due to\nunpredicted input data."),(0,o.kt)("p",null,"Transaction ID is visible upon calling the ",(0,o.kt)("inlineCode",{parentName:"p"},"SHOW TRANSACTIONS;")," query. "),(0,o.kt)("p",null,"In order to be able to terminate the procedure, it has to contain function\n",(0,o.kt)("inlineCode",{parentName:"p"},"graph.CheckMustAbort();")," which precedes crucial parts of the code, such as\n",(0,o.kt)("inlineCode",{parentName:"p"},"while")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"until")," loops, or similar points where the procedure might become\ncostly."),(0,o.kt)("p",null,"Consider the following example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <cstdint>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n#include <mgp.hpp>\n#include <mg_exceptions.hpp>\n\n// Methods\nconstexpr char const *get = "get";\n// Return object names\nchar const *return_field = "return";\n\n\nvoid Test(mgp_list *args, mgp_graph *memgraph_graph, mgp_result *result, mgp_memory *memory) {\n    mgp::memory = memory;\n    const auto record_factory = mgp::RecordFactory(result);\n    auto graph = mgp::Graph(memgraph_graph);\n    int64_t id_ = 1;\n    try {\n        while (true) {\n            graph.CheckMustAbort();\n            ++id_;\n        }\n    } catch (const mgp::MustAbortException &e) {\n        std::cout << e.what() << std::endl;\n        auto new_record = record_factory.NewRecord();\n        new_record.Insert(return_field, id_);\n    }\n}\n\n\nextern "C" int mgp_init_module(struct mgp_module *module, struct mgp_memory *memory) {\n    try {\n        mgp::memory = memory;\n        mgp::AddProcedure(Test, get, mgp::ProcedureType::Read, {}, {mgp::Return(return_field, mgp::Type::Int)}, module, memory);\n    } catch(const std::exception &e) {\n        return 1;\n    } \n    return 0;\n}\n\nextern "C" int mgp_shutdown_module() { return 0; }\n')),(0,o.kt)("p",null,"As mentioned before, no exceptions should leave your module. As done in this\nexample, exception handlers are in ",(0,o.kt)("inlineCode",{parentName:"p"},"mgp_init_module")," and the callback function.\nDepending on your module\u2019s needs, you might want one in ",(0,o.kt)("inlineCode",{parentName:"p"},"mgp_shutdown_module")," as\nwell."),(0,o.kt)("h2",{id:"importing-querying-and-testing-a-module"},"Importing, querying and testing a module"),(0,o.kt)("p",null,"Now in order to import, query and test a module, check out the ",(0,o.kt)("a",{parentName:"p",href:"/mage/how-to-guides/run-a-query-module"},"following\npage"),"."),(0,o.kt)("p",null,"Feel free to create an issue or open a pull request on our ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/memgraph/mage"},"GitHub\nrepo")," to speed up the development.",(0,o.kt)("br",null),"\nAlso, don\u2019t forget to throw us a star on GitHub. \u2b50"))}d.isMDXComponent=!0}}]);