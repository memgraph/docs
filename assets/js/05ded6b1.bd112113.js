"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[88154],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>c});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),h=d(n),c=i,m=h["".concat(s,".").concat(c)]||h[c]||p[c]||l;return n?a.createElement(m,r(r({ref:t},u),{},{components:n})):a.createElement(m,r({ref:t},u))}));function c(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,r=new Array(l);r[0]=h;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,r[1]=o;for(var d=2;d<l;d++)r[d]=n[d];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},34629:(e,t,n)=>{n.r(t),n.d(t,{Highlight:()=>p,assets:()=>d,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>u});var a=n(87462),i=(n(67294),n(3905)),l=(n(65488),n(85162),n(83523));const r={id:"nxalg",title:"nxalg",sidebar_label:"nxalg"},o=void 0,s={unversionedId:"query-modules/python/nxalg",id:"query-modules/python/nxalg",title:"nxalg",description:"docs-source",source:"@site/mage/query-modules/python/nxalg.md",sourceDirName:"query-modules/python",slug:"/query-modules/python/nxalg",permalink:"/docs/mage/query-modules/python/nxalg",draft:!1,editUrl:"https://github.com/memgraph/docs/tree/master/mage/query-modules/python/nxalg.md",tags:[],version:"current",frontMatter:{id:"nxalg",title:"nxalg",sidebar_label:"nxalg"},sidebar:"mage",previous:{title:"node_similarity",permalink:"/docs/mage/query-modules/python/node-similarity"},next:{title:"pagerank",permalink:"/docs/mage/query-modules/cpp/pagerank"}},d={},u=[{value:"Abstract",id:"abstract",level:2},{value:"Procedures",id:"procedures",level:2},{value:"<code>all_shortest_paths(source, target, weight, method)</code>",id:"all_shortest_pathssource-target-weight-method",level:3},{value:"Input:",id:"input",level:4},{value:"Output:",id:"output",level:4},{value:"Usage:",id:"usage",level:4},{value:"<code>all_simple_paths(source, target, cutoff)</code>",id:"all_simple_pathssource-target-cutoff",level:3},{value:"Input:",id:"input-1",level:4},{value:"Output:",id:"output-1",level:4},{value:"Usage:",id:"usage-1",level:4},{value:"<code>ancestors(source)</code>",id:"ancestorssource",level:3},{value:"Input:",id:"input-2",level:4},{value:"Output:",id:"output-2",level:4},{value:"Usage:",id:"usage-2",level:4},{value:"<code>betweenness_centrality(k, normalized, weight, endpoints, seed)</code>",id:"betweenness_centralityk-normalized-weight-endpoints-seed",level:3},{value:"Input:",id:"input-3",level:4},{value:"Output:",id:"output-3",level:4},{value:"Usage:",id:"usage-3",level:4},{value:"<code>bfs_edges(source, reverse, depth_limit)</code>",id:"bfs_edgessource-reverse-depth_limit",level:3},{value:"Input:",id:"input-4",level:4},{value:"Output:",id:"output-4",level:4},{value:"Usage:",id:"usage-4",level:4},{value:"<code>bfs_predecessors(source, depth_limit)</code>",id:"bfs_predecessorssource-depth_limit",level:3},{value:"Input:",id:"input-5",level:4},{value:"Output:",id:"output-5",level:4},{value:"Usage:",id:"usage-5",level:4},{value:"<code>bfs_successors(source, depth_limit)</code>",id:"bfs_successorssource-depth_limit",level:3},{value:"Input:",id:"input-6",level:4},{value:"Output:",id:"output-6",level:4},{value:"Usage:",id:"usage-6",level:4},{value:"<code>bfs_tree(source, reverse, depth_limit)</code>",id:"bfs_treesource-reverse-depth_limit",level:3},{value:"Input:",id:"input-7",level:4},{value:"Output:",id:"output-7",level:4},{value:"Usage:",id:"usage-7",level:4},{value:"<code>biconnected_components()</code>",id:"biconnected_components",level:3},{value:"Output:",id:"output-8",level:4},{value:"Usage:",id:"usage-8",level:4},{value:"<code>bridges(root)</code>",id:"bridgesroot",level:3},{value:"Input:",id:"input-8",level:4},{value:"Output:",id:"output-9",level:4},{value:"Usage:",id:"usage-9",level:4},{value:"<code>center()</code>",id:"center",level:3},{value:"Output:",id:"output-10",level:4},{value:"Usage:",id:"usage-10",level:4},{value:"<code>chain_decomposition(root)</code>",id:"chain_decompositionroot",level:3},{value:"Input:",id:"input-9",level:4},{value:"Output:",id:"output-11",level:4},{value:"Usage:",id:"usage-11",level:4},{value:"<code>check_planarity()</code>",id:"check_planarity",level:3},{value:"Output:",id:"output-12",level:4},{value:"Usage:",id:"usage-12",level:4},{value:"<code>clustering(nodes, weight)</code>",id:"clusteringnodes-weight",level:3},{value:"Input:",id:"input-10",level:4},{value:"Output:",id:"output-13",level:4},{value:"Usage:",id:"usage-13",level:4},{value:"<code>communicability()</code>",id:"communicability",level:3},{value:"Output:",id:"output-14",level:4},{value:"Usage:",id:"usage-14",level:4},{value:"<code>core_number()</code>",id:"core_number",level:3},{value:"Output:",id:"output-15",level:4},{value:"Usage:",id:"usage-15",level:4},{value:"<code>degree_assortativity_coefficient(x, y, weight, nodes)</code>",id:"degree_assortativity_coefficientx-y-weight-nodes",level:3},{value:"Input:",id:"input-11",level:4},{value:"Output:",id:"output-16",level:4},{value:"Usage:",id:"usage-16",level:4},{value:"<code>descendants(source)</code>",id:"descendantssource",level:3},{value:"Input:",id:"input-12",level:4},{value:"Output:",id:"output-17",level:4},{value:"Usage:",id:"usage-17",level:4},{value:"<code>dfs_postorder_nodes(source, depth_limit)</code>",id:"dfs_postorder_nodessource-depth_limit",level:3},{value:"Input:",id:"input-13",level:4},{value:"Output:",id:"output-18",level:4},{value:"Usage:",id:"usage-18",level:4},{value:"<code>dfs_predecessors(source, depth_limit)</code>",id:"dfs_predecessorssource-depth_limit",level:3},{value:"Input:",id:"input-14",level:4},{value:"Output:",id:"output-19",level:4},{value:"Usage:",id:"usage-19",level:4},{value:"<code>dfs_preorder_nodes(source, depth_limit)</code>",id:"dfs_preorder_nodessource-depth_limit",level:3},{value:"Input:",id:"input-15",level:4},{value:"Output:",id:"output-20",level:4},{value:"Usage:",id:"usage-20",level:4},{value:"<code>dfs_successors(source, depth_limit)</code>",id:"dfs_successorssource-depth_limit",level:3},{value:"Input:",id:"input-16",level:4},{value:"Output:",id:"output-21",level:4},{value:"Usage:",id:"usage-21",level:4},{value:"<code>dfs_tree(source, depth_limit)</code>",id:"dfs_treesource-depth_limit",level:3},{value:"Input:",id:"input-17",level:4},{value:"Output:",id:"output-22",level:4},{value:"Usage:",id:"usage-22",level:4},{value:"<code>diameter()</code>",id:"diameter",level:3},{value:"Output:",id:"output-23",level:4},{value:"Usage:",id:"usage-23",level:4},{value:"<code>dominance_frontiers(start)</code>",id:"dominance_frontiersstart",level:3},{value:"Input:",id:"input-18",level:4},{value:"Output:",id:"output-24",level:4},{value:"Usage:",id:"usage-24",level:4},{value:"<code>dominating_set(start)</code>",id:"dominating_setstart",level:3},{value:"Input:",id:"input-19",level:4},{value:"Output:",id:"output-25",level:4},{value:"Usage:",id:"usage-25",level:4},{value:"<code>edge_bfs(source, orientation)</code>",id:"edge_bfssource-orientation",level:3},{value:"Input:",id:"input-20",level:4},{value:"Output:",id:"output-26",level:4},{value:"Usage:",id:"usage-26",level:4},{value:"<code>edge_dfs(source, orientation)</code>",id:"edge_dfssource-orientation",level:3},{value:"Input:",id:"input-21",level:4},{value:"Output:",id:"output-27",level:4},{value:"Usage:",id:"usage-27",level:4},{value:"<code>find_cliques()</code>",id:"find_cliques",level:3},{value:"Output:",id:"output-28",level:4},{value:"Usage:",id:"usage-28",level:4},{value:"<code>find_cycle(source, orientation)</code>",id:"find_cyclesource-orientation",level:3},{value:"Input:",id:"input-22",level:4},{value:"Output:",id:"output-29",level:4},{value:"Usage:",id:"usage-29",level:4},{value:"<code>flow_hierarchy(weight)</code>",id:"flow_hierarchyweight",level:3},{value:"Input:",id:"input-23",level:4},{value:"Output:",id:"output-30",level:4},{value:"Usage:",id:"usage-30",level:4},{value:"<code>global_efficiency()</code>",id:"global_efficiency",level:3},{value:"Output:",id:"output-31",level:4},{value:"Usage:",id:"usage-31",level:4},{value:"<code>greedy_color(strategy, interchange)</code>",id:"greedy_colorstrategy-interchange",level:3},{value:"Input:",id:"input-24",level:4},{value:"Output:",id:"output-32",level:4},{value:"Usage:",id:"usage-32",level:4},{value:"<code>has_eulerian_path()</code>",id:"has_eulerian_path",level:3},{value:"Output:",id:"output-33",level:4},{value:"Usage:",id:"usage-33",level:4},{value:"<code>has_path(source, target)</code>",id:"has_pathsource-target",level:3},{value:"Input:",id:"input-25",level:4},{value:"Output:",id:"output-34",level:4},{value:"Usage:",id:"usage-34",level:4},{value:"<code>immediate_dominators(start)</code>",id:"immediate_dominatorsstart",level:3},{value:"Input:",id:"input-26",level:4},{value:"Output:",id:"output-35",level:4},{value:"Usage:",id:"usage-35",level:4},{value:"<code>is_arborescence()</code>",id:"is_arborescence",level:3},{value:"Output:",id:"output-36",level:4},{value:"Usage:",id:"usage-36",level:4},{value:"<code>is_at_free()</code>",id:"is_at_free",level:3},{value:"Output:",id:"output-37",level:4},{value:"Usage:",id:"usage-37",level:4},{value:"<code>is_bipartite()</code>",id:"is_bipartite",level:3},{value:"Output:",id:"output-38",level:4},{value:"Usage:",id:"usage-38",level:4},{value:"<code>is_branching()</code>",id:"is_branching",level:3},{value:"Output:",id:"output-39",level:4},{value:"Usage:",id:"usage-39",level:4},{value:"<code>is_chordal()</code>",id:"is_chordal",level:3},{value:"Output:",id:"output-40",level:4},{value:"Usage:",id:"usage-40",level:4},{value:"<code>is_distance_regular()</code>",id:"is_distance_regular",level:3},{value:"Output:",id:"output-41",level:4},{value:"Usage:",id:"usage-41",level:4},{value:"<code>is_edge_cover(cover)</code>",id:"is_edge_covercover",level:3},{value:"Input:",id:"input-27",level:4},{value:"Output:",id:"output-42",level:4},{value:"Usage:",id:"usage-42",level:4},{value:"<code>is_eulerian()</code>",id:"is_eulerian",level:3},{value:"Output:",id:"output-43",level:4},{value:"Usage:",id:"usage-43",level:4},{value:"<code>is_forest()</code>",id:"is_forest",level:3},{value:"Output:",id:"output-44",level:4},{value:"Usage:",id:"usage-44",level:4},{value:"<code>is_isolate(n)</code>",id:"is_isolaten",level:3},{value:"Input:",id:"input-28",level:4},{value:"Output:",id:"output-45",level:4},{value:"Usage:",id:"usage-45",level:4},{value:"<code>is_isomorphic(nodes1, edges1, nodes2, edges2)</code>",id:"is_isomorphicnodes1-edges1-nodes2-edges2",level:3},{value:"Input:",id:"input-29",level:4},{value:"Output:",id:"output-46",level:4},{value:"Usage:",id:"usage-46",level:4},{value:"<code>is_semieulerian()</code>",id:"is_semieulerian",level:3},{value:"Output:",id:"output-47",level:4},{value:"Usage:",id:"usage-47",level:4},{value:"<code>is_simple_path(nodes)</code>",id:"is_simple_pathnodes",level:3},{value:"Input:",id:"input-30",level:4},{value:"Output:",id:"output-48",level:4},{value:"Usage:",id:"usage-48",level:4},{value:"<code>is_strongly_regular()</code>",id:"is_strongly_regular",level:3},{value:"Output:",id:"output-49",level:4},{value:"Usage:",id:"usage-49",level:4},{value:"<code>is_tournament()</code>",id:"is_tournament",level:3},{value:"Output:",id:"output-50",level:4},{value:"Usage:",id:"usage-50",level:4},{value:"<code>is_tree()</code>",id:"is_tree",level:3},{value:"Output:",id:"output-51",level:4},{value:"Usage:",id:"usage-51",level:4},{value:"<code>isolates()</code>",id:"isolates",level:3},{value:"Output:",id:"output-52",level:4},{value:"Usage:",id:"usage-52",level:4},{value:"<code>jaccard_coefficient(ebunch)</code>",id:"jaccard_coefficientebunch",level:3},{value:"Input:",id:"input-31",level:4},{value:"Output:",id:"output-53",level:4},{value:"Usage:",id:"usage-53",level:4},{value:"<code>k_clique_communities(k, cliques)</code>",id:"k_clique_communitiesk-cliques",level:3},{value:"Input:",id:"input-32",level:4},{value:"Output:",id:"output-54",level:4},{value:"Usage:",id:"usage-54",level:4},{value:"<code>k_components(density)</code>",id:"k_componentsdensity",level:3},{value:"Input:",id:"input-33",level:4},{value:"Output:",id:"output-55",level:4},{value:"Usage:",id:"usage-55",level:4},{value:"<code>k_edge_components(k)</code>",id:"k_edge_componentsk",level:3},{value:"Input:",id:"input-34",level:4},{value:"Output:",id:"output-56",level:4},{value:"Usage:",id:"usage-56",level:4},{value:"<code>local_efficiency()</code>",id:"local_efficiency",level:3},{value:"Output:",id:"output-57",level:4},{value:"Usage:",id:"usage-57",level:4},{value:"<code>lowest_common_ancestor(node1, node2)</code>",id:"lowest_common_ancestornode1-node2",level:3},{value:"Input:",id:"input-35",level:4},{value:"Output:",id:"output-58",level:4},{value:"Usage:",id:"usage-58",level:4},{value:"<code>maximal_matching()</code>",id:"maximal_matching",level:3},{value:"Output:",id:"output-59",level:4},{value:"Usage:",id:"usage-59",level:4},{value:"<code>minimum_spanning_tree(weight, algorithm, ignore_nan)</code>",id:"minimum_spanning_treeweight-algorithm-ignore_nan",level:3},{value:"Input:",id:"input-36",level:4},{value:"Output:",id:"output-60",level:4},{value:"Usage:",id:"usage-60",level:4},{value:"<code>multi_source_dijkstra_path(sources, cutoff, weight)</code>",id:"multi_source_dijkstra_pathsources-cutoff-weight",level:3},{value:"Input:",id:"input-37",level:4},{value:"Output:",id:"output-61",level:4},{value:"Usage:",id:"usage-61",level:4},{value:"<code>multi_source_dijkstra_path_length(sources, cutoff, weight)</code>",id:"multi_source_dijkstra_path_lengthsources-cutoff-weight",level:3},{value:"Input:",id:"input-38",level:4},{value:"Output:",id:"output-62",level:4},{value:"Usage:",id:"usage-62",level:4},{value:"<code>node_boundary(nbunch1, bunch2)</code>",id:"node_boundarynbunch1-bunch2",level:3},{value:"Input:",id:"input-39",level:4},{value:"Output:",id:"output-63",level:4},{value:"Usage:",id:"usage-63",level:4},{value:"<code>node_connectivity(source, target)</code>",id:"node_connectivitysource-target",level:3},{value:"Input:",id:"input-40",level:4},{value:"Output:",id:"output-64",level:4},{value:"Usage:",id:"usage-64",level:4},{value:"<code>node_expansion(s)</code>",id:"node_expansions",level:3},{value:"Input:",id:"input-41",level:4},{value:"Output:",id:"output-65",level:4},{value:"Usage:",id:"usage-65",level:4},{value:"<code>non_randomness(k)</code>",id:"non_randomnessk",level:3},{value:"Input:",id:"input-42",level:4},{value:"Output:",id:"output-66",level:4},{value:"Usage:",id:"usage-66",level:4},{value:"<code>pagerank(alpha, personalization, max_iter, tol, nstart, weight, dangling)</code>",id:"pagerankalpha-personalization-max_iter-tol-nstart-weight-dangling",level:3},{value:"Input:",id:"input-43",level:4},{value:"Output:",id:"output-67",level:4},{value:"Usage:",id:"usage-67",level:4},{value:"<code>reciprocity(nodes)</code>",id:"reciprocitynodes",level:3},{value:"Input:",id:"input-44",level:4},{value:"Output:",id:"output-68",level:4},{value:"Usage:",id:"usage-68",level:4},{value:"<code>shortest_path(source, target, weight, method)</code>",id:"shortest_pathsource-target-weight-method",level:3},{value:"Input:",id:"input-45",level:4},{value:"Output:",id:"output-69",level:4},{value:"Usage:",id:"usage-69",level:4},{value:"<code>shortest_path_length(source, target, weight, method)</code>",id:"shortest_path_lengthsource-target-weight-method",level:3},{value:"Input:",id:"input-46",level:4},{value:"Output:",id:"output-70",level:4},{value:"Usage:",id:"usage-70",level:4},{value:"<code>simple_cycles()</code>",id:"simple_cycles",level:3},{value:"Output:",id:"output-71",level:4},{value:"Usage:",id:"usage-71",level:4},{value:"<code>strongly_connected_components()</code>",id:"strongly_connected_components",level:3},{value:"Output:",id:"output-72",level:4},{value:"Usage:",id:"usage-72",level:4},{value:"<code>topological_sort()</code>",id:"topological_sort",level:3},{value:"Output:",id:"output-73",level:4},{value:"Usage:",id:"usage-73",level:4},{value:"<code>triadic_census()</code>",id:"triadic_census",level:3},{value:"Output:",id:"output-74",level:4},{value:"Usage:",id:"usage-74",level:4},{value:"<code>voronoi_cells(center_nodes, weight)</code>",id:"voronoi_cellscenter_nodes-weight",level:3},{value:"Input:",id:"input-47",level:4},{value:"Output:",id:"output-75",level:4},{value:"Usage:",id:"usage-75",level:4},{value:"<code>wiener_index(weight)</code>",id:"wiener_indexweight",level:3},{value:"Input:",id:"input-48",level:4},{value:"Output:",id:"output-76",level:4},{value:"Usage:",id:"usage-76",level:4}],p=e=>{let{children:t,color:n}=e;return(0,i.kt)("span",{style:{backgroundColor:n,borderRadius:"2px",color:"#fff",padding:"0.2rem"}},t)},h={toc:u,Highlight:p};function c(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/memgraph/mage/blob/main/python/nxalg.py"},(0,i.kt)("img",{parentName:"a",src:"https://img.shields.io/badge/source-nxalg-FB6E00?logo=github&style=for-the-badge",alt:"docs-source"}))),(0,i.kt)("h2",{id:"abstract"},"Abstract"),(0,i.kt)("p",null,"This module, named ",(0,i.kt)("strong",{parentName:"p"},"nxalg"),", provides a comprehensive set of thin wrappers around most of the algorithms present in the ",(0,i.kt)("a",{parentName:"p",href:"https://networkx.org/"},"NetworkX")," package. The wrapper functions now have the capability to create a NetworkX compatible graph-like object that can stream the native database graph directly saving on memory usage significantly."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Trait"),(0,i.kt)("th",{parentName:"tr",align:null},"Value"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"Module type")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)(p,{color:"#FB6E00",mdxType:"Highlight"},(0,i.kt)("strong",{parentName:"td"},"module")))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"Implementation")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)(p,{color:"#FB6E00",mdxType:"Highlight"},(0,i.kt)("strong",{parentName:"td"},"Python")))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"Graph direction")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)(p,{color:"#FB6E00",mdxType:"Highlight"},(0,i.kt)("strong",{parentName:"td"},"directed")),"/",(0,i.kt)(p,{color:"#FB6E00",mdxType:"Highlight"},(0,i.kt)("strong",{parentName:"td"},"undirected")))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"Edge weights")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)(p,{color:"#FB6E00",mdxType:"Highlight"},(0,i.kt)("strong",{parentName:"td"},"weighted")),"/",(0,i.kt)(p,{color:"#FB6E00",mdxType:"Highlight"},(0,i.kt)("strong",{parentName:"td"},"unweighted")))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"Parallelism")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)(p,{color:"#FB6E00",mdxType:"Highlight"},(0,i.kt)("strong",{parentName:"td"},"sequential")))))),(0,i.kt)("h2",{id:"procedures"},"Procedures"),(0,i.kt)(l.ZP,{mdxType:"RunOnSubgraph"}),(0,i.kt)("h3",{id:"all_shortest_pathssource-target-weight-method"},(0,i.kt)("inlineCode",{parentName:"h3"},"all_shortest_paths(source, target, weight, method)")),(0,i.kt)("p",null,"Compute all shortest simple paths in the graph. A simple path is a path with no repeated nodes."),(0,i.kt)("h4",{id:"input"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"source: Vertex")," \u27a1 Starting node for the path."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"target: Vertex")," \u27a1 Ending node for the path."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"weight: string (default=NULL)")," \u27a1 If ",(0,i.kt)("inlineCode",{parentName:"li"},"NULL"),", every edge has weight/distance/cost 1. If a string, use this edge attribute as the edge weight. Any edge attribute not present defaults to 1."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},'method: string (default="dijkstra")')," \u27a1 The algorithm to use to compute the path lengths. Supported options: \u2018dijkstra\u2019, \u2018bellman-ford\u2019. Other inputs produce a ValueError. If ",(0,i.kt)("inlineCode",{parentName:"li"},"weight")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", unweighted graph methods are used, and this suggestion is ignored.")),(0,i.kt)("h4",{id:"output"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"paths: List[Vertex]")," \u27a1 List of vertices for a certain path.")),(0,i.kt)("h4",{id:"usage"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (n:Label), (m:Label)\nCALL nxalg.all_shortest_paths(n, m) YIELD *\nRETURN paths;\n")),(0,i.kt)("h3",{id:"all_simple_pathssource-target-cutoff"},(0,i.kt)("inlineCode",{parentName:"h3"},"all_simple_paths(source, target, cutoff)")),(0,i.kt)("p",null,"Returns all simple paths in the graph ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," from source to target. A simple path is a path with no repeated nodes."),(0,i.kt)("h4",{id:"input-1"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"source: Vertex")," \u27a1 Starting node for the path."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"target: Vertex")," \u27a1 Ending node for the path."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cutoff: List[integer] (default=NULL)")," \u27a1 Depth to stop the search. Only paths of ",(0,i.kt)("inlineCode",{parentName:"li"},"length <= cutoff")," are returned.")),(0,i.kt)("h4",{id:"output-1"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"paths: List[Vertex]")," \u27a1 List of vertices for a certain path. If there are no paths between the source and target within the given cutoff there is no output.")),(0,i.kt)("h4",{id:"usage-1"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (n:Label), (m:Label)\nCALL nxalg.all_simple_paths(n, m, 5) YIELD *\nRETURN paths;\n")),(0,i.kt)("h3",{id:"ancestorssource"},(0,i.kt)("inlineCode",{parentName:"h3"},"ancestors(source)")),(0,i.kt)("p",null,"Returns all nodes having a path to ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),"."),(0,i.kt)("h4",{id:"input-2"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"source: Vertex")," \u27a1 Starting node. Calculates all nodes that have a path to ",(0,i.kt)("inlineCode",{parentName:"li"},"source"))),(0,i.kt)("h4",{id:"output-2"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ancestors: List[Vertex]")," \u27a1 List of vertices that have a path toward source node")),(0,i.kt)("h4",{id:"usage-2"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (n:Label)\nCALL nxalg.ancestors(n) YIELD *\nRETURN ancestors;\n")),(0,i.kt)("h3",{id:"betweenness_centralityk-normalized-weight-endpoints-seed"},(0,i.kt)("inlineCode",{parentName:"h3"},"betweenness_centrality(k, normalized, weight, endpoints, seed)")),(0,i.kt)("p",null,"Compute the shortest-path betweenness centrality for nodes. ",(0,i.kt)("em",{parentName:"p"},"Betweenness centrality")," is a measure of centrality in a graph based on shortest paths. Centrality identifies the most important nodes within a graph."),(0,i.kt)("h4",{id:"input-3"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"k: string (default=NULL)")," \u27a1 If ",(0,i.kt)("inlineCode",{parentName:"li"},"k")," is not ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", use ",(0,i.kt)("inlineCode",{parentName:"li"},"k")," node samples to estimate betweenness. The value of ",(0,i.kt)("inlineCode",{parentName:"li"},"k <= n")," where ",(0,i.kt)("inlineCode",{parentName:"li"},"n")," is the number of nodes in the graph. Higher values give a better approximation."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"normalized: boolean (default=True)")," \u27a1  If ",(0,i.kt)("inlineCode",{parentName:"li"},"True")," the betweenness values are normalized by ",(0,i.kt)("inlineCode",{parentName:"li"},"2/((n-1)(n-2))")," for graphs, and ",(0,i.kt)("inlineCode",{parentName:"li"},"1/((n-1)(n-2))")," for directed graphs where ",(0,i.kt)("inlineCode",{parentName:"li"},"n")," is the number of nodes in ",(0,i.kt)("inlineCode",{parentName:"li"},"G"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"weight: string (default=NULL)")," \u27a1  If ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", all edge weights are considered equal. Otherwise holds the name of the edge attribute used as weight."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"endpoints: boolean (default=False)")," \u27a1  If ",(0,i.kt)("inlineCode",{parentName:"li"},"True"),", includes the endpoints in the shortest path counts."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"seed: integer (default=NULL)")," \u27a1  Indicator of random number generation state. Note that this is only used if ",(0,i.kt)("inlineCode",{parentName:"li"},"k")," is not ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),".")),(0,i.kt)("h4",{id:"output-3"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"node: Vertex")," \u27a1 Graph vertex for betweenness calculation"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"betweenness: double")," \u27a1 Value of betweenness for a given node")),(0,i.kt)("h4",{id:"usage-3"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.betweenness_centrality(20, True) YIELD *\nRETURN node, betweenness;\n")),(0,i.kt)("h3",{id:"bfs_edgessource-reverse-depth_limit"},(0,i.kt)("inlineCode",{parentName:"h3"},"bfs_edges(source, reverse, depth_limit)")),(0,i.kt)("p",null,"Iterate over edges in a breadth-first-search starting at source."),(0,i.kt)("h4",{id:"input-4"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"source: Vertex")," \u27a1  Specify starting node for breadth-first search; this function iterates over only those edges in the component reachable from this node."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"reverse: boolean (default=False)")," \u27a1   If ",(0,i.kt)("inlineCode",{parentName:"li"},"True"),", traverse a directed graph in the reverse direction."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"depth_limit: integer (default=NULL)")," \u27a1  Specify the maximum search depth.")),(0,i.kt)("h4",{id:"output-4"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"edges: List[Edge]")," \u27a1 List of edges in the breadth-first search.")),(0,i.kt)("h4",{id:"usage-4"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (n:Label)\nCALL nxalg.bfs_edges(n, False) YIELD *\nRETURN edges;\n")),(0,i.kt)("h3",{id:"bfs_predecessorssource-depth_limit"},(0,i.kt)("inlineCode",{parentName:"h3"},"bfs_predecessors(source, depth_limit)")),(0,i.kt)("p",null,"Returns an iterator of predecessors in breadth-first-search from source."),(0,i.kt)("h4",{id:"input-5"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"source: Vertex")," \u27a1  Specify starting node for breadth-first search."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"depth_limit: integer (default=NULL)")," \u27a1  Specify the maximum search depth.")),(0,i.kt)("h4",{id:"output-5"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"node: Vertex")," \u27a1 Node in a graph"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"predecessors: List[Vertex]")," \u27a1 List of predecessors of given node")),(0,i.kt)("h4",{id:"usage-5"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (n:Label)\nCALL nxalg.bfs_predecessors(n, 10) YIELD *\nRETURN node, predecessors;\n")),(0,i.kt)("h3",{id:"bfs_successorssource-depth_limit"},(0,i.kt)("inlineCode",{parentName:"h3"},"bfs_successors(source, depth_limit)")),(0,i.kt)("p",null,"Returns an iterator of successors in breadth-first-search from source."),(0,i.kt)("h4",{id:"input-6"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"source: Vertex")," \u27a1  Specify starting node for breadth-first search."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"depth_limit: integer (default=NULL)")," \u27a1  Specify the maximum search depth.")),(0,i.kt)("h4",{id:"output-6"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"node: Vertex")," \u27a1 Node in a graph"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"successors: List[Vertex]")," \u27a1 List of successors of given node")),(0,i.kt)("h4",{id:"usage-6"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (n:Label)\nCALL nxalg.bfs_successors(n, 5) YIELD *\nRETURN node, successors;\n")),(0,i.kt)("h3",{id:"bfs_treesource-reverse-depth_limit"},(0,i.kt)("inlineCode",{parentName:"h3"},"bfs_tree(source, reverse, depth_limit)")),(0,i.kt)("p",null,"Returns an oriented tree constructed from of a breadth-first-search starting at ",(0,i.kt)("inlineCode",{parentName:"p"},"source"),"."),(0,i.kt)("h4",{id:"input-7"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"source: Vertex")," \u27a1  Specify starting node for breadth-first search."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"reversed: boolean (default=False)")," \u27a1  If ",(0,i.kt)("inlineCode",{parentName:"li"},"True"),", traverse a directed graph in the reverse direction."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"depth_limit: integer (default=NULL)")," \u27a1  Specify the maximum search depth.")),(0,i.kt)("h4",{id:"output-7"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"tree: List[Vertex]")," \u27a1 An oriented tree in a list format.")),(0,i.kt)("h4",{id:"usage-7"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (n:Label)\nCALL nxalg.bfs_tree(n, True, 3) YIELD *\nRETURN n, tree;\n")),(0,i.kt)("h3",{id:"biconnected_components"},(0,i.kt)("inlineCode",{parentName:"h3"},"biconnected_components()")),(0,i.kt)("p",null,"Returns a list of sets of nodes, one set for each biconnected\ncomponent of the graph"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Biconnected components")," are maximal subgraphs such that the removal of a\nnode (and all edges incident on that node) will not disconnect the\nsubgraph. Note that nodes may be part of more than one biconnected\ncomponent.  Those nodes are articulation points or cut vertices.  The\nremoval of articulation points will increase the number of connected\ncomponents of the graph."),(0,i.kt)("p",null,"Notice that by convention a dyad is considered a biconnected component."),(0,i.kt)("h4",{id:"output-8"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"components: List[List[Vertex]]")," \u27a1 A list of sets of nodes, one set for each biconnected component.")),(0,i.kt)("h4",{id:"usage-8"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.biconnected_components() YIELD *\nRETURN components;\n")),(0,i.kt)("h3",{id:"bridgesroot"},(0,i.kt)("inlineCode",{parentName:"h3"},"bridges(root)")),(0,i.kt)("p",null,"Returns all bridges in a graph."),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"bridge")," in a graph is an edge whose removal causes the number of\nconnected components of the graph to increase.  Equivalently, a bridge is an\nedge that does not belong to any cycle."),(0,i.kt)("h4",{id:"input-8"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"root: Vertex (default=NULL)")," \u27a1   A node in the graph ",(0,i.kt)("inlineCode",{parentName:"li"},"G"),". If specified, only the bridges in the connected components containing this node will be returned.")),(0,i.kt)("h4",{id:"output-9"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"bridges: List[Edge]")," \u27a1  A list of edges in the graph whose removal disconnects the graph (or causes the number of connected components to increase).")),(0,i.kt)("h4",{id:"usage-9"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.bridges() YIELD *\nRETURN bridges;\n")),(0,i.kt)("h3",{id:"center"},(0,i.kt)("inlineCode",{parentName:"h3"},"center()")),(0,i.kt)("p",null,"Returns the center of the graph ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("em",{parentName:"p"},"center")," is the set of nodes with eccentricity equal to the radius."),(0,i.kt)("h4",{id:"output-10"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"center: List[Vertex]")," \u27a1 List of nodes in center.")),(0,i.kt)("h4",{id:"usage-10"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.center() YIELD *\nRETURN center;\n")),(0,i.kt)("h3",{id:"chain_decompositionroot"},(0,i.kt)("inlineCode",{parentName:"h3"},"chain_decomposition(root)")),(0,i.kt)("p",null,"Returns the chain decomposition of a graph."),(0,i.kt)("p",null,"The ",(0,i.kt)("em",{parentName:"p"},"chain decomposition")," of a graph with respect to a depth-first\nsearch tree is a set of cycles or paths derived from the set of\nfundamental cycles of the tree in the following manner. Consider\neach fundamental cycle with respect to the given tree, represented\nas a list of edges beginning with the non tree edge oriented away\nfrom the root of the tree. For each fundamental cycle, if it\noverlaps with any previous fundamental cycle, just take the initial\nnon-overlapping segment, which is a path instead of a cycle. Each\ncycle or path is called a ",(0,i.kt)("em",{parentName:"p"},"chain"),"."),(0,i.kt)("h4",{id:"input-9"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"root: Vertex[NULL]")," \u27a1   Optional. A node in the graph ",(0,i.kt)("inlineCode",{parentName:"li"},"G"),". If specified, only the chain decomposition for the connected component containing this node will be returned. This node indicates the root of the depth-first Search tree.")),(0,i.kt)("h4",{id:"output-11"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"chains: List[List[Edge]]")," \u27a1 A list of edges representing a chain. There is no guarantee on the orientation of the edges in each chain (for example, if a chain includes the edge joining nodes 1 and 2, the chain may include either (1, 2) or (2, 1)).")),(0,i.kt)("h4",{id:"usage-11"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (n:Label)\nCALL nxalg.chain_decomposition(n) YIELD *\nRETURN chains;\n")),(0,i.kt)("h3",{id:"check_planarity"},(0,i.kt)("inlineCode",{parentName:"h3"},"check_planarity()")),(0,i.kt)("p",null,"Check if a graph is planar."),(0,i.kt)("p",null,"A graph is planar if it can be drawn in a plane without\nany edge intersections."),(0,i.kt)("h4",{id:"output-12"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"is_planar: boolean")," \u27a1 ",(0,i.kt)("inlineCode",{parentName:"li"},"True")," if the graph is planar.")),(0,i.kt)("h4",{id:"usage-12"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.check_planarity() YIELD *\nRETURN is_planar;\n")),(0,i.kt)("h3",{id:"clusteringnodes-weight"},(0,i.kt)("inlineCode",{parentName:"h3"},"clustering(nodes, weight)")),(0,i.kt)("p",null,"Compute the clustering coefficient for nodes."),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"clustering coefficient")," is a measure of the degree to which nodes\nin a graph tend to cluster together."),(0,i.kt)("h4",{id:"input-10"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"nodes: List[Vertex] (default=NULL)")," \u27a1  Compute clustering for nodes in this container."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"weight: string (default=NULL)")," \u27a1  The edge attribute that holds the numerical value used as a weight. If ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", then each edge has weight 1.")),(0,i.kt)("h4",{id:"output-13"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"node: Vertex")," \u27a1 Node in graph for calculation of clustering"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"clustering: double")," \u27a1 Clustering coefficient at specified nodes.")),(0,i.kt)("h4",{id:"usage-13"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (n:SpecificLabel)\nWITH COLLECT(n) AS cluster_nodes\nCALL nxalg.clustering(cluster_nodes) YIELD *\nRETURN node, clustering;\n")),(0,i.kt)("h3",{id:"communicability"},(0,i.kt)("inlineCode",{parentName:"h3"},"communicability()")),(0,i.kt)("p",null,"Returns communicability between all pairs of nodes in ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("em",{parentName:"p"},"communicability")," between pairs of nodes in ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is the sum of\nclosed walks of different lengths starting at node ",(0,i.kt)("inlineCode",{parentName:"p"},"u")," and ending at node ",(0,i.kt)("inlineCode",{parentName:"p"},"v"),"."),(0,i.kt)("h4",{id:"output-14"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"node1: Vertex")," \u27a1 First value in communicability calculation"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"node2: Vertex")," \u27a1 Second value in communicability calculation"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"communicability: double")," \u27a1 Value of communicability between two values.")),(0,i.kt)("h4",{id:"usage-14"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.communicability() YIELD *\nRETURN node1, node2, communicability\nORDER BY communicability DESC;\n")),(0,i.kt)("h3",{id:"core_number"},(0,i.kt)("inlineCode",{parentName:"h3"},"core_number()")),(0,i.kt)("p",null,"Returns the core number for each vertex."),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"k-core")," is a maximal subgraph that contains nodes of degree ",(0,i.kt)("inlineCode",{parentName:"p"},"k")," or more."),(0,i.kt)("p",null,"The core number of a node is the largest value ",(0,i.kt)("inlineCode",{parentName:"p"},"k")," of a k-core containing\nthat node."),(0,i.kt)("h4",{id:"output-15"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"node: Vertex")," \u27a1 Node to calculate k-core for"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"core: integer")," \u27a1 Largest value ",(0,i.kt)("inlineCode",{parentName:"li"},"k")," of a k-core")),(0,i.kt)("h4",{id:"usage-15"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.core_number() YIELD *\nRETURN node, core\nORDER BY core DESC;\n")),(0,i.kt)("h3",{id:"degree_assortativity_coefficientx-y-weight-nodes"},(0,i.kt)("inlineCode",{parentName:"h3"},"degree_assortativity_coefficient(x, y, weight, nodes)")),(0,i.kt)("p",null,"Compute degree assortativity of a graph."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Assortativity")," measures the similarity of connections\nin the graph with respect to the node degree."),(0,i.kt)("h4",{id:"input-11"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},'x: string (default="out")'),' \u27a1  The degree type for source node (directed graphs only). Can be "in" or "out".'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},'y: string (default="in")'),' \u27a1  The degree type for target node (directed graphs only). Can be "in" or "out".'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"weight: string (default=NULL)")," \u27a1  The edge attribute that holds the numerical value used as a weight.  If ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", then each edge has weight 1. The degree is the sum of the edge weights adjacent to the node."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"nodes: List[Vertex] (default=NULL)")," \u27a1  Compute degree assortativity only for nodes in a container. The default is all nodes.")),(0,i.kt)("h4",{id:"output-16"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"assortativity: double")," \u27a1 Assortativity of graph by degree.")),(0,i.kt)("h4",{id:"usage-16"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.degree_assortativity_coefficient('out', 'in') YIELD *\nRETURN assortativity;\n")),(0,i.kt)("h3",{id:"descendantssource"},(0,i.kt)("inlineCode",{parentName:"h3"},"descendants(source)")),(0,i.kt)("p",null,"Returns all nodes reachable from ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),"."),(0,i.kt)("h4",{id:"input-12"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"source: Vertex")," \u27a1  A node in ",(0,i.kt)("inlineCode",{parentName:"li"},"G"),".")),(0,i.kt)("h4",{id:"output-17"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"descendants: List[Vertex]")," \u27a1 The descendants of ",(0,i.kt)("inlineCode",{parentName:"li"},"source")," in ",(0,i.kt)("inlineCode",{parentName:"li"},"G"),".")),(0,i.kt)("h4",{id:"usage-17"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (source:Label)\nCALL nxalg.descendants(source) YIELD *\nRETURN descendants;\n")),(0,i.kt)("h3",{id:"dfs_postorder_nodessource-depth_limit"},(0,i.kt)("inlineCode",{parentName:"h3"},"dfs_postorder_nodes(source, depth_limit)")),(0,i.kt)("p",null,"Returns nodes in a depth-first-search post-ordering starting at source."),(0,i.kt)("h4",{id:"input-13"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"source: Vertex")," \u27a1  Specify the maximum search depth."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"depth_limit: integer (default=NULL)")," \u27a1  Specify the maximum search depth.")),(0,i.kt)("h4",{id:"output-18"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"nodes: List[Vertex]")," \u27a1 A list of nodes in a depth-first-search post-ordering.")),(0,i.kt)("h4",{id:"usage-18"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (source:Label)\nCALL nxalg.dfs_postorder_nodes(source, 10) YIELD *\nRETURN source, nodes;\n")),(0,i.kt)("h3",{id:"dfs_predecessorssource-depth_limit"},(0,i.kt)("inlineCode",{parentName:"h3"},"dfs_predecessors(source, depth_limit)")),(0,i.kt)("p",null,"Returns a dictionary of predecessors in depth-first-search from source."),(0,i.kt)("h4",{id:"input-14"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"source: Vertex")," \u27a1  Specify the maximum search depth."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"depth_limit: integer (default=NULL)")," \u27a1  Specify the maximum search depth.")),(0,i.kt)("h4",{id:"output-19"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"node: Vertex")," \u27a1 Node we are looking a predecessor for."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"predecessor: Vertex")," \u27a1 predecessor of a given node.")),(0,i.kt)("h4",{id:"usage-19"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (source:Label)\nCALL nxalg.dfs_predecessors(source, 10) YIELD *\nRETURN node, predecessor;\n")),(0,i.kt)("h3",{id:"dfs_preorder_nodessource-depth_limit"},(0,i.kt)("inlineCode",{parentName:"h3"},"dfs_preorder_nodes(source, depth_limit)")),(0,i.kt)("p",null,"Returns nodes in a depth-first-search pre-ordering starting at source."),(0,i.kt)("h4",{id:"input-15"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"source: Vertex")," \u27a1  Specify starting node for depth-first search and return nodes in the component reachable from this node."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"depth_limit: integer (default=NULL)")," \u27a1  Specify the maximum search depth.")),(0,i.kt)("h4",{id:"output-20"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"nodes: List[Vertex]")," \u27a1 A list of nodes in a depth-first-search pre-ordering.")),(0,i.kt)("h4",{id:"usage-20"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (source:Label)\nCALL nxalg.dfs_preorder_nodes(source, 10) YIELD *\nRETURN source, nodes AS preoder_nodes;\n")),(0,i.kt)("h3",{id:"dfs_successorssource-depth_limit"},(0,i.kt)("inlineCode",{parentName:"h3"},"dfs_successors(source, depth_limit)")),(0,i.kt)("p",null,"Returns a dictionary of successors in depth-first-search from source."),(0,i.kt)("h4",{id:"input-16"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"source: Vertex")," \u27a1  Specify starting node for depth-first search and return nodes in the component reachable from this node."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"depth_limit: integer (default=NULL)")," \u27a1  Specify the maximum search depth.")),(0,i.kt)("h4",{id:"output-21"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"node: Vertex")," \u27a1 Node to calculate successors"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"successors: List[Vertex]")," \u27a1 Successors of a given nodes")),(0,i.kt)("h4",{id:"usage-21"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (source:Label)\nCALL nxalg.dfs_successors(source, 5) YIELD *\nRETURN node, successors;\n")),(0,i.kt)("h3",{id:"dfs_treesource-depth_limit"},(0,i.kt)("inlineCode",{parentName:"h3"},"dfs_tree(source, depth_limit)")),(0,i.kt)("p",null,"Returns an oriented tree constructed from a depth-first-search from source."),(0,i.kt)("h4",{id:"input-17"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"source: Vertex")," \u27a1  Specify starting node for depth-first search."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"depth_limit: integer (default=NULL)")," \u27a1  Specify the maximum search depth.")),(0,i.kt)("h4",{id:"output-22"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"tree: List[Vertex]")," \u27a1 An oriented tree in a form of a list.")),(0,i.kt)("h4",{id:"usage-22"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (source:Label)\nCALL nxalg.dfs_tree(source, 7) YIELD *\nRETURN tree;\n")),(0,i.kt)("h3",{id:"diameter"},(0,i.kt)("inlineCode",{parentName:"h3"},"diameter()")),(0,i.kt)("p",null,"Returns the diameter of the graph ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),"."),(0,i.kt)("p",null,"The diameter is the maximum eccentricity."),(0,i.kt)("h4",{id:"output-23"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"diameter: integer")," \u27a1 Diameter of graph.")),(0,i.kt)("h4",{id:"usage-23"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.diameter() YIELD *\nRETURN diameter;\n")),(0,i.kt)("h3",{id:"dominance_frontiersstart"},(0,i.kt)("inlineCode",{parentName:"h3"},"dominance_frontiers(start)")),(0,i.kt)("p",null,"Returns the dominance frontiers of all nodes of a directed graph."),(0,i.kt)("p",null,"The ",(0,i.kt)("em",{parentName:"p"},"dominance frontier")," of a node ",(0,i.kt)("inlineCode",{parentName:"p"},"d")," is the set of all\nnodes such that ",(0,i.kt)("inlineCode",{parentName:"p"},"d")," dominates an immediate\npredecessor of a node, but ",(0,i.kt)("inlineCode",{parentName:"p"},"d")," does not strictly dominate that node."),(0,i.kt)("h4",{id:"input-18"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"start: Vertex")," \u27a1  The start node of dominance computation.")),(0,i.kt)("h4",{id:"output-24"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"node: Vertex")," \u27a1 Node to calculate frontier."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"frontier: List[Vertex]")," \u27a1 Dominance frontier for a given node.")),(0,i.kt)("h4",{id:"usage-24"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (source:Label)\nCALL nxalg.dominance_frontiers(source) YIELD *\nRETURN node, frontier;\n")),(0,i.kt)("h3",{id:"dominating_setstart"},(0,i.kt)("inlineCode",{parentName:"h3"},"dominating_set(start)")),(0,i.kt)("p",null,"Finds a dominating set for the graph ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),"."),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"dominating set")," for a graph with node set ",(0,i.kt)("inlineCode",{parentName:"p"},"V")," is a subset ",(0,i.kt)("inlineCode",{parentName:"p"},"D")," of\n",(0,i.kt)("inlineCode",{parentName:"p"},"V")," such that every node not in ",(0,i.kt)("inlineCode",{parentName:"p"},"D")," is adjacent to at least one\nmember of ",(0,i.kt)("inlineCode",{parentName:"p"},"D"),"."),(0,i.kt)("h4",{id:"input-19"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"start: Vertex")," \u27a1  Node to use as a starting point for the algorithm.")),(0,i.kt)("h4",{id:"output-25"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"dominating_set: List[Vertex]")," \u27a1 A dominating set for ",(0,i.kt)("inlineCode",{parentName:"li"},"G"),".")),(0,i.kt)("h4",{id:"usage-25"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (source:Label)\nCALL nxalg.dominating_set(source) YIELD *\nRETURN dominating_set;\n")),(0,i.kt)("h3",{id:"edge_bfssource-orientation"},(0,i.kt)("inlineCode",{parentName:"h3"},"edge_bfs(source, orientation)")),(0,i.kt)("p",null,"A directed, breadth-first-search of edges in ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),", beginning at ",(0,i.kt)("inlineCode",{parentName:"p"},"source"),"."),(0,i.kt)("p",null,"Return the edges of ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," in a breadth-first-search order continuing until\nall edges are generated."),(0,i.kt)("h4",{id:"input-20"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"source: Vertex")," \u27a1  The node from which the traversal begins. If ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", then a source is chosen arbitrarily and repeatedly until all edges from each node in the graph are searched."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"orientation: string (default=NULL)")," \u27a1  For directed graphs and directed multigraphs, edge traversals need not respect the original orientation of the edges. When set to \u2018reverse\u2019, every edge is traversed in the reverse direction. When set to \u2018ignore\u2019, every edge is treated as undirected. When set to \u2018original\u2019, every edge is treated as directed. In all three cases, the returned edge tuples add a last entry to indicate the direction in which that edge was traversed. If ",(0,i.kt)("inlineCode",{parentName:"li"},"orientation")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", the returned edge has no direction indicated. The direction is respected, but not reported.")),(0,i.kt)("h4",{id:"output-26"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"edges: List[Edges]")," \u27a1 A directed edge indicating the path taken by the breadth-first-search. For graphs, edge is of the form ",(0,i.kt)("inlineCode",{parentName:"li"},"(u, v)")," where ",(0,i.kt)("inlineCode",{parentName:"li"},"u")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"v")," are the tail and head of the edge as determined by the traversal. For multigraphs, edge is of the form ",(0,i.kt)("inlineCode",{parentName:"li"},"(u, v, key)"),", where ",(0,i.kt)("inlineCode",{parentName:"li"},"key")," is the key of the edge. When the graph is directed, then u and ",(0,i.kt)("inlineCode",{parentName:"li"},"v")," are always in the order of the actual directed edge. If ",(0,i.kt)("inlineCode",{parentName:"li"},"orientation")," is not ",(0,i.kt)("inlineCode",{parentName:"li"},"None")," then the edge tuple is extended to include the direction of traversal (\u2018forward\u2019 or \u2018reverse\u2019) on that edge.")),(0,i.kt)("h4",{id:"usage-26"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (source:Label)\nCALL nxalg.edge_bfs(source, 'ignore') YIELD *\nRETURN source, edges;\n")),(0,i.kt)("h3",{id:"edge_dfssource-orientation"},(0,i.kt)("inlineCode",{parentName:"h3"},"edge_dfs(source, orientation)")),(0,i.kt)("p",null,"A directed, depth-first-search of edges in ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),", beginning at ",(0,i.kt)("inlineCode",{parentName:"p"},"source"),"."),(0,i.kt)("p",null,"Return the edges of ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," in a depth-first-search order continuing until\nall edges are generated."),(0,i.kt)("h4",{id:"input-21"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"source: Vertex (default=NULL)")," \u27a1  The node from which the traversal begins. If ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", then a source is chosen arbitrarily and repeatedly until all edges from each node in the graph are searched."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"orientation: string (default=NULL)")," \u27a1  For directed graphs and directed multigraphs, edge traversals\nneed not respect the original orientation of the edges.\nWhen set to \u2018reverse\u2019, every edge is traversed in the reverse direction.\nWhen set to \u2018ignore\u2019, every edge is treated as undirected.\nWhen set to \u2018original\u2019, every edge is treated as directed.\nIn all three cases, the returned edge tuples add a last entry to\nindicate the direction in which that edge was traversed.\nIf ",(0,i.kt)("inlineCode",{parentName:"li"},"orientation")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", the returned edge has no direction indicated.\nThe direction is respected, but not reported.")),(0,i.kt)("h4",{id:"output-27"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"edges: List[Edge]")," \u27a1 A directed edge indicating the path taken by the depth-first traversal.\nFor graphs, edge is of the form ",(0,i.kt)("inlineCode",{parentName:"li"},"(u, v)")," where ",(0,i.kt)("inlineCode",{parentName:"li"},"u")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"v"),"\nare the tail and head of the edge as determined by the traversal.\nFor multigraphs, edge is of the form ",(0,i.kt)("inlineCode",{parentName:"li"},"(u, v, key)"),", where ",(0,i.kt)("inlineCode",{parentName:"li"},"key")," is\nthe key of the edge. When the graph is directed, then ",(0,i.kt)("inlineCode",{parentName:"li"},"u")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"v"),"\nare always in the order of the actual directed edge.\nIf ",(0,i.kt)("inlineCode",{parentName:"li"},"orientation")," is not ",(0,i.kt)("inlineCode",{parentName:"li"},"None")," then the edge tuple is extended to include\nthe direction of traversal (\u2018forward\u2019 or \u2018reverse\u2019) on that edge.")),(0,i.kt)("h4",{id:"usage-27"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (source:Label)\nCALL nxalg.edge_dfs(source, 'original') YIELD *\nRETURN source, edges;\n")),(0,i.kt)("h3",{id:"find_cliques"},(0,i.kt)("inlineCode",{parentName:"h3"},"find_cliques()")),(0,i.kt)("p",null,"Returns all maximal cliques in an undirected graph."),(0,i.kt)("p",null,"For each node ",(0,i.kt)("inlineCode",{parentName:"p"},"v"),", a ",(0,i.kt)("em",{parentName:"p"},"maximal clique")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," is the largest complete\nsubgraph containing ",(0,i.kt)("inlineCode",{parentName:"p"},"v"),". The largest maximal clique is sometimes\ncalled the ",(0,i.kt)("em",{parentName:"p"},"maximum clique"),"."),(0,i.kt)("p",null,"This function returns an iterator over cliques, each of which is a\nlist of nodes. It is an iterative implementation, so should not\nsuffer from recursion depth issues."),(0,i.kt)("h4",{id:"output-28"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cliques: List[List[Vertex]]")," \u27a1 An iterator over maximal cliques, each of which is a list of\nnodes in ",(0,i.kt)("inlineCode",{parentName:"li"},"G"),". The order of cliques is arbitrary.")),(0,i.kt)("h4",{id:"usage-28"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.find_cliques() YIELD *\nRETURN cliques;\n")),(0,i.kt)("h3",{id:"find_cyclesource-orientation"},(0,i.kt)("inlineCode",{parentName:"h3"},"find_cycle(source, orientation)")),(0,i.kt)("p",null,"Returns a cycle found via depth-first traversal."),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"cycle")," is a closed path in the graph.\nThe orientation of directed edges is determined by ",(0,i.kt)("inlineCode",{parentName:"p"},"orientation"),"."),(0,i.kt)("h4",{id:"input-22"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"source: List[Vertex] (default=NULL)")," \u27a1  The node from which the traversal begins. If ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", then a source is chosen arbitrarily and repeatedly until all edges from each node in the graph are searched."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"orientation: string (default=NULL)")," \u27a1  For directed graphs and directed multigraphs, edge traversals\nneed not respect the original orientation of the edges. When set to \u2018reverse\u2019 every edge is traversed in the reverse direction. When set to \u2018ignore\u2019, every edge is treated as undirected. When set to \u2018original\u2019, every edge is treated as directed. In all three cases, the yielded edge tuples add a last entry to indicate the direction in which that edge was traversed. If ",(0,i.kt)("inlineCode",{parentName:"li"},"orientation")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", the yielded edge has no direction indicated. The direction is respected, but not reported.")),(0,i.kt)("h4",{id:"output-29"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"   ")," \u27a1 A list of directed edges indicating the path taken for the loop. If no cycle is found, then an exception is raised. For graphs, an edge is of the form ",(0,i.kt)("inlineCode",{parentName:"li"},"(u, v)")," where ",(0,i.kt)("inlineCode",{parentName:"li"},"u")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"v")," are the tail and the head of the edge as determined by the traversal. For multigraphs, an edge is of the form ",(0,i.kt)("inlineCode",{parentName:"li"},"(u, v, key)"),", where ",(0,i.kt)("inlineCode",{parentName:"li"},"key")," is the key of the edge. When the graph is directed, then ",(0,i.kt)("inlineCode",{parentName:"li"},"u")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"v")," are always in the order of the actual directed edge. If ",(0,i.kt)("inlineCode",{parentName:"li"},"orientation")," is not ",(0,i.kt)("inlineCode",{parentName:"li"},"None")," then the edge tuple is extended to include the direction of traversal (\u2018forward\u2019 or \u2018reverse\u2019) on that edge.")),(0,i.kt)("h4",{id:"usage-29"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (source:Label)\nCALL nxalg.find_cycle(source) YIELD *\nRETURN source, edges;\n")),(0,i.kt)("h3",{id:"flow_hierarchyweight"},(0,i.kt)("inlineCode",{parentName:"h3"},"flow_hierarchy(weight)")),(0,i.kt)("p",null,"Returns the flow hierarchy of a directed network."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Flow hierarchy")," is defined as the fraction of edges not participating in cycles in a directed graph."),(0,i.kt)("h4",{id:"input-23"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"weight: string (default=NULL)")," \u27a1  Attribute to use for node weights. If ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", the weight defaults to 1.")),(0,i.kt)("h4",{id:"output-30"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"flow_hierarchy: double")," \u27a1  Flow hierarchy value.")),(0,i.kt)("h4",{id:"usage-30"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.flow_hierarchy() YIELD *\nRETURN flow_hierarchy;\n")),(0,i.kt)("h3",{id:"global_efficiency"},(0,i.kt)("inlineCode",{parentName:"h3"},"global_efficiency()")),(0,i.kt)("p",null,"Returns the average global efficiency of the graph. The ",(0,i.kt)("em",{parentName:"p"},"efficiency")," of a pair of nodes in a graph is the multiplicative inverse of the shortest path distance between the nodes. The ",(0,i.kt)("em",{parentName:"p"},"average global efficiency")," of a graph is the average efficiency of all pairs of nodes."),(0,i.kt)("h4",{id:"output-31"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"global_efficiency: double")," \u27a1  The average global efficiency of the graph.")),(0,i.kt)("h4",{id:"usage-31"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.global_efficiency() YIELD *\nRETURN global_efficiency;\n")),(0,i.kt)("h3",{id:"greedy_colorstrategy-interchange"},(0,i.kt)("inlineCode",{parentName:"h3"},"greedy_color(strategy, interchange)")),(0,i.kt)("p",null,"Color a graph using various strategies of greedy graph coloring. Attempts to color a graph using as few colors as possible, where no neighbors of a node can have the same color as the node itself. The given strategy determines the order in which nodes are colored."),(0,i.kt)("h4",{id:"input-24"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"strategy")," \u27a1  The parameter ",(0,i.kt)("inlineCode",{parentName:"li"},"function(G,colors)")," is a function (or a string representing a function) that provides the coloring strategy, by returning nodes in the order they should be colored. ",(0,i.kt)("inlineCode",{parentName:"li"},"G")," is the graph, and ",(0,i.kt)("inlineCode",{parentName:"li"},"colors")," is a dictionary of the currently assigned colors, keyed by nodes. The function must return an iterable over all the nodes in ",(0,i.kt)("inlineCode",{parentName:"li"},"G"),". If the strategy function is an iterator generator (a function with\n",(0,i.kt)("inlineCode",{parentName:"li"},"yield")," statements), keep in mind that the ",(0,i.kt)("inlineCode",{parentName:"li"},"colors")," dictionary will be updated after each ",(0,i.kt)("inlineCode",{parentName:"li"},"yield"),", since this function chooses colors greedily. If ",(0,i.kt)("inlineCode",{parentName:"li"},"strategy")," is a string, it must be one of the following, each of which represents one of the built-in strategy functions.\n",(0,i.kt)("inlineCode",{parentName:"li"},"'largest_first'"),(0,i.kt)("inlineCode",{parentName:"li"},"'random_sequential'"),(0,i.kt)("inlineCode",{parentName:"li"},"'smallest_last'"),(0,i.kt)("inlineCode",{parentName:"li"},"'independent_set'"),(0,i.kt)("inlineCode",{parentName:"li"},"'connected_sequential_bfs'"),(0,i.kt)("inlineCode",{parentName:"li"},"'connected_sequential_dfs'"),(0,i.kt)("inlineCode",{parentName:"li"},"'connected_sequential'")," (alias for the previous strategy)\n",(0,i.kt)("inlineCode",{parentName:"li"},"'saturation_largest_first'"),(0,i.kt)("inlineCode",{parentName:"li"},"'DSATUR'")," (alias for the previous strategy)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"interchange: boolean (default=False)")," \u27a1  Will use the color interchange algorithm if set to ",(0,i.kt)("inlineCode",{parentName:"li"},"True"),". Note that ",(0,i.kt)("inlineCode",{parentName:"li"},"saturation_largest_first")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"independent_set")," do not work with interchange. Furthermore, if you use interchange with your own strategy function, you cannot rely on the values in the ",(0,i.kt)("inlineCode",{parentName:"li"},"colors")," argument.")),(0,i.kt)("h4",{id:"output-32"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"node: Vertex")," \u27a1 Vertex to color."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"color: integer")," \u27a1 Color index of a certain node.")),(0,i.kt)("h4",{id:"usage-32"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.greedy_color('connected_sequential_bfs') YIELD *\nRETURN node, color;\n")),(0,i.kt)("h3",{id:"has_eulerian_path"},(0,i.kt)("inlineCode",{parentName:"h3"},"has_eulerian_path()")),(0,i.kt)("p",null," An ",(0,i.kt)("em",{parentName:"p"},"Eulerian path")," is a path in a graph that uses each edge of a graph exactly once.\nA directed graph has an Eulerian path if:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"at most one vertex has ",(0,i.kt)("inlineCode",{parentName:"li"},"out_degree - in_degree = 1"),","),(0,i.kt)("li",{parentName:"ul"},"at most one vertex has ",(0,i.kt)("inlineCode",{parentName:"li"},"in_degree - out_degree = 1"),","),(0,i.kt)("li",{parentName:"ul"},"every other vertex has equal in_degree and out_degree,"),(0,i.kt)("li",{parentName:"ul"},"and all of its vertices with nonzero degree belong to a single connected component of the underlying undirected graph.\nAn undirected graph has an Eulerian path if exactly zero or two vertices have an odd degree and all of its vertices with nonzero degrees belong to a single connected component.")),(0,i.kt)("h4",{id:"output-33"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"has_eulerian_path: boolean")," \u27a1 ",(0,i.kt)("inlineCode",{parentName:"li"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"li"},"G")," has an eulerian path.")),(0,i.kt)("h4",{id:"usage-33"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.has_eulerian_path() YIELD *\nRETURN has_eulerian_path;\n")),(0,i.kt)("h3",{id:"has_pathsource-target"},(0,i.kt)("inlineCode",{parentName:"h3"},"has_path(source, target)")),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," has a path from ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"target"),"."),(0,i.kt)("h4",{id:"input-25"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"source: Vertex")," \u27a1  Starting node for the path."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"target: Vertex")," \u27a1  Ending node for the path.")),(0,i.kt)("h4",{id:"output-34"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"has_path: boolean")," \u27a1  ",(0,i.kt)("inlineCode",{parentName:"li"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"li"},"G")," has a path from ",(0,i.kt)("inlineCode",{parentName:"li"},"source")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"target"),".")),(0,i.kt)("h4",{id:"usage-34"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (n:Label), (m:Label)\nCALL nxalg.has_path(n, m) YIELD *\nRETURN has_path;\n")),(0,i.kt)("h3",{id:"immediate_dominatorsstart"},(0,i.kt)("inlineCode",{parentName:"h3"},"immediate_dominators(start)")),(0,i.kt)("p",null,"Returns the immediate dominators of all nodes of a directed graph. The immediate dominator of a node is the unique node that Strictly dominates a node ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," but does not strictly dominate any other node That dominates ",(0,i.kt)("inlineCode",{parentName:"p"},"n"),"."),(0,i.kt)("h4",{id:"input-26"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"start: Vertex")," \u27a1  The start node of dominance computation.")),(0,i.kt)("h4",{id:"output-35"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"node: Vertex")," \u27a1  Vertex to calculate dominator for."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"dominator: Vertex")," \u27a1  Dominator node for certain vertex.")),(0,i.kt)("h4",{id:"usage-35"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (n:Label)\nCALL nxalg.immediate_dominators(n) YIELD *\nRETURN node, dominator;\n")),(0,i.kt)("h3",{id:"is_arborescence"},(0,i.kt)("inlineCode",{parentName:"h3"},"is_arborescence()")),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is an arborescence. An ",(0,i.kt)("em",{parentName:"p"},"arborescence")," is a directed tree with maximum in-degree equal to 1."),(0,i.kt)("h4",{id:"output-36"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"is_arborescence: boolean")," \u27a1  A boolean that is ",(0,i.kt)("inlineCode",{parentName:"li"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"li"},"G")," is an arborescence.")),(0,i.kt)("h4",{id:"usage-36"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.is_arborescence() YIELD *\nRETURN is_arborescence;\n")),(0,i.kt)("h3",{id:"is_at_free"},(0,i.kt)("inlineCode",{parentName:"h3"},"is_at_free()")),(0,i.kt)("p",null,"Check if a graph is AT-free. The method uses the find_asteroidal_triple method to recognize an AT-free graph. If no asteroidal triple is found, the graph is AT-free and ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," is returned. If at least one asteroidal triple is found, the graph is not AT-free and ",(0,i.kt)("inlineCode",{parentName:"p"},"False")," is returned."),(0,i.kt)("h4",{id:"output-37"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"is_at_free: boolean")," \u27a1  ",(0,i.kt)("inlineCode",{parentName:"li"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"li"},"G")," is AT-free and ",(0,i.kt)("inlineCode",{parentName:"li"},"False")," otherwise.")),(0,i.kt)("h4",{id:"usage-37"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.is_at_free() YIELD *\nRETURN is_at_free;\n")),(0,i.kt)("h3",{id:"is_bipartite"},(0,i.kt)("inlineCode",{parentName:"h3"},"is_bipartite()")),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," if graph ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is bipartite, ",(0,i.kt)("inlineCode",{parentName:"p"},"False")," if not. A ",(0,i.kt)("em",{parentName:"p"},"bipartite graph")," (or bigraph) is a graph whose vertices can be divided into two disjoint and independent sets ",(0,i.kt)("inlineCode",{parentName:"p"},"u")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," and such that every edge connects a vertex in ",(0,i.kt)("inlineCode",{parentName:"p"},"u")," one in ",(0,i.kt)("inlineCode",{parentName:"p"},"v"),"."),(0,i.kt)("h4",{id:"output-38"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"is_bipartite: boolean")," \u27a1  ",(0,i.kt)("inlineCode",{parentName:"li"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"li"},"G")," is bipartite and ",(0,i.kt)("inlineCode",{parentName:"li"},"False")," otherwise.")),(0,i.kt)("h4",{id:"usage-38"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.is_bipartite() YIELD *\nRETURN is_bipartite;\n")),(0,i.kt)("h3",{id:"is_branching"},(0,i.kt)("inlineCode",{parentName:"h3"},"is_branching()")),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is a branching. A ",(0,i.kt)("em",{parentName:"p"},"branching")," is a directed forest with maximum in-degree equal to 1."),(0,i.kt)("h4",{id:"output-39"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"is_branching: boolean")," \u27a1   A boolean that is ",(0,i.kt)("inlineCode",{parentName:"li"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"li"},"G")," is a branching.")),(0,i.kt)("h4",{id:"usage-39"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.is_branching() YIELD *\nRETURN is_branching;\n")),(0,i.kt)("h3",{id:"is_chordal"},(0,i.kt)("inlineCode",{parentName:"h3"},"is_chordal()")),(0,i.kt)("p",null,"Checks whether ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is a chordal graph. A graph is ",(0,i.kt)("em",{parentName:"p"},"chordal")," if every cycle of length at least 4 has a chord (an edge joining two nodes not adjacent in the cycle)."),(0,i.kt)("h4",{id:"output-40"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"is_chordal: boolean")," \u27a1  ",(0,i.kt)("inlineCode",{parentName:"li"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"li"},"G")," is a chordal graph and ",(0,i.kt)("inlineCode",{parentName:"li"},"False")," otherwise.")),(0,i.kt)("h4",{id:"usage-40"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.is_chordal() YIELD *\nRETURN is_chordal;\n")),(0,i.kt)("h3",{id:"is_distance_regular"},(0,i.kt)("inlineCode",{parentName:"h3"},"is_distance_regular()")),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," if the graph is distance regular, ",(0,i.kt)("inlineCode",{parentName:"p"},"False")," otherwise. A connected graph ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is distance-regular if for any nodes ",(0,i.kt)("inlineCode",{parentName:"p"},"x,y")," and any integers ",(0,i.kt)("inlineCode",{parentName:"p"},"i,j=0,1,...,d")," (where ",(0,i.kt)("inlineCode",{parentName:"p"},"d")," is the graph diameter), the number of vertices at distance ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," from ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and distance ",(0,i.kt)("inlineCode",{parentName:"p"},"j")," from ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," depends only on ",(0,i.kt)("inlineCode",{parentName:"p"},"i,j")," and the graph distance between ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),", independently of the choice of ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"."),(0,i.kt)("h4",{id:"output-41"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"is_distance_regular: boolean")," \u27a1  ",(0,i.kt)("inlineCode",{parentName:"li"},"True")," if the graph is Distance Regular, ",(0,i.kt)("inlineCode",{parentName:"li"},"False")," otherwise.")),(0,i.kt)("h4",{id:"usage-41"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.is_distance_regular() YIELD *\nRETURN is_distance_regular;\n")),(0,i.kt)("h3",{id:"is_edge_covercover"},(0,i.kt)("inlineCode",{parentName:"h3"},"is_edge_cover(cover)")),(0,i.kt)("p",null,"Decides whether a set of edges is a valid edge cover of the graph. Given a set of edges, it can be decided whether the set is an ",(0,i.kt)("em",{parentName:"p"},"edge covering")," if checked whether all nodes of the graph have an edge from the set incident on it."),(0,i.kt)("h4",{id:"input-27"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cover: List[Edge]")," \u27a1   A list of edges to be checked.")),(0,i.kt)("h4",{id:"output-42"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"is_edge_cover: boolean")," \u27a1  Whether the set of edges is a valid edge cover of the graph.")),(0,i.kt)("h4",{id:"usage-42"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (n)-[e]-(m)\nWITH COLLECT(e) AS cover\nCALL nxalg.is_edge_cover(cover) YIELD *\nRETURN is_edge_cover;\n")),(0,i.kt)("h3",{id:"is_eulerian"},(0,i.kt)("inlineCode",{parentName:"h3"},"is_eulerian()")),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," if and only if ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is Eulerian. A graph is ",(0,i.kt)("em",{parentName:"p"},"Eulerian")," if it has an Eulerian circuit. An ",(0,i.kt)("em",{parentName:"p"},"Eulerian circuit")," is a closed walk that includes each edge of a graph exactly once."),(0,i.kt)("h4",{id:"output-43"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"is_eulerian: boolean")," \u27a1  ",(0,i.kt)("inlineCode",{parentName:"li"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"li"},"G")," is Eulerian.")),(0,i.kt)("h4",{id:"usage-43"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.is_eulerian() YIELD *\nRETURN is_eulerian;\n")),(0,i.kt)("h3",{id:"is_forest"},(0,i.kt)("inlineCode",{parentName:"h3"},"is_forest()")),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is a forest. A ",(0,i.kt)("em",{parentName:"p"},"forest")," is a graph with no undirected cycles.\nFor directed graphs, ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is a forest if the underlying graph is a forest. The underlying graph is obtained by treating each directed edge as a single undirected edge in a multigraph."),(0,i.kt)("h4",{id:"output-44"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"is_forest: boolean")," \u27a1  A boolean that is ",(0,i.kt)("inlineCode",{parentName:"li"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"li"},"G")," is a forest.")),(0,i.kt)("h4",{id:"usage-44"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.is_forest() YIELD *\nRETURN is_forest;\n")),(0,i.kt)("h3",{id:"is_isolaten"},(0,i.kt)("inlineCode",{parentName:"h3"},"is_isolate(n)")),(0,i.kt)("p",null,"Determines whether a node is an isolate.\nAn ",(0,i.kt)("em",{parentName:"p"},"isolate")," is a node with no neighbors (that is, with degree zero). For directed graphs, this means no in-neighbors and no out-neighbors."),(0,i.kt)("h4",{id:"input-28"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"n: Vertex")," \u27a1  A node in ",(0,i.kt)("inlineCode",{parentName:"li"},"G"),".")),(0,i.kt)("h4",{id:"output-45"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"is_isolate: boolean")," \u27a1  ",(0,i.kt)("inlineCode",{parentName:"li"},"True")," if and only if ",(0,i.kt)("inlineCode",{parentName:"li"},"n")," has no neighbors.")),(0,i.kt)("h4",{id:"usage-45"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (n)\nCALL nxalg.is_isolate(n) YIELD *\nRETURN is_isolate;\n")),(0,i.kt)("h3",{id:"is_isomorphicnodes1-edges1-nodes2-edges2"},(0,i.kt)("inlineCode",{parentName:"h3"},"is_isomorphic(nodes1, edges1, nodes2, edges2)")),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," if the graphs ",(0,i.kt)("inlineCode",{parentName:"p"},"G1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"G2")," are isomorphic and ",(0,i.kt)("inlineCode",{parentName:"p"},"False")," otherwise. The two graphs ",(0,i.kt)("inlineCode",{parentName:"p"},"G1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"G2")," must be the same type."),(0,i.kt)("h4",{id:"input-29"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"nodes1: List[Vertex]")," \u27a1  Nodes in ",(0,i.kt)("inlineCode",{parentName:"li"},"G1"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"edges1: List[Edge]")," \u27a1  Edges in ",(0,i.kt)("inlineCode",{parentName:"li"},"G1"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"nodes2: List[Vertex]")," \u27a1  Nodes in ",(0,i.kt)("inlineCode",{parentName:"li"},"G2"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"edges2: List[Edge]")," \u27a1   Edges in ",(0,i.kt)("inlineCode",{parentName:"li"},"G2"),".")),(0,i.kt)("h4",{id:"output-46"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"is_isomorphic: boolean")," \u27a1  ",(0,i.kt)("inlineCode",{parentName:"li"},"True")," if the graphs ",(0,i.kt)("inlineCode",{parentName:"li"},"G1")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"G2")," are isomorphic and ",(0,i.kt)("inlineCode",{parentName:"li"},"False")," otherwise.")),(0,i.kt)("h4",{id:"usage-46"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (n:Label1)-[e]-(), (r:Label2)-[f]-()\nWITH\nCOLLECT(n) AS nodes1\nCOLLECT(e) AS edges1\nCOLLECT(r) AS nodes2\nCOLLECT(f) AS edges2\nCALL nxalg.is_isomorphic(nodes1, edges1, nodes2, edges2) YIELD *\nRETURN is_isomorphic;\n")),(0,i.kt)("h3",{id:"is_semieulerian"},(0,i.kt)("inlineCode",{parentName:"h3"},"is_semieulerian()")),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is semi-Eulerian."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"G")," is semi-Eulerian if it has an Eulerian path but no Eulerian circuit."),(0,i.kt)("h4",{id:"output-47"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"is_semieulerian: boolean")," \u27a1  ",(0,i.kt)("inlineCode",{parentName:"li"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"li"},"G")," is semi-Eulerian.")),(0,i.kt)("h4",{id:"usage-47"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.is_semieulerian() YIELD *\nRETURN is_semieulerian;\n")),(0,i.kt)("h3",{id:"is_simple_pathnodes"},(0,i.kt)("inlineCode",{parentName:"h3"},"is_simple_path(nodes)")),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," if and only if the given nodes form a simple path in\n",(0,i.kt)("inlineCode",{parentName:"p"},"G"),".\nA ",(0,i.kt)("em",{parentName:"p"},"simple path")," in a graph is a nonempty sequence of nodes in which no node appears more than once in the sequence and each adjacent pair of nodes in the sequence is adjacent in the graph."),(0,i.kt)("h4",{id:"input-30"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"nodes: List[Vertex]")," \u27a1  A list of one or more nodes in the graph ",(0,i.kt)("inlineCode",{parentName:"li"},"G"),".")),(0,i.kt)("h4",{id:"output-48"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"is_simple_path: boolean")," \u27a1  Whether the given list of nodes represents a simple path in ",(0,i.kt)("inlineCode",{parentName:"li"},"G"),".")),(0,i.kt)("h4",{id:"usage-48"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (n:Label)\nWITH COLLECT(n) AS nodes\nCALL nxalg.is_simple_path(nodes) YIELD *\nRETURN is_simple_path;\n")),(0,i.kt)("h3",{id:"is_strongly_regular"},(0,i.kt)("inlineCode",{parentName:"h3"},"is_strongly_regular()")),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," if and only if the given graph is strongly regular.\nAn undirected graph is ",(0,i.kt)("em",{parentName:"p"},"strongly regular")," if:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"it is regular,")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"each pair of adjacent vertices has the same number of neighbors in common,")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"each pair of nonadjacent vertices has the same number of neighbors in common.\nEach strongly regular graph is a distance-regular graph. Conversely, if a distance-regular graph has a diameter of two, then it is a strongly regular graph.")),(0,i.kt)("h4",{id:"output-49"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"is_strongly_regular: boolean")," \u27a1   Whether ",(0,i.kt)("inlineCode",{parentName:"li"},"G")," is strongly regular.")),(0,i.kt)("h4",{id:"usage-49"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.is_strongly_regular() YIELD *\nRETURN is_strongly_regular;\n")),(0,i.kt)("h3",{id:"is_tournament"},(0,i.kt)("inlineCode",{parentName:"h3"},"is_tournament()")),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," if and only if ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is a tournament.\nA ",(0,i.kt)("em",{parentName:"p"},"tournament")," is a directed graph, with neither self-loops nor multi-edges, in which there is exactly one directed edge joining each pair of distinct nodes."),(0,i.kt)("h4",{id:"output-50"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"is_tournament: boolean")," \u27a1   Whether the given graph is a tournament graph.")),(0,i.kt)("h4",{id:"usage-50"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.is_tournament() YIELD *\nRETURN is_tournament;\n")),(0,i.kt)("h3",{id:"is_tree"},(0,i.kt)("inlineCode",{parentName:"h3"},"is_tree()")),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is a tree.\nA ",(0,i.kt)("em",{parentName:"p"},"tree")," is a connected graph with no undirected cycles.\nFor directed graphs, ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is a tree if the underlying graph is a tree. The underlying graph is obtained by treating each directed edge as a single undirected edge in a multigraph."),(0,i.kt)("h4",{id:"output-51"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"is_tree: boolean")," \u27a1   A boolean that is ",(0,i.kt)("inlineCode",{parentName:"li"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"li"},"G")," is a tree.")),(0,i.kt)("h4",{id:"usage-51"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.is_tree() YIELD *\nRETURN is_tree;\n")),(0,i.kt)("h3",{id:"isolates"},(0,i.kt)("inlineCode",{parentName:"h3"},"isolates()")),(0,i.kt)("p",null,"Returns a list of isolates in the graph.\nAn ",(0,i.kt)("em",{parentName:"p"},"isolate")," is a node with no neighbors (that is, with degree zero). For directed graphs, this means no in-neighbors and no out-neighbors."),(0,i.kt)("h4",{id:"output-52"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"isolates: List[Vertex]")," \u27a1   A list of isolates in ",(0,i.kt)("inlineCode",{parentName:"li"},"G"),".")),(0,i.kt)("h4",{id:"usage-52"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.isolates() YIELD *\nRETURN isolates;\n")),(0,i.kt)("h3",{id:"jaccard_coefficientebunch"},(0,i.kt)("inlineCode",{parentName:"h3"},"jaccard_coefficient(ebunch)")),(0,i.kt)("p",null,"Compute the Jaccard coefficient of all node pairs in ",(0,i.kt)("inlineCode",{parentName:"p"},"ebunch"),"."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Jaccard coefficient")," compares members of two sets to see which members are shared and which are distinct."),(0,i.kt)("h4",{id:"input-31"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ebunch: List[List[Vertex]] (default=NULL)")," \u27a1  Jaccard coefficient will be computed for each pair of nodes given in the iterable. The pairs must be given as 2-tuples\n",(0,i.kt)("inlineCode",{parentName:"li"},"(u, v)")," where ",(0,i.kt)("inlineCode",{parentName:"li"},"u")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"v")," are nodes in the graph. If ",(0,i.kt)("inlineCode",{parentName:"li"},"ebunch")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"None")," then all non-existent edges in the graph will be used.")),(0,i.kt)("h4",{id:"output-53"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"u: Vertex")," \u27a1  First node in pair."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"v: Vertex")," \u27a1  Second node in pair."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"coef: Vertex")," \u27a1  Jaccard coefficient.")),(0,i.kt)("h4",{id:"usage-53"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.jaccard_coefficient() YIELD *\nRETURN u, v, coef;\n")),(0,i.kt)("h3",{id:"k_clique_communitiesk-cliques"},(0,i.kt)("inlineCode",{parentName:"h3"},"k_clique_communities(k, cliques)")),(0,i.kt)("p",null,"Find k-clique communities in a graph using the percolation method.\nA ",(0,i.kt)("em",{parentName:"p"},"k-clique community")," is the union of all cliques of size ",(0,i.kt)("inlineCode",{parentName:"p"},"k")," that can be reached through adjacent (sharing ",(0,i.kt)("inlineCode",{parentName:"p"},"k-1")," nodes) k-cliques."),(0,i.kt)("h4",{id:"input-32"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"k: integer")," \u27a1  Size of the smallest clique."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cliques: List[List[Vertex]] (default=NULL)")," \u27a1  Precomputed cliques (use networkx.find_cliques(G)).")),(0,i.kt)("h4",{id:"output-54"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"communities: List[List[Vertex]]")," \u27a1   Sets of nodes, one for each k-clique community.")),(0,i.kt)("h4",{id:"usage-54"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.k_clique_communities(3) YIELD *\nRETURN communities;\n")),(0,i.kt)("h3",{id:"k_componentsdensity"},(0,i.kt)("inlineCode",{parentName:"h3"},"k_components(density)")),(0,i.kt)("p",null,"Returns the approximate k-component structure of a graph ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),".\nA ",(0,i.kt)("em",{parentName:"p"},"k-component")," is a maximal subgraph of a graph ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," that has, at least, node connectivity ",(0,i.kt)("inlineCode",{parentName:"p"},"k"),": we need to remove at least ",(0,i.kt)("inlineCode",{parentName:"p"},"k")," nodes to break it into more components. k-components have an inherent hierarchical structure because they are nested in terms of connectivity: a connected graph can contain several 2-components, each of which can contain one or more 3-components, and so forth.\nThis implementation is based on the fast heuristics to approximate the k-component structure of a graph. This, in turn, is based on a fast approximation algorithm for finding good lower bounds of the number of node independent paths between two nodes."),(0,i.kt)("h4",{id:"input-33"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"min_density: double (default=0.95)")," \u27a1   Density relaxation threshold.")),(0,i.kt)("h4",{id:"output-55"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"k: integer")," \u27a1  Connectivity level k"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"components: List[List[Vertex]]")," \u27a1  List of sets of nodes that form a k-component of level ",(0,i.kt)("inlineCode",{parentName:"li"},"k")," as values.")),(0,i.kt)("h4",{id:"usage-55"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.k_components(0.8) YIELD *\nRETURN k, components;\n")),(0,i.kt)("h3",{id:"k_edge_componentsk"},(0,i.kt)("inlineCode",{parentName:"h3"},"k_edge_components(k)")),(0,i.kt)("p",null,"Returns nodes in each maximal k-edge-connected component in ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),".\nA connected graph is ",(0,i.kt)("em",{parentName:"p"},"k-edge-connected")," if it remains connected whenever fewer than k edges are removed. The edge-connectivity of a graph is the largest k for which the graph is k-edge-connected."),(0,i.kt)("h4",{id:"input-34"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"k: integer")," \u27a1  Desired edge connectivity.")),(0,i.kt)("h4",{id:"output-56"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"components: List[List[Vertex]]")," \u27a1   A list of k-edge-ccs. Each set of returned nodes will have k-edge-connectivity in the graph ",(0,i.kt)("inlineCode",{parentName:"li"},"G"),".")),(0,i.kt)("h4",{id:"usage-56"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.k_edge_components(3) YIELD *\nRETURN components;\n")),(0,i.kt)("h3",{id:"local_efficiency"},(0,i.kt)("inlineCode",{parentName:"h3"},"local_efficiency()")),(0,i.kt)("p",null,"Returns the average local efficiency of the graph.\nThe ",(0,i.kt)("em",{parentName:"p"},"efficiency")," of a pair of nodes in a graph is the multiplicative inverse of the shortest path distance between the nodes. The ",(0,i.kt)("em",{parentName:"p"},"local efficiency")," of a node in the graph is the average global efficiency of the subgraph induced by the neighbors of the node. The ",(0,i.kt)("em",{parentName:"p"},"average local efficiency")," is the average of the local efficiencies of each node."),(0,i.kt)("h4",{id:"output-57"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"local_efficiency: double")," \u27a1   The average local efficiency of the graph.")),(0,i.kt)("h4",{id:"usage-57"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.local_efficiency() YIELD *\nRETURN local_efficiency;\n")),(0,i.kt)("h3",{id:"lowest_common_ancestornode1-node2"},(0,i.kt)("inlineCode",{parentName:"h3"},"lowest_common_ancestor(node1, node2)")),(0,i.kt)("p",null,"Compute the lowest common ancestor of the given pair of nodes."),(0,i.kt)("h4",{id:"input-35"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"node1: Vertex")," \u27a1  A node in the graph."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"node2: Vertex")," \u27a1  A node in the graph.")),(0,i.kt)("h4",{id:"output-58"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ancestor: Vertex")," \u27a1  The lowest common ancestor of ",(0,i.kt)("inlineCode",{parentName:"li"},"node1")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"node2"),", or default if they have no common ancestors.")),(0,i.kt)("h4",{id:"usage-58"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (n), (m)\nWHERE n != m\nCALL nxalg.local_efficiency(n, m) YIELD *\nRETURN n, m, ancestor;\n")),(0,i.kt)("h3",{id:"maximal_matching"},(0,i.kt)("inlineCode",{parentName:"h3"},"maximal_matching()")),(0,i.kt)("p",null," A ",(0,i.kt)("em",{parentName:"p"},"matching")," is a subset of edges in which no node occurs more than once. A ",(0,i.kt)("em",{parentName:"p"},"maximal matching")," cannot add more edges and still be a matching."),(0,i.kt)("h4",{id:"output-59"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"edges: List[Edge]")," \u27a1   A maximal matching of the graph.")),(0,i.kt)("h4",{id:"usage-59"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.maximal_matching() YIELD *\nRETURN edges;\n")),(0,i.kt)("h3",{id:"minimum_spanning_treeweight-algorithm-ignore_nan"},(0,i.kt)("inlineCode",{parentName:"h3"},"minimum_spanning_tree(weight, algorithm, ignore_nan)")),(0,i.kt)("p",null,"Returns a minimum spanning tree or forest on an undirected graph ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),".\nA ",(0,i.kt)("em",{parentName:"p"},"minimum spanning tree")," is a subset of the edges of a connected, undirected graph that connects all of the vertices together without any cycles."),(0,i.kt)("h4",{id:"input-36"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},'weight: string (default="weight")')," \u27a1  Data key to use for edge weights."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},'algorithm: string (default="kruskal")')," \u27a1  The algorithm to use when finding a minimum spanning tree. Valid choices are \u2018kruskal\u2019, \u2018prim\u2019, or \u2018boruvka\u2019."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ignore_nan: boolean (default=False)")," \u27a1  If ",(0,i.kt)("inlineCode",{parentName:"li"},"NaN")," is found as an edge weight normally an exception is raised. If ",(0,i.kt)("inlineCode",{parentName:"li"},"ignore_nan")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"True")," then that edge is ignored.")),(0,i.kt)("h4",{id:"output-60"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"node: List[Vertex]")," \u27a1  A minimum spanning tree or forest."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"edges: List[Edge]")," \u27a1  A minimum spanning tree or forest.")),(0,i.kt)("h4",{id:"usage-60"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},'CALL nxalg.minimum_spanning_tree("weight", "prim", TRUE) YIELD *\nRETURN node, edges;\n')),(0,i.kt)("h3",{id:"multi_source_dijkstra_pathsources-cutoff-weight"},(0,i.kt)("inlineCode",{parentName:"h3"},"multi_source_dijkstra_path(sources, cutoff, weight)")),(0,i.kt)("p",null,"Find shortest weighted paths in G from a given set of source nodes."),(0,i.kt)("p",null,"Compute shortest path between any of the source nodes and all other reachable nodes for a weighted graph."),(0,i.kt)("h4",{id:"input-37"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"sources: List[Vertex]")," \u27a1  Starting nodes for paths. If this is a set containing a single node, then all paths computed by this function will start from that node. If there are two or more nodes in the set, the computed paths may begin from any one of the start nodes."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cutoff: integer (default=NULL)")," \u27a1   Depth to stop the search. Only return paths with ",(0,i.kt)("inlineCode",{parentName:"li"},"length <= cutoff"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"weight: string")," \u27a1  If this is a string, then edge weights will be accessed via the edge attribute with this key (that is, the weight of the edge joining ",(0,i.kt)("inlineCode",{parentName:"li"},"u")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"v")," will be ",(0,i.kt)("inlineCode",{parentName:"li"},"G.edges[u, v][weight]"),"). If no such edge attribute exists, the weight of the edge is assumed to be one. If this is a function, the weight of an edge is the value returned by the function. The function must accept exactly three positional arguments: the two endpoints of an edge and the dictionary of edge attributes for that edge. The function must return a number.")),(0,i.kt)("h4",{id:"output-61"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"target: Vertex")," \u27a1 Target key for shortest path"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"path: List[Vertex]")," \u27a1  Shortest path in a list")),(0,i.kt)("h4",{id:"usage-61"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (n:Label)\nCOLLECT (n) AS sources\nCALL nxalg.multi_source_dijkstra_path(sources, 7) YIELD *\nRETURN target, path;\n")),(0,i.kt)("h3",{id:"multi_source_dijkstra_path_lengthsources-cutoff-weight"},(0,i.kt)("inlineCode",{parentName:"h3"},"multi_source_dijkstra_path_length(sources, cutoff, weight)")),(0,i.kt)("p",null,"Find shortest weighted path lengths in ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," from a given set of source nodes."),(0,i.kt)("p",null,"Compute the shortest path length between any of the source nodes and all other reachable nodes for a weighted graph."),(0,i.kt)("h4",{id:"input-38"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"sources: List[Vertex]")," \u27a1  Starting nodes for paths. If this is a set containing a single node, then all paths computed by this function will start from that node. If there are two or more nodes in the set, the computed paths may begin from any one of the start nodes."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cutoff: integer (default=NULL)")," \u27a1  Depth to stop the search. Only return paths with ",(0,i.kt)("inlineCode",{parentName:"li"},"length <= cutoff"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"weight: string")," \u27a1  If this is a string, then edge weights will be accessed via the edge attribute with this key (that is, the weight of the edge joining ",(0,i.kt)("inlineCode",{parentName:"li"},"u")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"v")," will be ",(0,i.kt)("inlineCode",{parentName:"li"},"G.edges[u, v][weight]"),"). If no such edge attribute exists, the weight of the edge is assumed to be one. If this is a function, the weight of an edge is the value returned by the function. The function must accept exactly three positional arguments: the two endpoints of an edge and the dictionary of edge attributes for that edge. The function must return a number.")),(0,i.kt)("h4",{id:"output-62"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"target: Vertex")," \u27a1 Target key for shortest path"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"length: double")," \u27a1  Shortest path length")),(0,i.kt)("h4",{id:"usage-62"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (n:Label)\nCOLLECT (n) AS sources\nCALL nxalg.multi_source_dijkstra_path_length(sources, 5) YIELD *\nRETURN target, length;\n")),(0,i.kt)("h3",{id:"node_boundarynbunch1-bunch2"},(0,i.kt)("inlineCode",{parentName:"h3"},"node_boundary(nbunch1, bunch2)")),(0,i.kt)("p",null,"Returns the node boundary of ",(0,i.kt)("inlineCode",{parentName:"p"},"nbunch1"),".\nThe ",(0,i.kt)("em",{parentName:"p"},"node boundary")," of a set ",(0,i.kt)("inlineCode",{parentName:"p"},"S")," with respect to a set ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," is the set of nodes ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," such that for some ",(0,i.kt)("inlineCode",{parentName:"p"},"u")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"S"),", there is an edge joining ",(0,i.kt)("inlineCode",{parentName:"p"},"u")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"v"),". If ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," is not specified, it is assumed to be the set of all nodes not in ",(0,i.kt)("inlineCode",{parentName:"p"},"S"),"."),(0,i.kt)("h4",{id:"input-39"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"nbunch1: List[Vertex]")," \u27a1  List of nodes in the graph representing the set of nodes whose node boundary will be returned. (This is the set ",(0,i.kt)("inlineCode",{parentName:"li"},"S")," from the definition above.)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"nbunch2: List[Vertex] (default=NULL)")," \u27a1  List of nodes representing the target (or \u201cexterior\u201d) set of nodes. (This is the set ",(0,i.kt)("inlineCode",{parentName:"li"},"T")," from the definition above.) If not specified, this is assumed to be the set of all nodes in ",(0,i.kt)("inlineCode",{parentName:"li"},"G")," not in ",(0,i.kt)("inlineCode",{parentName:"li"},"nbunch1"),".")),(0,i.kt)("h4",{id:"output-63"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"boundary: List[Vertex]")," \u27a1   The node boundary of ",(0,i.kt)("inlineCode",{parentName:"li"},"nbunch1")," with respect to ",(0,i.kt)("inlineCode",{parentName:"li"},"nbunch2"),".")),(0,i.kt)("h4",{id:"usage-63"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (n:Label)\nCOLLECT (n) AS sources1\nCALL nxalg.node_boundary(sources1) YIELD *\nRETURN boundary;\n")),(0,i.kt)("h3",{id:"node_connectivitysource-target"},(0,i.kt)("inlineCode",{parentName:"h3"},"node_connectivity(source, target)")),(0,i.kt)("p",null,"Returns an approximation for node connectivity for a graph or digraph ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),"."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Node connectivity")," is equal to the minimum number of nodes that must be removed to disconnect ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," or render it trivial. By Menger\u2019s theorem, this is equal to the number of node independent paths (paths that share no nodes other than ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"target"),").\nIf ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"target")," nodes are provided, this function returns the local node connectivity: the minimum number of nodes that must be removed to break all paths from source to ",(0,i.kt)("inlineCode",{parentName:"p"},"target")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),".\nThis algorithm is based on a fast approximation that gives a strict lower bound on the actual number of node independent paths between two nodes. It works for both directed and undirected graphs."),(0,i.kt)("h4",{id:"input-40"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"source: Vertex (default=NULL)")," \u27a1  Source node."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"target: Vertex (default=NULL)")," \u27a1  Target node.")),(0,i.kt)("h4",{id:"output-64"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"connectivity: integer")," \u27a1  Node connectivity of ",(0,i.kt)("inlineCode",{parentName:"li"},"G"),", or local node connectivity if ",(0,i.kt)("inlineCode",{parentName:"li"},"source")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"target")," are provided.")),(0,i.kt)("h4",{id:"usage-64"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (n:Label), (m:Label)\nCALL nxalg.node_connectivity(n, m) YIELD *\nRETURN connectivity;\n")),(0,i.kt)("h3",{id:"node_expansions"},(0,i.kt)("inlineCode",{parentName:"h3"},"node_expansion(s)")),(0,i.kt)("p",null,"Returns the node expansion of the set ",(0,i.kt)("inlineCode",{parentName:"p"},"S"),".\nThe ",(0,i.kt)("em",{parentName:"p"},"node expansion")," is the quotient of the size of the node boundary of ",(0,i.kt)("inlineCode",{parentName:"p"},"S")," and the cardinality of ",(0,i.kt)("inlineCode",{parentName:"p"},"S"),"."),(0,i.kt)("h4",{id:"input-41"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"s: List[Vertex]")," \u27a1  A sequence of nodes in ",(0,i.kt)("inlineCode",{parentName:"li"},"G"),".")),(0,i.kt)("h4",{id:"output-65"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"node_expansion: double")," \u27a1   The node expansion of the set ",(0,i.kt)("inlineCode",{parentName:"li"},"S"),".")),(0,i.kt)("h4",{id:"usage-65"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (n:Label)\nWITH COLLECT(n) AS s\nCALL nxalg.node_expansion(s) YIELD *\nRETURN node_expansion;\n")),(0,i.kt)("h3",{id:"non_randomnessk"},(0,i.kt)("inlineCode",{parentName:"h3"},"non_randomness(k)")),(0,i.kt)("p",null,"Compute the non-randomness of graph ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),".\nThe first returned value ",(0,i.kt)("inlineCode",{parentName:"p"},"non_randomness")," is the sum of non-randomness values of all edges within the graph (where the non-randomness of an edge tends to be small when the two nodes linked by that edge are from two different communities).\nThe second computed value ",(0,i.kt)("inlineCode",{parentName:"p"},"relative_non_randomness")," is a relative measure that indicates to what extent graph ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is different from random graphs in terms of probability. When it is close to 0, the graph tends to be more likely generated by an Erdos Renyi model."),(0,i.kt)("h4",{id:"input-42"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"k: integer (default=NULL)")," \u27a1  The number of communities in ",(0,i.kt)("inlineCode",{parentName:"li"},"G"),". If ",(0,i.kt)("inlineCode",{parentName:"li"},"k")," is not set, the function will use a default community detection algorithm to set it.")),(0,i.kt)("h4",{id:"output-66"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"non_randomness: double")," \u27a1  Non-randomness of a graph"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"relative_non_randomness: double")," \u27a1  Relative non-randomness of a graph")),(0,i.kt)("h4",{id:"usage-66"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.non_randomness() YIELD *\nRETURN non_randomness, relative_non_randomness;\n")),(0,i.kt)("h3",{id:"pagerankalpha-personalization-max_iter-tol-nstart-weight-dangling"},(0,i.kt)("inlineCode",{parentName:"h3"},"pagerank(alpha, personalization, max_iter, tol, nstart, weight, dangling)")),(0,i.kt)("p",null,"Returns the PageRank of the nodes in the graph."),(0,i.kt)("p",null,"PageRank computes a ranking of the nodes in the graph G based on the structure of the incoming links. It was originally designed as an algorithm to rank web pages."),(0,i.kt)("h4",{id:"input-43"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"alpha: double (default=0.85)")," \u27a1  Damping parameter for PageRank."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"personalization: string (default=NULL)")," \u27a1  The \u201cpersonalization vector\u201d consisting of a dictionary with a subset of graph nodes as a key and maps personalization value for each subset. At least one personalization value must be non-zero. If not specified, a nodes personalization value will be zero. By default, a uniform distribution is used."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"max_iter: integer (default=100)")," \u27a1  Maximum number of iterations in power method eigenvalue solver."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"tol: double (default=1e-06)")," \u27a1  Error tolerance used to check convergence in power method solver."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"nstart: string (default=NULL)")," \u27a1 Starting value of PageRank iteration for each node."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},'weight: string (default="weight")')," \u27a1  Edge data key to use as weight. If ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", weights are set to 1."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"dangling: string (default=NULL)")," \u27a1  The outedges to be assigned to any \u201cdangling\u201d nodes, i.e., nodes without any outedges. The dict key is the node the outedge points to and the dict value is the weight of that outedge. By default, dangling nodes are given outedges according to the personalization vector (uniform if not specified). This must be selected to result in an irreducible transition matrix. It may be common to have the dangling dict to be the same as the personalization dict.")),(0,i.kt)("h4",{id:"output-67"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"node: Vertex")," \u27a1 Vertex to calculate PageRank for."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"rank: double")," \u27a1 Node PageRank.")),(0,i.kt)("h4",{id:"usage-67"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.pagerank() YIELD *\nRETURN node, rank;\n")),(0,i.kt)("h3",{id:"reciprocitynodes"},(0,i.kt)("inlineCode",{parentName:"h3"},"reciprocity(nodes)")),(0,i.kt)("p",null,"Compute the reciprocity in a directed graph.\nThe ",(0,i.kt)("em",{parentName:"p"},"reciprocity")," of a directed graph is defined as the ratio of the number of edges pointing in both directions to the total number of edges in the graph.\nThe reciprocity of a single node ",(0,i.kt)("inlineCode",{parentName:"p"},"u")," is defined similarly, it is the ratio of the number of edges in both directions to the total number of edges attached to node ",(0,i.kt)("inlineCode",{parentName:"p"},"u"),"."),(0,i.kt)("h4",{id:"input-44"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"nodes: List[Vertex]")," \u27a1  Compute reciprocity for nodes in this container.")),(0,i.kt)("h4",{id:"output-68"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"node: Vertex")," \u27a1 Node to calculate reciprocity."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"reciprocity: double")," \u27a1 Reciprocity value")),(0,i.kt)("h4",{id:"usage-68"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH(n:Label)\nWITH COLLECT(n) AS nodes\nCALL nxalg.reciprocity(nodes) YIELD *\nRETURN node, reciprocity;\n")),(0,i.kt)("h3",{id:"shortest_pathsource-target-weight-method"},(0,i.kt)("inlineCode",{parentName:"h3"},"shortest_path(source, target, weight, method)")),(0,i.kt)("p",null,"Compute shortest paths in the graph."),(0,i.kt)("h4",{id:"input-45"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"source: Vertex (default=NULL)")," \u27a1  Starting node for the path. If not specified, compute shortest path lengths using all nodes as source nodes."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"target: Vertex (default=NULL)")," \u27a1  Ending node for the path. If not specified, compute shortest path lengths using all nodes as target nodes."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"weight: string (default=NULL)")," \u27a1  If ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", every edge has weight/distance/cost 1. If a string, use this edge attribute as the edge weight. Any edge attribute not present defaults to 1."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},'method: string (default="dijkstra")')," \u27a1  The algorithm to use to compute the path length. Supported options: \u2018dijkstra\u2019, \u2018bellman-ford\u2019. Other inputs produce a ValueError. If ",(0,i.kt)("inlineCode",{parentName:"li"},"weight")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", unweighted graph methods are used and this suggestion is ignored.")),(0,i.kt)("h4",{id:"output-69"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"source: Vertex")," \u27a1   Source node."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"target: Vertex")," \u27a1   Target node."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"path: List[Vertex]")," \u27a1   All returned paths include both the ",(0,i.kt)("inlineCode",{parentName:"li"},"source")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"target")," in the path. If the ",(0,i.kt)("inlineCode",{parentName:"li"},"source")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"target")," are both specified, return a single list of nodes in a shortest path from the ",(0,i.kt)("inlineCode",{parentName:"li"},"source")," to the ",(0,i.kt)("inlineCode",{parentName:"li"},"target"),". If only the ",(0,i.kt)("inlineCode",{parentName:"li"},"source")," is specified, return a dictionary keyed by targets with a list of nodes in a shortest path from the ",(0,i.kt)("inlineCode",{parentName:"li"},"source")," to one of the targets. If only the ",(0,i.kt)("inlineCode",{parentName:"li"},"target")," is specified, return a dictionary keyed by sources with a list of nodes in a shortest path from one of the sources to the ",(0,i.kt)("inlineCode",{parentName:"li"},"target"),". If neither the ",(0,i.kt)("inlineCode",{parentName:"li"},"source")," nor ",(0,i.kt)("inlineCode",{parentName:"li"},"target")," are specified return a dictionary of dictionaries with ",(0,i.kt)("inlineCode",{parentName:"li"},"path[source][target]=[list of nodes in path]"),".")),(0,i.kt)("h4",{id:"usage-69"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (n:Label), (m:Label)\nCALL nxalg.shortest_path(n, m) YIELD *\nRETURN source, target, path;\n")),(0,i.kt)("h3",{id:"shortest_path_lengthsource-target-weight-method"},(0,i.kt)("inlineCode",{parentName:"h3"},"shortest_path_length(source, target, weight, method)")),(0,i.kt)("p",null,"Compute shortest path lengths in the graph."),(0,i.kt)("h4",{id:"input-46"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"source: Vertex (default=NULL)")," \u27a1  Starting node for the path. If not specified, compute shortest path lengths using all nodes as source nodes."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"target: Vertex (default=NULL)")," \u27a1  Ending node for the path. If not specified, compute shortest path lengths using all nodes as target nodes."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"weight: string (default=NULL)")," \u27a1  If ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", every edge has weight/distance/cost 1. If a string, use this edge attribute as the edge weight. Any edge attribute not present defaults to 1."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},'method: string (default="dijkstra")')," \u27a1  The algorithm to use to compute the path length. Supported options: \u2018dijkstra\u2019, \u2018bellman-ford\u2019. Other inputs produce a ValueError. If ",(0,i.kt)("inlineCode",{parentName:"li"},"weight")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", unweighted graph methods are used and this suggestion is ignored.")),(0,i.kt)("h4",{id:"output-70"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"source: Vertex")," \u27a1   Source node."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"target: Vertex")," \u27a1   Target node."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"length: double")," \u27a1   If the ",(0,i.kt)("inlineCode",{parentName:"li"},"source")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"target")," are both specified, return the length of the shortest path from the ",(0,i.kt)("inlineCode",{parentName:"li"},"source")," to the ",(0,i.kt)("inlineCode",{parentName:"li"},"target"),". If only the ",(0,i.kt)("inlineCode",{parentName:"li"},"source")," is specified, return a dict keyed by ",(0,i.kt)("inlineCode",{parentName:"li"},"target")," to the shortest path length from the ",(0,i.kt)("inlineCode",{parentName:"li"},"source")," to that ",(0,i.kt)("inlineCode",{parentName:"li"},"target"),". If only the ",(0,i.kt)("inlineCode",{parentName:"li"},"target")," is specified, return a dict keyed by ",(0,i.kt)("inlineCode",{parentName:"li"},"source")," to the shortest path length from that ",(0,i.kt)("inlineCode",{parentName:"li"},"source")," to the ",(0,i.kt)("inlineCode",{parentName:"li"},"target"),". If neither the ",(0,i.kt)("inlineCode",{parentName:"li"},"source")," nor ",(0,i.kt)("inlineCode",{parentName:"li"},"target")," are specified, return an iterator over (source, dictionary) where dictionary is keyed by ",(0,i.kt)("inlineCode",{parentName:"li"},"target")," to shortest path length from ",(0,i.kt)("inlineCode",{parentName:"li"},"source")," to that ",(0,i.kt)("inlineCode",{parentName:"li"},"target"),".")),(0,i.kt)("h4",{id:"usage-70"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (n:Label), (m:Label)\nCALL nxalg.shortest_path_length(n, m) YIELD *\nRETURN source, target, length;\n")),(0,i.kt)("h3",{id:"simple_cycles"},(0,i.kt)("inlineCode",{parentName:"h3"},"simple_cycles()")),(0,i.kt)("p",null,"Find simple cycles (elementary circuits) of a directed graph.\nA ",(0,i.kt)("em",{parentName:"p"},"simple cycle"),", or ",(0,i.kt)("em",{parentName:"p"},"elementary circuit"),", is a closed path where no node appears twice. Two elementary circuits are distinct if they are not cyclic permutations of each other.\nThis is a nonrecursive, iterator/generator version of Johnson\u2019s algorithm. There may be better algorithms for some cases."),(0,i.kt)("h4",{id:"output-71"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cycles: List[List[Vertex]]")," \u27a1  A list of elementary cycles in the graph. Each cycle is represented by a list of nodes in the cycle.")),(0,i.kt)("h4",{id:"usage-71"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.simple_cycles() YIELD *\nRETURN cycles;\n")),(0,i.kt)("h3",{id:"strongly_connected_components"},(0,i.kt)("inlineCode",{parentName:"h3"},"strongly_connected_components()")),(0,i.kt)("p",null,"Returns nodes in strongly connected components of a graph."),(0,i.kt)("h4",{id:"output-72"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"components: List[List[Vertex]]")," \u27a1   A list of lists of nodes, one for each strongly connected component of ",(0,i.kt)("inlineCode",{parentName:"li"},"G"),".")),(0,i.kt)("h4",{id:"usage-72"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.strongly_connected_components() YIELD *\nRETURN components;\n")),(0,i.kt)("h3",{id:"topological_sort"},(0,i.kt)("inlineCode",{parentName:"h3"},"topological_sort()")),(0,i.kt)("p",null,"Returns nodes in topologically sorted order.\nA ",(0,i.kt)("em",{parentName:"p"},"topological sort")," is a non unique permutation of the nodes such that an edge from ",(0,i.kt)("inlineCode",{parentName:"p"},"u")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," implies that ",(0,i.kt)("inlineCode",{parentName:"p"},"u")," appears before ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," in the topological sort order."),(0,i.kt)("h4",{id:"output-73"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"nodes: List[Vertex]")," \u27a1   A list of nodes in topological sorted order.")),(0,i.kt)("h4",{id:"usage-73"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.topological_sort() YIELD *\nRETURN nodes;\n")),(0,i.kt)("h3",{id:"triadic_census"},(0,i.kt)("inlineCode",{parentName:"h3"},"triadic_census()")),(0,i.kt)("p",null,"Determines the triadic census of a directed graph. The ",(0,i.kt)("em",{parentName:"p"},"triadic census")," is a count of how many of the 16 possible types of triads are present in a directed graph."),(0,i.kt)("h4",{id:"output-74"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"triad: string")," \u27a1  Triad name."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"count: integer")," \u27a1  Number of occurrences as value.")),(0,i.kt)("h4",{id:"usage-74"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.triadic_census() YIELD *\nRETURN triad, count;\n")),(0,i.kt)("h3",{id:"voronoi_cellscenter_nodes-weight"},(0,i.kt)("inlineCode",{parentName:"h3"},"voronoi_cells(center_nodes, weight)")),(0,i.kt)("p",null,"Returns the Voronoi cells centered at center_nodes with respect to the shortest-path distance metric.\nIf ",(0,i.kt)("inlineCode",{parentName:"p"},"C")," is a set of nodes in the graph and ",(0,i.kt)("inlineCode",{parentName:"p"},"c")," is an element of ",(0,i.kt)("inlineCode",{parentName:"p"},"C"),", the ",(0,i.kt)("em",{parentName:"p"},"Voronoi cell")," centered at a node ",(0,i.kt)("inlineCode",{parentName:"p"},"c")," is the set of all nodes\n",(0,i.kt)("inlineCode",{parentName:"p"},"v")," that are closer to ",(0,i.kt)("inlineCode",{parentName:"p"},"c")," than to any other center node in ",(0,i.kt)("inlineCode",{parentName:"p"},"C")," with respect to the shortest-path distance metric.\nFor directed graphs, this will compute the \u201coutward\u201d Voronoi cells in which distance is measured from the center nodes to the target node."),(0,i.kt)("h4",{id:"input-47"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"center_nodes: List[Vertex]")," \u27a1  A nonempty set of nodes in the graph ",(0,i.kt)("inlineCode",{parentName:"li"},"G")," that represent the centers of the Voronoi cells."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"weight: string (default=NULL)")," \u27a1  The edge attribute (or an arbitrary function) representing the weight of an edge. This keyword argument is as described in the documentation for ",(0,i.kt)("inlineCode",{parentName:"li"},"networkx.multi_source_dijkstra_path"),", for example.")),(0,i.kt)("h4",{id:"output-75"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"center: Vertex")," \u27a1 Vertex value of center_nodes."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cell: List[Vertex]")," \u27a1  Partition of ",(0,i.kt)("inlineCode",{parentName:"li"},"G")," closer to that center node.")),(0,i.kt)("h4",{id:"usage-75"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (n)\nWITH COLLECT(n) AS center_nodes\nCALL nxalg.voronoi_cells(center_nodes) YIELD *\nRETURN center, cell;\n")),(0,i.kt)("h3",{id:"wiener_indexweight"},(0,i.kt)("inlineCode",{parentName:"h3"},"wiener_index(weight)")),(0,i.kt)("p",null,"Returns the Wiener index of the given graph.\nThe ",(0,i.kt)("em",{parentName:"p"},"Wiener index")," of a graph is the sum of the shortest-path distances between each pair of reachable nodes. For pairs of nodes in undirected graphs, only one orientation of the pair is counted."),(0,i.kt)("h4",{id:"input-48"},"Input:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"weight: string (default=NULL)")," \u27a1 The edge attribute to use as distance when computing shortest-path distances. This is passed directly to the\n",(0,i.kt)("inlineCode",{parentName:"li"},"networkx.shortest_path_length")," function.")),(0,i.kt)("h4",{id:"output-76"},"Output:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"wiener_index: double")," \u27a1  The Wiener index of the graph ",(0,i.kt)("inlineCode",{parentName:"li"},"G"),".")),(0,i.kt)("h4",{id:"usage-76"},"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL nxalg.voronoi_cells() YIELD *\nRETURN wiener_index;\n")))}c.isMDXComponent=!0},83523:(e,t,n)=>{n.d(t,{ZP:()=>r});var a=n(87462),i=(n(67294),n(3905));const l={toc:[]};function r(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"If you want to execute this algorithm on graph projections, subgraphs or portions\nof the graph, be sure to check out the guide on\n",(0,i.kt)("a",{parentName:"p",href:"/mage/how-to-guides/run-a-subgraph-module"},"How to run a MAGE module on subgraphs"),".")))}r.isMDXComponent=!0},85162:(e,t,n)=>{n.d(t,{Z:()=>r});var a=n(67294),i=n(86010);const l="tabItem_Ymn6";function r(e){let{children:t,hidden:n,className:r}=e;return a.createElement("div",{role:"tabpanel",className:(0,i.Z)(l,r),hidden:n},t)}},65488:(e,t,n)=>{n.d(t,{Z:()=>c});var a=n(87462),i=n(67294),l=n(86010),r=n(72389),o=n(67392),s=n(7094),d=n(12466);const u="tabList__CuJ",p="tabItem_LNqP";function h(e){var t;const{lazy:n,block:r,defaultValue:h,values:c,groupId:m,className:k}=e,g=i.Children.map(e.children,(e=>{if((0,i.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),N=c??g.map((e=>{let{props:{value:t,label:n,attributes:a}}=e;return{value:t,label:n,attributes:a}})),f=(0,o.l)(N,((e,t)=>e.value===t.value));if(f.length>0)throw new Error(`Docusaurus error: Duplicate values "${f.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const v=null===h?h:h??(null==(t=g.find((e=>e.props.default)))?void 0:t.props.value)??g[0].props.value;if(null!==v&&!N.some((e=>e.value===v)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${v}" but none of its children has the corresponding value. Available values are: ${N.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:C,setTabGroupChoices:_}=(0,s.U)(),[y,b]=(0,i.useState)(v),L=[],{blockElementScrollPositionUntilNextRender:w}=(0,d.o5)();if(null!=m){const e=C[m];null!=e&&e!==y&&N.some((t=>t.value===e))&&b(e)}const x=e=>{const t=e.currentTarget,n=L.indexOf(t),a=N[n].value;a!==y&&(w(t),b(a),null!=m&&_(m,String(a)))},T=e=>{var t;let n=null;switch(e.key){case"Enter":x(e);break;case"ArrowRight":{const t=L.indexOf(e.currentTarget)+1;n=L[t]??L[0];break}case"ArrowLeft":{const t=L.indexOf(e.currentTarget)-1;n=L[t]??L[L.length-1];break}}null==(t=n)||t.focus()};return i.createElement("div",{className:(0,l.Z)("tabs-container",u)},i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.Z)("tabs",{"tabs--block":r},k)},N.map((e=>{let{value:t,label:n,attributes:r}=e;return i.createElement("li",(0,a.Z)({role:"tab",tabIndex:y===t?0:-1,"aria-selected":y===t,key:t,ref:e=>L.push(e),onKeyDown:T,onClick:x},r,{className:(0,l.Z)("tabs__item",p,null==r?void 0:r.className,{"tabs__item--active":y===t})}),n??t)}))),n?(0,i.cloneElement)(g.filter((e=>e.props.value===y))[0],{className:"margin-top--md"}):i.createElement("div",{className:"margin-top--md"},g.map(((e,t)=>(0,i.cloneElement)(e,{key:t,hidden:e.props.value!==y})))))}function c(e){const t=(0,r.Z)();return i.createElement(h,(0,a.Z)({key:String(t)},e))}}}]);