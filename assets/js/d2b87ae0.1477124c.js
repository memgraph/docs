"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[91375],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=d(n),h=o,u=m["".concat(l,".").concat(h)]||m[h]||c[h]||r;return n?a.createElement(u,i(i({ref:t},p),{},{components:n})):a.createElement(u,i({ref:t},p))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var d=2;d<r;d++)i[d]=n[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2759:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>d});var a=n(87462),o=(n(67294),n(3905));const r={id:"storage-modes",title:"Storage modes",sidebar_label:"Storage modes"},i=void 0,s={unversionedId:"reference-guide/storage-modes",id:"version-2.10.0/reference-guide/storage-modes",title:"Storage modes",description:"Memgraph supports three different storage modes:",source:"@site/memgraph_versioned_docs/version-2.10.0/reference-guide/storage-modes.md",sourceDirName:"reference-guide",slug:"/reference-guide/storage-modes",permalink:"/docs/memgraph/2.10.0/reference-guide/storage-modes",draft:!1,editUrl:"https://github.com/memgraph/docs/tree/master/memgraph_versioned_docs/version-2.10.0/reference-guide/storage-modes.md",tags:[],version:"2.10.0",frontMatter:{id:"storage-modes",title:"Storage modes",sidebar_label:"Storage modes"},sidebar:"memgraph",previous:{title:"Server stats",permalink:"/docs/memgraph/2.10.0/reference-guide/server-stats"},next:{title:"Streams overview",permalink:"/docs/memgraph/2.10.0/reference-guide/streams"}},l={},d=[{value:"Switching storage modes",id:"switching-storage-modes",level:2},{value:"In-memory transactional storage mode (default)",id:"in-memory-transactional-storage-mode-default",level:2},{value:"In-memory analytical storage mode",id:"in-memory-analytical-storage-mode",level:2},{value:"Transactions",id:"transactions",level:3},{value:"WAL",id:"wal",level:3},{value:"Snapshots",id:"snapshots",level:3},{value:"On-disk transactional storage mode",id:"on-disk-transactional-storage-mode",level:2},{value:"Architecture",id:"architecture",level:3},{value:"MVCC",id:"mvcc",level:3},{value:"Isolation level",id:"isolation-level",level:3},{value:"Indices",id:"indices",level:3},{value:"Constraints",id:"constraints",level:3},{value:"Data formats",id:"data-formats",level:3},{value:"Durability",id:"durability",level:3},{value:"Memory control",id:"memory-control",level:3},{value:"Replication",id:"replication",level:3}],p={toc:d};function c(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Memgraph supports three different storage modes:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"IN_MEMORY_TRANSACTIONAL")," - the default database mode that favors\nstrongly-consistent ACID transactions using WAL files and snapshots,\nbut requires more time and resources during data import and analysis."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"IN_MEMORY_ANALYTICAL")," - speeds up import and data analysis but offers no ACID\nguarantees besides manually created snapshots."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ON_DISK_TRANSACTIONAL")," - supports ACID properties in the same way as ",(0,o.kt)("inlineCode",{parentName:"li"},"IN_MEMORY_TRANSACTIONAL"),"\nwith the additional ability to store data on disk (HDD or SSD) thus trading performance for lower costs. ",(0,o.kt)("strong",{parentName:"li"},"Experimental"))),(0,o.kt)("h2",{id:"switching-storage-modes"},"Switching storage modes"),(0,o.kt)("p",null,"You can switch between in-memory modes within a session using the following query:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cypher"},"STORAGE MODE IN_MEMORY_{TRANSACTIONAL|ANALYTICAL};\n")),(0,o.kt)("p",null,"When switching modes, Memgraph will wait until all other transactions are done.\nIf some other transactions are running in your system, you will receive a\nwarning message, so be sure to ",(0,o.kt)("a",{parentName:"p",href:"/docs/memgraph/2.10.0/reference-guide/configuration#other"},"set the log level to\n",(0,o.kt)("inlineCode",{parentName:"a"},"WARNING")),"."),(0,o.kt)("p",null,"Switching from the in-memory storage mode to the on-disk storage mode is allowed\nwhen there is only one active session and the database is empty. As Memgraph Lab\nuses multiple sessions to run queries in parallel, it is currently impossible to\nswitch to the on-disk storage mode within Memgraph Lab. You can change the\nstorage mode to on-disk transactional using ",(0,o.kt)("inlineCode",{parentName:"p"},"mgconsole"),", then connect to the\ninstance with Memgraph Lab and query the instance as usual."),(0,o.kt)("p",null,"To change the storage mode to ",(0,o.kt)("inlineCode",{parentName:"p"},"ON_DISK_TRANSACTIONAL"),", use the following query:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cypher"},"STORAGE MODE ON_DISK_TRANSACTIONAL;\n")),(0,o.kt)("p",null,"It is forbidden to change the storage mode from ",(0,o.kt)("inlineCode",{parentName:"p"},"ON_DISK_TRANSACTIONAL")," to any\nof the in-memory storage modes while there is data in the database as it might\nnot fit in the RAM. To change the storage mode to any of the in-memory storages,\nempty the instance and restart it. An empty database will start in the default\nstorage mode (in-memory transactional)."),(0,o.kt)("p",null,"If you are running the Memgraph Enterprise Edition, you need to have\n",(0,o.kt)("a",{parentName:"p",href:"/docs/memgraph/2.10.0/reference-guide/auth-module"},(0,o.kt)("inlineCode",{parentName:"a"},"STORAGE_MODE")," permission")," to change the\nstorage mode."),(0,o.kt)("p",null,"You can check the current storage mode using the following query:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cypher"},"SHOW STORAGE INFO;\n")),(0,o.kt)("p",null,"An empty instance will always restart in in-memory transactional storage mode.\nUpon restart, a non-empty instance in the on-disk storage mode will not change\nstorage mode, but the instance in an in-memory analytical storage mode will revert\nto the default in-memory transactional storage mode. "),(0,o.kt)("h2",{id:"in-memory-transactional-storage-mode-default"},"In-memory transactional storage mode (default)"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"IN_MEMORY_TRANSACTIONAL")," storage mode offers all ACID guarantees. WAL files and\nperiodic snapshots are created automatically, and you can also create snapshots\nmanually."),(0,o.kt)("p",null,"In the ",(0,o.kt)("inlineCode",{parentName:"p"},"IN_MEMORY_TRANSACTIONAL")," mode, Memgraph creates a\n",(0,o.kt)("a",{parentName:"p",href:"/memgraph/under-the-hood/storage#delta-memory-layout"},(0,o.kt)("inlineCode",{parentName:"a"},"Delta"))," object each time\ndata is changed. Deltas are the backbone upon which Memgraph provides atomicity,\nconsistency, isolation, and durability - ACID. By using ",(0,o.kt)("inlineCode",{parentName:"p"},"Deltas"),", Memgraph\ncreates ",(0,o.kt)("a",{parentName:"p",href:"/memgraph/reference-guide/backup#write-ahead-logging"},"write-ahead-logs"),"\nfor durability, provides isolation, consistency, and atomicity (by ensuring that\neverything is executed or nothing)."),(0,o.kt)("p",null,"Depending on the transaction ",(0,o.kt)("a",{parentName:"p",href:"/memgraph/reference-guide/transactions#isolation-levels"},"isolation\nlevel"),", other transactions may\nsee changes from other transactions."),(0,o.kt)("p",null,"In the transactional storage mode,\n",(0,o.kt)("a",{parentName:"p",href:"/memgraph/reference-guide/backup#snapshots"},"snapshots")," are created periodically\nor manually. They capture the database state and store it on the disk. A\nsnapshot is used to recover the database upon startup (depending on the setting\nof the configuration flag ",(0,o.kt)("inlineCode",{parentName:"p"},"--storage-recover-on-startup"),", which defaults to\n",(0,o.kt)("inlineCode",{parentName:"p"},"true"),")."),(0,o.kt)("p",null,"When Memgraph starts creating a periodic snapshot, it is not possible to\nmanually create a snapshot, until the periodic snapshot is created."),(0,o.kt)("p",null,"Manual snapshots are created by running the ",(0,o.kt)("inlineCode",{parentName:"p"},"CREATE SNAPSHOT;")," query."),(0,o.kt)("h2",{id:"in-memory-analytical-storage-mode"},"In-memory analytical storage mode"),(0,o.kt)("p",null,"In the transactional storage mode, Memgraph is fully ",(0,o.kt)("a",{parentName:"p",href:"/docs/memgraph/2.10.0/reference-guide/backup"},"ACID\ncompliant")," which could cause memory spikes during data\nimport because each time data is changed Memgraph creates\n",(0,o.kt)("a",{parentName:"p",href:"/memgraph/under-the-hood/storage#delta-memory-layout"},(0,o.kt)("inlineCode",{parentName:"a"},"Delta"))," objects to\nprovides atomicity, consistency, isolation, and durability"),(0,o.kt)("p",null,"But ",(0,o.kt)("inlineCode",{parentName:"p"},"Deltas")," also require a lot of memory (104B per change), especially when\nthere are a lot of changes  (for example, during import with the ",(0,o.kt)("inlineCode",{parentName:"p"},"LOAD CSV"),"\nclause). By switching the storage mode to ",(0,o.kt)("inlineCode",{parentName:"p"},"IN_MEMORY_ANALYTICAL")," mode disables\nthe creation of ",(0,o.kt)("inlineCode",{parentName:"p"},"Deltas")," thus drastically speeding up import with lower memory\nconsumption - up to 6 times faster import with 6 times less memory consumption."),(0,o.kt)("p",null,"If you want to enable ACID compliance, you can switch back to\n",(0,o.kt)("inlineCode",{parentName:"p"},"IN_MEMORY_TRANSACTIONAL")," and continue with regular work on the database or you\ncan take advantage of the low memory costs of the analytical mode to run\nanalytical queries that will not change the data, but be aware that no backup is\ncreated automatically, and there are no ACID guarantees besides manually created\nsnapshots. There are no ",(0,o.kt)("inlineCode",{parentName:"p"},"WAL")," files created nor periodic snapshots. Users\n",(0,o.kt)("strong",{parentName:"p"},"can")," create a snapshot manually."),(0,o.kt)("h3",{id:"transactions"},"Transactions"),(0,o.kt)("p",null,"In the analytical storage mode, there are no ACID guarantees and other\ntransactions can see the changes of ongoing transactions. Also, a ",(0,o.kt)("a",{parentName:"p",href:"/memgraph/reference-guide/transactions#isolation-levels"},"transaction\ncan see the changes it is\ndoing"),". This means that\nthe transactions can be committed in random orders, and the updates to the data,\nin the end, might not be correct."),(0,o.kt)("h3",{id:"wal"},"WAL"),(0,o.kt)("p",null,"As mentioned, no ",(0,o.kt)("a",{parentName:"p",href:"/memgraph/reference-guide/backup#write-ahead-logging"},"write-ahead\nlogs")," are created in the\n",(0,o.kt)("inlineCode",{parentName:"p"},"IN_MEMORY_ANALYTICAL")," mode. When switching back to the\n",(0,o.kt)("inlineCode",{parentName:"p"},"IN_MEMORY_TRANSACTIONAL")," mode it is recommended to create a snapshot manually\nwith ",(0,o.kt)("inlineCode",{parentName:"p"},"CREATE SNAPSHOT;")," Cypher query. Once Memgraph switches to the\n",(0,o.kt)("inlineCode",{parentName:"p"},"IN_MEMORY_TRANSACTIONAL")," mode, for all new updates it will create a WAL if not\notherwise instructed by the config file."),(0,o.kt)("h3",{id:"snapshots"},"Snapshots"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"/memgraph/reference-guide/backup#snapshots"},"Snapshots")," capture the database\nstate and store it on the disk. A snapshot is used to recover the database upon\nstartup (depending on the setting of the configuration flag\n",(0,o.kt)("inlineCode",{parentName:"p"},"--storage-recover-on-startup"),", which defaults to ",(0,o.kt)("inlineCode",{parentName:"p"},"true"),")."),(0,o.kt)("p",null,"In Memgraph, snapshots are created periodically or manually."),(0,o.kt)("p",null,"In the ",(0,o.kt)("inlineCode",{parentName:"p"},"IN_MEMORY_ANALYTICAL")," mode, periodic snapshots are ",(0,o.kt)("strong",{parentName:"p"},"disabled"),"."),(0,o.kt)("p",null,"Manual snapshots are created by running the ",(0,o.kt)("inlineCode",{parentName:"p"},"CREATE SNAPSHOT;")," query. When the\nquery is run in the ",(0,o.kt)("inlineCode",{parentName:"p"},"IN_MEMORY_ANALYTICAL")," mode, Memgraph guarantees that it\nwill be ",(0,o.kt)("strong",{parentName:"p"},"the only")," transaction present in the system, and all the other\ntransactions will wait until the snapshot is created to ensure its validity."),(0,o.kt)("h2",{id:"on-disk-transactional-storage-mode"},"On-disk transactional storage mode"),(0,o.kt)("p",null,"In the on-disk transactional storage mode, disk is used as a physical storage\nwhich allows you to save more data than the capacity of your RAM. This helps\nkeep the hardware costs to a minimum, but you should except slower performance\nwhen compared to the in-memory transactional storage mode. Keep in mind that\nwhile executing queries, all the graph objects used in the transactions still\nneed to be able to fit in the RAM, or Memgraph will throw an exception. "),(0,o.kt)("h3",{id:"architecture"},"Architecture"),(0,o.kt)("p",null,'RocksDB is used as a background storage to serialize nodes and relationships\ninto a key-value format. The used architecture is also known as "larger than\nmemory" as it enables in-memory databases to save more data than the main memory\ncan hold, without the performance overhead caused by the buffer pool. '),(0,o.kt)("p",null,"The imported data is residing on the disk, while the main memory contains two\ncaches, one executing operations on main RocksDB instance and the other for\noperations that require indices. In both cases, Memgraph's custom\n",(0,o.kt)("inlineCode",{parentName:"p"},"SkipList")," cache is used, which allows a multithreaded read-write access pattern."),(0,o.kt)("h3",{id:"mvcc"},"MVCC"),(0,o.kt)("p",null,"Concurrent execution of transactions is supported differently for on-disk\nstorage than for in-memory. The in-memory storage mode relies on delta objects\nwhich store the exact versions of data at the specific moment in time.\nTherefore, the in-memory storage mode uses a pessimistic approach and\nimmediately checks whether there is a conflict between two transactions. "),(0,o.kt)("p",null,"In the on-disk storage mode, the cache is used per transaction. This\nsignificantly simplifies object management since there is no need to question\ncertain object's validity, but it also requires the optimistic approach for\nconflict resolution between transactions. "),(0,o.kt)("p",null,"In the on-disk storage mode, the conflict is checked at the transaction's commit\ntime with the help of RocksDB's transaction support. This also implies that\ndeltas are cleared after each transaction, which can optimize memory usage\nduring execution. Deltas are still used to fully support Cypher's semantic of\nthe write queries. The design of the on-disk storage also simplifies the process\nof garbage collection, since all the data is on disk."),(0,o.kt)("h3",{id:"isolation-level"},"Isolation level"),(0,o.kt)("p",null,"The on-disk storage mode supports only snapshot isolation level. Mostly because\nit's the Memgraph viewpoint that snapshot isolation should be the default\nisolation level for most applications relying on databases. But the snapshot\nisolation level also simplifies the query's execution flow since no data is transferred to the disk until the commit of the transaction."),(0,o.kt)("h3",{id:"indices"},"Indices"),(0,o.kt)("p",null,"The on-disk storage mode supports both label and label-property indices. They\nare stored in separate RocksDB instances as key-value pairs so that the access\nto the data is faster. Whenever the indexed node is accessed, it's stored into a\nseparate in-memory cache to maximize the reading speed."),(0,o.kt)("h3",{id:"constraints"},"Constraints"),(0,o.kt)("p",null,"The on-disk storage mode supports both existence and uniqueness constraints.\nExistence constraints don't use context from the disk since the validity of\nnodes can be checked by looking only at this single node. On the other side,\nuniqueness constraints require a different approach. For a node to be valid, the\nengine needs to iterate through all other nodes under constraint and check\nwhether a conflict exists. To speed up this iteration process, nodes under\nconstraint are stored into a separate RocksDB instance to eliminate the cost of\niterating over nodes which are not under constraint."),(0,o.kt)("h3",{id:"data-formats"},"Data formats"),(0,o.kt)("p",null,"Below is the format in which data is serialized to the disk. "),(0,o.kt)("p",null,"Vertex format for main disk storage:\nKey - ",(0,o.kt)("inlineCode",{parentName:"p"},"label1, label2, ... | vertex gid | commit_timestamp"),"\nValue - ",(0,o.kt)("inlineCode",{parentName:"p"},"property1, property2")),(0,o.kt)("p",null,"Edge format for the main disk storage:\nKey - ",(0,o.kt)("inlineCode",{parentName:"p"},"from vertex gid | to vertex gid | 0 | edge type | edge gid | commit_timestamp"),"\nValue - ",(0,o.kt)("inlineCode",{parentName:"p"},"property1, property2"),"\n",(0,o.kt)("inlineCode",{parentName:"p"},"0")," is a placeholder for edge direction in future."),(0,o.kt)("p",null,"Format for label index on disk:"),(0,o.kt)("p",null,"Key - ",(0,o.kt)("inlineCode",{parentName:"p"},"indexing label | vertex gid | commit_timestamp")),(0,o.kt)("p",null,"Value - ",(0,o.kt)("inlineCode",{parentName:"p"},"label1_id, label2_id, ... | property1, property2, ...")),(0,o.kt)("p",null,"Value does not contain ",(0,o.kt)("inlineCode",{parentName:"p"},"indexing label"),"."),(0,o.kt)("p",null,"Format for label-property index on disk:"),(0,o.kt)("p",null,"Key - ",(0,o.kt)("inlineCode",{parentName:"p"},"indexing label | indexing property | vertex gid | commit_timestamp")),(0,o.kt)("p",null,"Value - ",(0,o.kt)("inlineCode",{parentName:"p"},"label1_id, label2_id, ... | property1, property2, ...")),(0,o.kt)("p",null,"Value does not contain ",(0,o.kt)("inlineCode",{parentName:"p"},"indexing label"),"."),(0,o.kt)("h3",{id:"durability"},"Durability"),(0,o.kt)("p",null,"In the on-disk storage mode, durability is supported by RocksDB since it keeps\nits own\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/rocksdb/wiki/Write-Ahead-Log-%28WAL%29"},"WAL")," files.\nMemgraph persists the metadata used in the implementation of the on-disk\nstorage. "),(0,o.kt)("h3",{id:"memory-control"},"Memory control"),(0,o.kt)("p",null,"If the workload is larger than memory, a single transaction must fit into the\nmemory. A memory tracker track all allocations happening throughout the\ntransaction's lifetime. Disk space also has to be carefully managed. Since the\ntimestamp is serialized together with the raw node and relationship data, the\nengine needs to ensure that when the new version of the same node is stored, the\nold one is deleted."),(0,o.kt)("h3",{id:"replication"},"Replication"),(0,o.kt)("p",null,"At the moment, the on-disk storage doesn't support replication."))}c.isMDXComponent=!0}}]);