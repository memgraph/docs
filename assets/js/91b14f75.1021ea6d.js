"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[74192],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>h});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=c(a),h=i,u=m["".concat(l,".").concat(h)]||m[h]||d[h]||o;return a?n.createElement(u,r(r({ref:t},p),{},{components:a})):n.createElement(u,r({ref:t},p))}));function h(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=a.length,r=new Array(o);r[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var c=2;c<o;c++)r[c]=a[c];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},11387:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var n=a(87462),i=(a(67294),a(3905));const o={id:"node-classification-algorithm",title:"Node Classification",sidebar_label:"Node Classification"},r=void 0,s={unversionedId:"algorithms/machine-learning-graph-analytics/node-classification-algorithm",id:"algorithms/machine-learning-graph-analytics/node-classification-algorithm",title:"Node Classification",description:"Description",source:"@site/mage/algorithms/machine-learning-graph-analytics/node-classification-algorithm.md",sourceDirName:"algorithms/machine-learning-graph-analytics",slug:"/algorithms/machine-learning-graph-analytics/node-classification-algorithm",permalink:"/docs/mage/algorithms/machine-learning-graph-analytics/node-classification-algorithm",draft:!1,editUrl:"https://github.com/memgraph/docs/tree/master/mage/algorithms/machine-learning-graph-analytics/node-classification-algorithm.md",tags:[],version:"current",frontMatter:{id:"node-classification-algorithm",title:"Node Classification",sidebar_label:"Node Classification"},sidebar:"mage",previous:{title:"Link Prediction",permalink:"/docs/mage/algorithms/machine-learning-graph-analytics/link-prediction-algorithm"},next:{title:"Node2Vec",permalink:"/docs/mage/algorithms/machine-learning-graph-analytics/node2vec-algorithm"}},l={},c=[{value:"Description",id:"description",level:2},{value:"Solution",id:"solution",level:3},{value:"Materials",id:"materials",level:2},{value:"Implementation",id:"implementation",level:3},{value:"Use cases",id:"use-cases",level:2}],p={toc:c};function d(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"description"},"Description"),(0,i.kt)("p",null,"Node classification is the problem of finding out the ",(0,i.kt)("strong",{parentName:"p"},"right label")," for a ",(0,i.kt)("strong",{parentName:"p"},"node")," based on its ",(0,i.kt)("strong",{parentName:"p"},"neighbors\u2019 labels")," and ",(0,i.kt)("strong",{parentName:"p"},"structure similarities"),"."),(0,i.kt)("p",null,"More formally, let ",(0,i.kt)("inlineCode",{parentName:"p"},"G=(V, E)")," be a graph with vertices (nodes) ",(0,i.kt)("inlineCode",{parentName:"p"},"V")," and edges (relationships) ",(0,i.kt)("inlineCode",{parentName:"p"},"E"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"S")," the set of all labels, and ",(0,i.kt)("inlineCode",{parentName:"p"},"f : V \u2192 S")," a vertex labeling function that returns the correct label for each node.\nFrom a given partial function ",(0,i.kt)("inlineCode",{parentName:"p"},"g : V\u2019 \u2286 V \u2192 S")," (",(0,i.kt)("inlineCode",{parentName:"p"},"V\u2019")," being training examples),\na node classification model aims to minimize the loss of the label prediction function ",(0,i.kt)("inlineCode",{parentName:"p"},"g\u2019 : V \u2192 S"),"."),(0,i.kt)("p",null,"The motivation for node classification models is the sociological concept of homophily. In social networks, individuals who associate and\nbond with each other tend to have similar properties. In graph structure, homophily means that neighboring nodes\ntend to have the same labels and similar connections.  "),(0,i.kt)("p",null,"In real-life datasets, the set ",(0,i.kt)("inlineCode",{parentName:"p"},"V")," can be a lot of things, often scientific publications, proteins, Reddit posts, etc. In the same respective order,\nset ",(0,i.kt)("inlineCode",{parentName:"p"},"E")," can be a citation of publications, protein connections, or connection of posts commented by the same user. Therefore, node classification helps the user to classify publications\nrelevant to its field, check whether protein helps cure new diseases, or simply find out which subreddit a post naturally belongs to.\nOn incompletely labeled graphs, node classification seeks to find the right labels for unlabeled nodes."),(0,i.kt)("h3",{id:"solution"},"Solution"),(0,i.kt)("p",null,"Solving methods range from ",(0,i.kt)("strong",{parentName:"p"},"algorithmic")," to ",(0,i.kt)("strong",{parentName:"p"},"machine learning-based"),". Both models work on top of the feature which describes each node. Together features and relationships between\nnodes help the algorithm decide what is the correct label for each node."),(0,i.kt)("p",null,"The key difference is when using traditional methods, an engineer must create distinguishing features for each node himself.\nOn the other hand, the machine learning model learns and adapts almost any set of randomly initialized sets of numbers that represent node features."),(0,i.kt)("p",null,"For a traditional approach, extracting such a feature is not an easy problem, since there are many options to choose from \u2014 node properties, node adjacency, or the structure of the neighborhood.\nTraditional methods of extracting knowledge from nodes include measures of ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Centrality"},"centrality"),", importance, or feature structure such as ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Graphlets"},"graphlets"),"."),(0,i.kt)("p",null,"Graph machine learning models can work based on almost arbitrary features. Finding similar features for nodes with the same label, then\nlearning and mapping such features as distinguishing ones is their biggest advantage. ML models are constantly developed. Here are some which are usually used in ",(0,i.kt)("strong",{parentName:"p"},"node classification")," tasks:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"http://snap.stanford.edu/graphsage/"},"GraphSAGE")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"https://towardsdatascience.com/understanding-graph-convolutional-networks-for-node-classification-a2bfdb7aba7b"},"Graph convolutional networks")," (GCN)"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"https://arxiv.org/abs/1710.10903"},"Graph Attention Network")," (GAT)")),(0,i.kt)("img",{src:"https://i.imgur.com/hbWDz7q.png",alt:"drawing"}),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Previously labeled nodes can be used to determine the class of unclassified ones")),(0,i.kt)("h2",{id:"materials"},"Materials"),(0,i.kt)("h3",{id:"implementation"},"Implementation"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/memgraph/mage/blob/main/python/node_classification.py"},(0,i.kt)("img",{parentName:"a",src:"https://img.shields.io/badge/Node_classification-Implementation-FB6E00?logo=github&style=for-the-badge",alt:"Node classification"}))),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/mage/query-modules/python/node-classification-with-gnn"},(0,i.kt)("img",{parentName:"a",src:"https://img.shields.io/badge/Node_classification-Documentation-FCC624?style=for-the-badge&logo=python&logoColor=white",alt:"Node classification"}))),(0,i.kt)("p",null,"Machine learning-powered ",(0,i.kt)("strong",{parentName:"p"},"node classification")," is provided within ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/memgraph/mage"},"Memgraph MAGE"),". We encourage you to test it yourself and take a look at the implementation."),(0,i.kt)("h2",{id:"use-cases"},"Use cases"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/docs/mage/use-cases/finance"},(0,i.kt)("img",{parentName:"a",src:"https://img.shields.io/badge/Finance-Application-8A477F?style=for-the-badge",alt:"Finance"}))),(0,i.kt)("p",null,"Classifying nodes based on previously labeled data can help investigators to find out fraudsters in finance systems. Since fraudsters can often act very quickly with their tricks, applying a streaming-based node classification can help up building a real-time fraud detection system."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/docs/mage/use-cases/computer-security"},(0,i.kt)("img",{parentName:"a",src:"https://img.shields.io/badge/Computer_Security-Application-8A477F?style=for-the-badge",alt:"Computer Security"}))),(0,i.kt)("p",null,"Fraudsters usually behave differently than common users. This way a system can be observed and once an unusual behavior is spotted it can immediately be revealed. This can help build a bulletproof computer security system."))}d.isMDXComponent=!0}}]);