"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[33960],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>f});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=r.createContext({}),s=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=s(e.components);return r.createElement(p.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,p=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=s(n),f=a,h=d["".concat(p,".").concat(f)]||d[f]||m[f]||o;return n?r.createElement(h,i(i({ref:t},c),{},{components:n})):r.createElement(h,i({ref:t},c))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=d;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var s=2;s<o;s++)i[s]=n[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},16659:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>p,toc:()=>c});var r=n(87462),a=(n(67294),n(3905)),o=n(41434);const i={sidebar_label:"export",title:"gqlalchemy.transformations.export"},l=void 0,p={unversionedId:"reference/transformations/export",id:"reference/transformations/export",title:"gqlalchemy.transformations.export",description:"GQLAlchemy currently supports exporting data from Memgraph to NetworkX, DGL and PyG graph formats.",source:"@site/gqlalchemy/reference/transformations/export.md",sourceDirName:"reference/transformations",slug:"/reference/transformations/export",permalink:"/docs/gqlalchemy/reference/transformations/export",draft:!1,editUrl:"https://github.com/memgraph/docs/tree/master/gqlalchemy/reference/transformations/export.md",tags:[],version:"current",frontMatter:{sidebar_label:"export",title:"gqlalchemy.transformations.export"},sidebar:"gqlalchemy",previous:{title:"models",permalink:"/docs/gqlalchemy/reference/models"},next:{title:"import",permalink:"/docs/gqlalchemy/reference/transformations/importing/import"}},s={},c=[{value:"Transporter",id:"transporter",level:2},{value:"GraphTransporter",id:"graphtransporter",level:2},{value:"Methods",id:"methods",level:3},{value:"<code>__init__</code>",id:"__init__",level:4},{value:"Input",id:"input",level:5},{value:"<code>export</code>",id:"export",level:4},{value:"Example",id:"example",level:3}],m={toc:c};function d(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"GQLAlchemy currently supports exporting data from Memgraph to ",(0,a.kt)("inlineCode",{parentName:"p"},"NetworkX"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"DGL")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"PyG")," graph formats.  "),(0,a.kt)(o.ZP,{mdxType:"OptionalDependenciesNote"}),(0,a.kt)("h2",{id:"transporter"},"Transporter"),(0,a.kt)("p",null,"Abstract transporter that provides interface for translating Memgraph data into graph objects like ",(0,a.kt)("inlineCode",{parentName:"p"},"NetworkX"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"DGL")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"PyG"),"."),(0,a.kt)("h2",{id:"graphtransporter"},"GraphTransporter"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"GraphTransporter")," is used for converting a Memgraph graph to the specific graph type offered by some Python package (",(0,a.kt)("inlineCode",{parentName:"p"},"PyG"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"DGL"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"Nx"),"...). Each ",(0,a.kt)("inlineCode",{parentName:"p"},"GraphTransporter")," has a reference to the specific translator object, which is used for translating Memgraph data into the correct graph type. This translator does all the dirty work, so check out the docs about ",(0,a.kt)("a",{parentName:"p",href:"/docs/gqlalchemy/reference/transformations/translators/dgl_translator"},(0,a.kt)("inlineCode",{parentName:"a"},"DGLTranslator")),", ",(0,a.kt)("a",{parentName:"p",href:"/docs/gqlalchemy/reference/transformations/translators/pyg_translator"},(0,a.kt)("inlineCode",{parentName:"a"},"PyGTranslator"))," and ",(0,a.kt)("a",{parentName:"p",href:"/docs/gqlalchemy/reference/transformations/translators/nx_translator"},(0,a.kt)("inlineCode",{parentName:"a"},"NxTranslator"))," to find out implementation details."),(0,a.kt)("h3",{id:"methods"},"Methods"),(0,a.kt)("h4",{id:"__init__"},(0,a.kt)("inlineCode",{parentName:"h4"},"__init__")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'def __init__(self, \n    graph_type: str, \n    default_node_label="NODE",\n    default_edge_type="RELATIONSHIP",\n    host: str = mg_consts.MG_HOST,\n    port: int = mg_consts.MG_PORT,\n    username: str = mg_consts.MG_USERNAME,\n    password: str = mg_consts.MG_PASSWORD,\n    encrypted: bool = mg_consts.MG_ENCRYPTED,\n    client_name: str = mg_consts.MG_CLIENT_NAME,\n    lazy: bool = mg_consts.MG_LAZY,\n    ) -> None\n')),(0,a.kt)("p",null,"Creates the neccessary translator object based on a graph type provided."),(0,a.kt)("h5",{id:"input"},"Input"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"graph_type: str")," -> Graph source type object. Can be one of the following: ","[",(0,a.kt)("inlineCode",{parentName:"li"},"DGL"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"NX"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"PYG"),"]"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"default_node_label: str=NODE")," -> Default node label that will be given to nodes when no other can be inferred."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"default_edge_type: str=RELATIONSHIP")," -> Default edge type that will be given to edges when no other can be inferred."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"host: str=127.0.0.1")," -> Host connection info for connecting to the Memgraph instance."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"port: int=7687")," -> Port connection info for connecting to the Memgraph instance."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},'username: str=""')," -> Username connection info for connecting to the Memgraph instance."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},'password: str=""')," -> Password connection info for connecting to the Memgraph instance."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"encrypted: bool=False")," -> Encrypted flag for connecting to the Memgraph instance."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"client_name: str=GQLAlchemy")," -> Client name used for connecting to the Memgraph instance."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"lazy: bool=False")," -> Lazy flag for connecting to the Memgraph instance.")),(0,a.kt)("h4",{id:"export"},(0,a.kt)("inlineCode",{parentName:"h4"},"export")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def export(self) -> None\n")),(0,a.kt)("p",null,"Creates graph instance for the provided export option."),(0,a.kt)("h3",{id:"example"},"Example"),(0,a.kt)("p",null,"The following code can be used to transfer data from Memgraph DB into ",(0,a.kt)("inlineCode",{parentName:"p"},"DGL")," graph."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'transporter = GraphTransporter("dgl")\ngraph = transporter.export()  # in this step, data is converted from Memgraph to graph\n')))}d.isMDXComponent=!0},41434:(e,t,n)=>{n.d(t,{ZP:()=>i});var r=n(87462),a=(n(67294),n(3905));const o={toc:[]};function i(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},o,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"The features below aren\u2019t included in the default GQLAlchemy installation. To\nuse them, make sure to ",(0,a.kt)("a",{parentName:"p",href:"/gqlalchemy/installation"},"install GQLAlchemy")," with the\nrelevant optional dependencies.")))}i.isMDXComponent=!0}}]);