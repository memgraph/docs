"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[65232],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),p=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=p(n),m=a,h=d["".concat(s,".").concat(m)]||d[m]||c[m]||i;return n?r.createElement(h,o(o({ref:t},u),{},{components:n})):r.createElement(h,o({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var p=2;p<i;p++)o[p]=n[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},69603:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return l},metadata:function(){return p},toc:function(){return c}});var r=n(87462),a=n(63366),i=(n(67294),n(3905)),o=["components"],l={id:"other-features",title:"Other features",sidebar_label:"Other features"},s=void 0,p={unversionedId:"other-features",id:"other-features",title:"Other features",description:"The following sections describe some of the other supported features.",source:"@site/cypher-manual/other-features.md",sourceDirName:".",slug:"/other-features",permalink:"/docs/cypher-manual/other-features",editUrl:"https://github.com/memgraph/docs/tree/master/cypher-manual/other-features.md",tags:[],version:"current",frontMatter:{id:"other-features",title:"Other features",sidebar_label:"Other features"},sidebar:"cypher_manual",previous:{title:"Query modules",permalink:"/docs/cypher-manual/query-modules"}},u={},c=[{value:"String operators",id:"string-operators",level:2},{value:"Parameters",id:"parameters",level:2},{value:"CASE",id:"case",level:2},{value:"Inspecting and profiling queries",id:"inspecting-and-profiling-queries",level:2}],d={toc:c};function m(e){var t=e.components,n=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The following sections describe some of the other supported features."),(0,i.kt)("h2",{id:"string-operators"},"String operators"),(0,i.kt)("p",null,"Apart from comparison and concatenation operators Cypher provides special\nstring operators for easier matching of substrings:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Operator"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"a STARTS WITH b")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns true if the prefix of string a is equal to string b.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"a ENDS WITH b")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns true if the suffix of string a is equal to string b.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"a CONTAINS b")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns true if some substring of string a is equal to string b.")))),(0,i.kt)("h2",{id:"parameters"},"Parameters"),(0,i.kt)("p",null,"When automating the queries for Memgraph, it comes in handy to change only some\nparts of the query. Usually, these parts are values that are used for filtering\nresults or similar, while the rest of the query remains the same."),(0,i.kt)("p",null,"Parameters allow reusing the same query but with different parameter values. The\nsyntax uses the ",(0,i.kt)("inlineCode",{parentName:"p"},"$")," symbol to designate a parameter name. We don't allow old\nCypher parameter syntax using curly braces. For example, you can parameterize\nfiltering a node property:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (node1 {property: $propertyValue}) RETURN node1;\n")),(0,i.kt)("p",null,"You can use parameters instead of any literal in the query. Using parameters as\nproperty maps is partially supported in ",(0,i.kt)("inlineCode",{parentName:"p"},"CREATE"),", but not in ",(0,i.kt)("inlineCode",{parentName:"p"},"MATCH")," nor ",(0,i.kt)("inlineCode",{parentName:"p"},"MERGE"),"\nclause. For example, the following query is illegal:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (n $propertyMap) RETURN n;\n")),(0,i.kt)("p",null,"but this is supported:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"CREATE (n $propertyMap) RETURN n;\n")),(0,i.kt)("p",null,"To use parameters with a Python driver use the following syntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"session.run('CREATE (alice:Person {name: $name, age: $ageValue}',\n            name='Alice', ageValue=22)).consume()\n")),(0,i.kt)("p",null,"To use parameters whose names are integers, you will need to wrap parameters in\na dictionary and convert them to strings before running a query:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"session.run('CREATE (alice:Person {name: $0, age: $1}',\n            {'0': \"Alice\", '1': 22})).consume()\n")),(0,i.kt)("p",null,"To use parameters with some other driver, please consult appropriate\ndocumentation."),(0,i.kt)("h2",{id:"case"},"CASE"),(0,i.kt)("p",null,"Conditional expressions can be expressed in the Cypher language with the ",(0,i.kt)("inlineCode",{parentName:"p"},"CASE"),"\nexpression. A simple form is used to compare an expression against multiple\npredicates. For the first matched predicate result of the expression provided\nafter the ",(0,i.kt)("inlineCode",{parentName:"p"},"THEN")," keyword is returned. If no expression is matched value\nfollowing ",(0,i.kt)("inlineCode",{parentName:"p"},"ELSE")," is returned is provided, or ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"ELSE")," is not used:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},'MATCH (n)\nRETURN CASE n.currency WHEN "DOLLAR" THEN "$" WHEN "EURO" THEN "\u20ac" ELSE "UNKNOWN" END;\n')),(0,i.kt)("p",null,"In generic form, you don't need to provide an expression whose value is compared\nto predicates, but you can list multiple predicates and the first one that\nevaluates to true is matched:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},'MATCH (n)\nRETURN CASE WHEN n.height < 30 THEN "short" WHEN n.height > 300 THEN "tall" END;\n')),(0,i.kt)("p",null,"Most expressions that take ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," as input will produce ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),". This includes boolean expressions that are used as\npredicates. In this case, anything that is not true is interpreted as being false. This also concludes that logically ",(0,i.kt)("inlineCode",{parentName:"p"},"null!=null"),"."),(0,i.kt)("h2",{id:"inspecting-and-profiling-queries"},"Inspecting and profiling queries"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"EXPLAIN")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"PROFILE")," operators can be used to inspect and profile a\nparticular Cypher query in order to see its internal representation and the way\nit behaves during execution:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"EXPLAIN MATCH (n) RETURN n;\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cypher"},"PROFILE MATCH (n) RETURN n;\n")),(0,i.kt)("p",null,"For a detailed look at using ",(0,i.kt)("inlineCode",{parentName:"p"},"EXPLAIN")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"PROFILE"),", take a look at the guides:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/memgraph/reference-guide/inspecting-queries"},"Inspecting queries")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/memgraph/reference-guide/profiling-queries"},"Profiling queries"))))}m.isMDXComponent=!0}}]);