"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[23385],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>c});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=r.createContext({}),m=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=m(e.components);return r.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},s=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,p=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),s=m(n),c=o,g=s["".concat(p,".").concat(c)]||s[c]||u[c]||a;return n?r.createElement(g,i(i({ref:t},d),{},{components:n})):r.createElement(g,i({ref:t},d))}));function c(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=s;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var m=2;m<a;m++)i[m]=n[m];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}s.displayName="MDXCreateElement"},31757:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>l,toc:()=>m});var r=n(87462),o=(n(67294),n(3905));const a={id:"create-a-new-module-cpp",title:"How to create a query module in C++",sidebar_label:"Create a C++ query module"},i=void 0,l={unversionedId:"how-to-guides/create-a-new-module-cpp",id:"how-to-guides/create-a-new-module-cpp",title:"How to create a query module in C++",description:"Query modules can be implemented using the [C",source:"@site/mage/how-to-guides/create-a-new-module-cpp.md",sourceDirName:"how-to-guides",slug:"/how-to-guides/create-a-new-module-cpp",permalink:"/docs/mage/how-to-guides/create-a-new-module-cpp",draft:!1,editUrl:"https://github.com/memgraph/docs/tree/master/mage/how-to-guides/create-a-new-module-cpp.md",tags:[],version:"current",frontMatter:{id:"create-a-new-module-cpp",title:"How to create a query module in C++",sidebar_label:"Create a C++ query module"},sidebar:"mage",previous:{title:"Create a Python query module",permalink:"/docs/mage/how-to-guides/create-a-new-module-python"},next:{title:"Run a query module",permalink:"/docs/mage/how-to-guides/run-a-query-module"}},p={},m=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Developing a module",id:"developing-a-module",level:2},{value:"Importing, querying and testing a module",id:"importing-querying-and-testing-a-module",level:2}],d={toc:m};function u(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Query modules can be implemented using the ",(0,o.kt)("a",{parentName:"p",href:"/memgraph/reference-guide/query-modules/api/c-api"},"C\nAPI"),"\nprovided by Memgraph. In this tutorial, we will learn how to develop a query\nmodule in C++ on the example of the ",(0,o.kt)("strong",{parentName:"p"},"random walk algorithm"),"."),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"If you wish to write your own query modules using the C API, you can write the\nprocedures in any programming language that can work with C and can be compiled\nto the ELF shared library format. The latter requirement is necessary so that\nthe modules can be loaded together when Memgraph starts.")),(0,o.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,o.kt)("p",null,"There are three options for installing and working with Memgraph MAGE:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Pulling the ",(0,o.kt)("inlineCode",{parentName:"strong"},"memgraph/memgraph-mage")," image"),": check the ",(0,o.kt)("inlineCode",{parentName:"li"},"Docker Hub"),(0,o.kt)("a",{parentName:"li",href:"/docs/mage/installation/docker-hub"},"installation guide"),"."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Building a Docker image from the MAGE repository"),": check the ",(0,o.kt)("inlineCode",{parentName:"li"},"Docker\nbuild")," ",(0,o.kt)("a",{parentName:"li",href:"/docs/mage/installation/docker-build"},"installation guide"),"."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Building MAGE from source"),": check the ",(0,o.kt)("inlineCode",{parentName:"li"},"Build from source on Linux"),(0,o.kt)("a",{parentName:"li",href:"/docs/mage/installation/source"},"installation guide"),".")),(0,o.kt)("h2",{id:"developing-a-module"},"Developing a module"),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"These instructions are the same for every MAGE installation option: ",(0,o.kt)("em",{parentName:"p"},"Docker\nHub"),", ",(0,o.kt)("em",{parentName:"p"},"Docker build")," and ",(0,o.kt)("em",{parentName:"p"},"Build from source on Linux"),".")),(0,o.kt)("p",null,"Position yourself in the ",(0,o.kt)("strong",{parentName:"p"},"MAGE repository")," you cloned earlier. Once you are\nthere, enter the ",(0,o.kt)("inlineCode",{parentName:"p"},"cpp")," subdirectory and create a new directory called\n",(0,o.kt)("inlineCode",{parentName:"p"},"random_walk_module")," with the ",(0,o.kt)("inlineCode",{parentName:"p"},"random_walk_module.cpp")," file inside it."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-plaintext"},"cpp\n\u2514\u2500\u2500 random_walk_module\n    \u2514\u2500\u2500 random_walk_module.cpp\n")),(0,o.kt)("p",null,"To make sure the module is linked with the rest of MAGE\u2019s code, we need to add a\n",(0,o.kt)("inlineCode",{parentName:"p"},"CMakeLists.txt")," script in the new directory and register our module in the\n",(0,o.kt)("inlineCode",{parentName:"p"},"cpp/CMakelists.txt")," script as well. Refer to the existing scripts in MAGE\u2019s\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/memgraph/mage/tree/main/cpp"},"query modules"),"."),(0,o.kt)("p",null,"Our ",(0,o.kt)("inlineCode",{parentName:"p"},"random_walk")," module contains a single procedure ",(0,o.kt)("inlineCode",{parentName:"p"},"get")," which implements the\nalgorithm. The procedure takes two input parameters: the starting node and the\nnumber of steps (10 by default), and it returns the generated random walk in the\nform of a list of ",(0,o.kt)("inlineCode",{parentName:"p"},"step | node")," entries, one for each step.\nAll in all, we can define its signature as ",(0,o.kt)("inlineCode",{parentName:"p"},"get(start: Node, steps: int = 10)\n-> [step: int | node: Node]"),"."),(0,o.kt)("p",null,"Let\u2019s take a look at the structure of our query module."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <mg_utils.hpp>\n\nvoid RandomWalk(mgp_list *args, mgp_graph *memgraph_graph,\n                     mgp_result *result, mgp_memory *memory);\n\nextern "C" int mgp_init_module(struct mgp_module *module,\n                               struct mgp_memory *memory);\n\nextern "C" int mgp_shutdown_module() { return 0; }\n\n')),(0,o.kt)("p",null,"In the first line, we include ",(0,o.kt)("inlineCode",{parentName:"p"},"mg_utils.hpp"),". This header contains declarations\nof the public C API provided by Memgraph, which we need to connect the algorithm\nto Memgraph and work with the data stored within."),(0,o.kt)("p",null,"Next, we are going to implement the random walk algorithm\u2019s logic in the\n",(0,o.kt)("inlineCode",{parentName:"p"},"RandomWalk")," function, which will be the callback for the invocations of our\nopenCypher procedure. Callback functions such as this one all need to have the\nsame signature, but they can be arbitrarily named (e.g. in query modules\ncontaining multiple callback functions)."),(0,o.kt)("p",null,"Query modules using the C API must have the ",(0,o.kt)("inlineCode",{parentName:"p"},"mgp_init_module")," &\n",(0,o.kt)("inlineCode",{parentName:"p"},"mgp_shutdown_module")," functions. The ",(0,o.kt)("inlineCode",{parentName:"p"},"mgp_init_module")," function\u2019s main purpose\nis to register procedures so that they can be called from openCypher, and with\n",(0,o.kt)("inlineCode",{parentName:"p"},"mgp_shutdown_module")," you may reset any global states or release global\nresources."),(0,o.kt)("admonition",{type:"warning"},(0,o.kt)("p",{parentName:"admonition"},"WARNING: Exceptions, if thrown, must never leave the scope of your module! You\nshould have a top-level exception handler that returns an error value and\npotentially logs the error message as well. Exceptions crossing the module\nboundary may cause all sorts of unexpected issues.")),(0,o.kt)("p",null,"That said, let\u2019s now take a closer look at ",(0,o.kt)("inlineCode",{parentName:"p"},"RandomWalk")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"mgp_init_module"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"\nvoid RandomWalk(mgp_list *args, mgp_graph *memgraph_graph, mgp_result *result,\n                mgp_memory *memory) {\n  try {\n    const auto start = mgp::value_get_vertex(mgp::list_at(args, 0));\n    const auto n_steps = mgp::value_get_int(mgp::list_at(args, 1));\n\n    srand(time(NULL));\n\n    const auto start_id = mgp::vertex_get_id(start).as_int;\n    const auto graph = mg_utility::GetGraphView(\n        memgraph_graph, result, memory, mg_graph::GraphType::kUndirectedGraph);\n\n    int step = 0;\n    auto current_node = graph->GetNode(start_id);\n    InsertStepRecord(memgraph_graph, result, memory, step++, current_node.id);\n\n    while (step <= n_steps) {\n      const auto neighbors = graph->Neighbours(current_node.id);\n      if (neighbors.empty()) break;\n\n      const auto next_node = neighbors[rand() % neighbors.size()];\n      current_node = graph->GetNode(next_node.node_id);\n      // record the output\n      InsertStepRecord(memgraph_graph, result, memory, step++, current_node.id);\n    }\n  } catch (const std::exception &e) {\n    mgp::result_set_error_msg(result, e.what());\n    return;\n  }\n}\n")),(0,o.kt)("p",null,"Upon being called, ",(0,o.kt)("inlineCode",{parentName:"p"},"RandomWalk")," receives the list of arguments (",(0,o.kt)("inlineCode",{parentName:"p"},"args"),") passed\nin the query. The parameter ",(0,o.kt)("inlineCode",{parentName:"p"},"result")," is used for recording the results of the\nprocedure, and its context is provided by ",(0,o.kt)("inlineCode",{parentName:"p"},"graph")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"memory"),"."),(0,o.kt)("p",null,"With the C API, we next retrieve the argument values from ",(0,o.kt)("inlineCode",{parentName:"p"},"args")," and access the\ngraph in order to be able to implement the algorithm. As for the output, you\nmight\u2019ve noted that the ",(0,o.kt)("inlineCode",{parentName:"p"},"RandomWalk")," function does not return anything by itself.\nInstead, remember that the parameter ",(0,o.kt)("inlineCode",{parentName:"p"},"result")," serves to record the output. We\ndelegated the logic for this task to the ",(0,o.kt)("inlineCode",{parentName:"p"},"InsertStepRecord")," function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'void InsertStepRecord(mgp_graph *graph, mgp_result *result, mgp_memory *memory,\n                      const int step, const int node_id) {\n  auto *record = mgp::result_new_record(result);\n\n  mg_utility::InsertIntValueResult(record, "step", step, memory);\n  mg_utility::InsertNodeValueResult(graph, record, "node", node_id, memory);\n}\n')),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"Analogous methods for other supported data types are outlined in the C API\nreference.")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"mgp_init_module")," function has as its main duty the registration of\nprocedure(s), which can then be invoked in openCypher. With the C API, we add our\nprocedure and its inputs and outputs."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'extern "C" int mgp_init_module(struct mgp_module *module,\n                               struct mgp_memory *memory) {\n  {\n    try {\n      auto *rw_proc = mgp::module_add_read_procedure(module, "get", RandomWalk);\n\n      // optional parameters require a default value\n      auto default_steps = mgp::value_make_int(10, memory);\n\n      mgp::proc_add_arg(rw_proc, "start", mgp::type_node());\n      mgp::proc_add_opt_arg(rw_proc, "steps", mgp::type_int(), default_steps);\n\n      mgp::proc_add_result(rw_proc, "step", mgp::type_int());\n      mgp::proc_add_result(rw_proc, "node", mgp::type_node());\n\n      mgp_value_destroy(default_steps);\n    } catch (const std::exception &e) {\n      return 1;\n    }\n  }\n  return 0;\n}\n')),(0,o.kt)("p",null,"Although this example registers a single procedure ",(0,o.kt)("inlineCode",{parentName:"p"},"get"),", you can have multiple\ndifferent procedures in one module, each of which can be invoked using the\n",(0,o.kt)("inlineCode",{parentName:"p"},"CALL <module>.<procedure> ...")," syntax (",(0,o.kt)("inlineCode",{parentName:"p"},"<module>")," being the name of the shared\nlibrary). Since we compile our example to ",(0,o.kt)("inlineCode",{parentName:"p"},"random_walk.so"),", the module is called\n",(0,o.kt)("inlineCode",{parentName:"p"},"random_walk"),"."),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"As the procedure name is defined upon registration, it can differ from its\nrespective callback.")),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"For more information on the signature specification API, consult the\ndocumentation of the functions prefixed with ",(0,o.kt)("inlineCode",{parentName:"p"},"proc_")," in the ",(0,o.kt)("inlineCode",{parentName:"p"},"mgp.hpp")," file.")),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"As the ",(0,o.kt)("inlineCode",{parentName:"p"},"memory")," argument is only alive throughout the execution of\n",(0,o.kt)("inlineCode",{parentName:"p"},"mgp_init_module"),", do not allocate any global resources with it. If you still do\nneed to set up a global state, you may do so in the ",(0,o.kt)("inlineCode",{parentName:"p"},"mgp_init_module")," using the\nstandard global allocators.")),(0,o.kt)("p",null,"Finally, you may want to reset any global state or release global resources,\nwhich is done in the following function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'extern "C" int mgp_shutdown_module() {\n   return 0;\n}\n')),(0,o.kt)("p",null,"As mentioned before, no exceptions should leave your module. As done in this\nexample, exception handlers are in ",(0,o.kt)("inlineCode",{parentName:"p"},"mgp_init_module")," and the callback function.\nDepending on your module\u2019s needs, you might want one in ",(0,o.kt)("inlineCode",{parentName:"p"},"mgp_shutdown_module")," as\nwell."),(0,o.kt)("h2",{id:"importing-querying-and-testing-a-module"},"Importing, querying and testing a module"),(0,o.kt)("p",null,"Now in order to import, query and test a module, check out the ",(0,o.kt)("a",{parentName:"p",href:"/mage/how-to-guides/run-a-query-module"},"following\npage"),"."),(0,o.kt)("p",null,"Feel free to create an issue or open a pull request on our ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/memgraph/mage"},"GitHub\nrepo")," to speed up the development.",(0,o.kt)("br",null),"\nAlso, don\u2019t forget to throw us a star on GitHub. \u2b50"))}u.isMDXComponent=!0}}]);