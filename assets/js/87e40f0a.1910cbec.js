"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[60328],{3905:(e,t,a)=>{a.d(t,{Zo:()=>s,kt:()=>c});var n=a(67294);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function u(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var p=n.createContext({}),o=function(e){var t=n.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},s=function(e){var t=o(e.components);return n.createElement(p.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,l=e.mdxType,r=e.originalType,p=e.parentName,s=u(e,["components","mdxType","originalType","parentName"]),d=o(a),c=l,k=d["".concat(p,".").concat(c)]||d[c]||m[c]||r;return a?n.createElement(k,i(i({ref:t},s),{},{components:a})):n.createElement(k,i({ref:t},s))}));function c(e,t){var a=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=a.length,i=new Array(r);i[0]=d;var u={};for(var p in t)hasOwnProperty.call(t,p)&&(u[p]=t[p]);u.originalType=e,u.mdxType="string"==typeof e?e:l,i[1]=u;for(var o=2;o<r;o++)i[o]=a[o];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},7795:(e,t,a)=>{a.r(t),a.d(t,{Highlight:()=>s,assets:()=>p,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>u,toc:()=>o});var n=a(87462),l=(a(67294),a(3905));a(74866),a(85162),a(83523);const r={id:"map",title:"map",sidebar_label:"map"},i=void 0,u={unversionedId:"query-modules/cpp/map",id:"query-modules/cpp/map",title:"map",description:"The map module offers a versatile toolkit for manipulating collections of key-value pairs, enabling advanced data operations within a graph database context.",source:"@site/mage/query-modules/cpp/map.md",sourceDirName:"query-modules/cpp",slug:"/query-modules/cpp/map",permalink:"/docs/mage/query-modules/cpp/map",draft:!1,editUrl:"https://github.com/memgraph/docs/tree/master/mage/query-modules/cpp/map.md",tags:[],version:"current",frontMatter:{id:"map",title:"map",sidebar_label:"map"},sidebar:"mage",previous:{title:"llm_util",permalink:"/docs/mage/query-modules/python/llm-util"},next:{title:"max_flow",permalink:"/docs/mage/query-modules/python/max-flow"}},p={},o=[{value:"Procedures",id:"procedures",level:3},{value:"<code>remove_key(input_map, key, recursive_map)</code>",id:"remove_keyinput_map-key-recursive_map",level:3},{value:"Input:",id:"input",level:4},{value:"Output:",id:"output",level:4},{value:"Usage:",id:"usage",level:4},{value:"<code>from_pairs(input_list)</code>",id:"from_pairsinput_list",level:3},{value:"Input:",id:"input-1",level:4},{value:"Output:",id:"output-1",level:4},{value:"Usage:",id:"usage-1",level:4},{value:"<code>merge(input_map1, input_map2)</code>",id:"mergeinput_map1-input_map2",level:3},{value:"Input:",id:"input-2",level:4},{value:"Output:",id:"output-2",level:4},{value:"Usage:",id:"usage-2",level:4},{value:"<code>flatten(map, delimiter)</code>",id:"flattenmap-delimiter",level:3},{value:"Input:",id:"input-3",level:4},{value:"Output:",id:"output-3",level:4},{value:"Usage:",id:"usage-3",level:4},{value:"<code>from_lists(list_keys, list_values)</code>",id:"from_listslist_keys-list_values",level:3},{value:"Input:",id:"input-4",level:4},{value:"Output:",id:"output-4",level:4},{value:"Usage:",id:"usage-4",level:4},{value:"<code>remove_keys(input_map, keys_list, recursive)</code>",id:"remove_keysinput_map-keys_list-recursive",level:3},{value:"Input:",id:"input-5",level:4},{value:"Output:",id:"output-5",level:4},{value:"Usage:",id:"usage-5",level:4},{value:"<code>from_nodes(label, property)</code>",id:"from_nodeslabel-property",level:3},{value:"Input:",id:"input-6",level:4},{value:"Output:",id:"output-6",level:4},{value:"Usage:",id:"usage-6",level:4},{value:"<code>from_values(values)</code>",id:"from_valuesvalues",level:3},{value:"Input:",id:"input-7",level:4},{value:"Output:",id:"output-7",level:4},{value:"Usage:",id:"usage-7",level:4},{value:"<code>set_key(map, key, value)</code>",id:"set_keymap-key-value",level:3},{value:"Input:",id:"input-8",level:4},{value:"Output:",id:"output-8",level:4},{value:"Usage:",id:"usage-8",level:4}],s=e=>{let{children:t,color:a}=e;return(0,l.kt)("span",{style:{backgroundColor:a,borderRadius:"2px",color:"#fff",padding:"0.2rem"}},t)},m={toc:o,Highlight:s};function d(e){let{components:t,...a}=e;return(0,l.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"map")," module offers a versatile toolkit for manipulating collections of key-value pairs, enabling advanced data operations within a graph database context."),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"https://github.com/memgraph/mage/tree/main/cpp/map_module"},(0,l.kt)("img",{parentName:"a",src:"https://img.shields.io/badge/source-map-FB6E00?logo=github&style=for-the-badge",alt:"docs-source"}))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Trait"),(0,l.kt)("th",{parentName:"tr",align:null},"Value"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"Module type")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)(s,{color:"#FB6E00",mdxType:"Highlight"},(0,l.kt)("strong",{parentName:"td"},"util")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"Implementation")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)(s,{color:"#FB6E00",mdxType:"Highlight"},(0,l.kt)("strong",{parentName:"td"},"C++")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"Graph direction")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)(s,{color:"#FB6E00",mdxType:"Highlight"},(0,l.kt)("strong",{parentName:"td"},"directed")),"/",(0,l.kt)(s,{color:"#FB6E00",mdxType:"Highlight"},(0,l.kt)("strong",{parentName:"td"},"undirected")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"Edge weights")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)(s,{color:"#FB6E00",mdxType:"Highlight"},(0,l.kt)("strong",{parentName:"td"},"weighted")),"/",(0,l.kt)(s,{color:"#FB6E00",mdxType:"Highlight"},(0,l.kt)("strong",{parentName:"td"},"unweighted")))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"Parallelism")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)(s,{color:"#FB6E00",mdxType:"Highlight"},(0,l.kt)("strong",{parentName:"td"},"sequential")))))),(0,l.kt)("h3",{id:"procedures"},"Procedures"),(0,l.kt)("h3",{id:"remove_keyinput_map-key-recursive_map"},(0,l.kt)("inlineCode",{parentName:"h3"},"remove_key(input_map, key, recursive_map)")),(0,l.kt)("p",null,"Removes the specified key and its corresponding value from the input map. If the key does not exist in the input map, it will be ignored. Additionally, when the recursive setting is enabled, the key will also be removed from any inner maps that are part of the input map."),(0,l.kt)("h4",{id:"input"},"Input:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"input_map: Map")," \u27a1 the map from which the key will be removed."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"key: string")," \u27a1 the key to be removed from the map."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"recursive_map: bool")," \u27a1 ",(0,l.kt)("inlineCode",{parentName:"li"},"false")," by default, should be set to ",(0,l.kt)("inlineCode",{parentName:"li"},"true")," if the input map consists of values that are also maps and, therefore, may have the key to be removed.")),(0,l.kt)("h4",{id:"output"},"Output:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"removed: Map")," \u27a1 the map after removing the specified key.")),(0,l.kt)("h4",{id:"usage"},"Usage:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cypher"},'CALL map.remove_key({c: "b", d: "ba"}, "c") YIELD removed RETURN removed;\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-plaintext"},'+----------------------------+\n| removed                    |\n+----------------------------+\n| {"d": "ba"}                |\n+----------------------------+\n')),(0,l.kt)("p",null,"Example with recursion:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cypher"},'CALL map.remove_key({c: "b", d: {e: "ba", c: "h", a: {c: "z"}}}, "c", true) YIELD removed RETURN removed;\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-plaintext"},'+----------------------------+\n| removed                    |\n+----------------------------+\n| {"d": {"e": "ba"}}         |\n+----------------------------+\n')),(0,l.kt)("h3",{id:"from_pairsinput_list"},(0,l.kt)("inlineCode",{parentName:"h3"},"from_pairs(input_list)")),(0,l.kt)("p",null,"Creates a map from a list of pairs, where each pair is essentially another list of size 2. The first element in each pair must be of type ",(0,l.kt)("inlineCode",{parentName:"p"},"string"),", as it will be used as a key in the resulting map."),(0,l.kt)("h4",{id:"input-1"},"Input:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"input_list: List[List]")," \u27a1 list of pairs.")),(0,l.kt)("h4",{id:"output-1"},"Output:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"map: Map")," \u27a1 a map whose keys are the first elements in pairs, and the corresponding values are the second elements in the pairs.")),(0,l.kt)("h4",{id:"usage-1"},"Usage:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cypher"},'CALL map.from_pairs([["b", 3], ["c", "c"]]) YIELD map RETURN map;\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-plaintext"},'+----------------------------+\n| map                        |\n+----------------------------+\n| {"b": 3, "c": "c"}         |\n+----------------------------+\n')),(0,l.kt)("h3",{id:"mergeinput_map1-input_map2"},(0,l.kt)("inlineCode",{parentName:"h3"},"merge(input_map1, input_map2)")),(0,l.kt)("p",null,"Merges two maps into one. If the same key occurs twice, the later value will overwrite the previous one."),(0,l.kt)("h4",{id:"input-2"},"Input:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"input_map1: Map")," \u27a1 a map containing key-value pairs that need to be merged with others."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"input_map2: Map")," \u27a1 another map containing key-value pairs that need to be merged with others.")),(0,l.kt)("h4",{id:"output-2"},"Output:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"merged: Map")," \u27a1 merged input maps.")),(0,l.kt)("h4",{id:"usage-2"},"Usage:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cypher"},'CALL map.merge({a: "b", c: "d"}, {e: "f", g: "h"}) YIELD merged RETURN merged;\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-plaintext"},'+----------------------------------------+\n| merged                                 |\n+----------------------------------------+\n| {a: "b", c: "d", e: "f", g: "h"}       |\n+----------------------------------------+\n')),(0,l.kt)("h3",{id:"flattenmap-delimiter"},(0,l.kt)("inlineCode",{parentName:"h3"},"flatten(map, delimiter)")),(0,l.kt)("p",null,"Flattens nested items in the input map."),(0,l.kt)("h4",{id:"input-3"},"Input:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"map: Map[Any]")," \u27a1 the map used in ",(0,l.kt)("inlineCode",{parentName:"li"},"flatten"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},'delimiter: string (default = ".")')," \u27a1 the delimiter used for flattening.")),(0,l.kt)("h4",{id:"output-3"},"Output:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"result: Map[Any]")," \u27a1 flattened map, sorted alphabetically by keys.")),(0,l.kt)("h4",{id:"usage-3"},"Usage:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cypher"},'CALL map.flatten({a: {b:3, d:4}},"/") YIELD result RETURN result;\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-plaintext"},'+----------------------------------------+\n| result                                 |\n+----------------------------------------+\n| {"a/b": 3, "a/d": 4}                   |\n+----------------------------------------+\n')),(0,l.kt)("h3",{id:"from_listslist_keys-list_values"},(0,l.kt)("inlineCode",{parentName:"h3"},"from_lists(list_keys, list_values)")),(0,l.kt)("p",null,"Makes a map from lists of keys and corresponding values."),(0,l.kt)("h4",{id:"input-4"},"Input:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"list_keys: List[string]")," \u27a1 the list of keys."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"list_values")," \u27a1 the list of values.")),(0,l.kt)("h4",{id:"output-4"},"Output:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"result: Map[Any]")," \u27a1 the resulting map.")),(0,l.kt)("h4",{id:"usage-4"},"Usage:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cypher"},'CALL map.from_lists(["key","key2"],[1,2]) YIELD result RETURN result;\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-plaintext"},'+----------------------------------------+\n| result                                 |\n+----------------------------------------+\n| {""key": 1, "key2": 2}                 |\n+----------------------------------------+\n')),(0,l.kt)("h3",{id:"remove_keysinput_map-keys_list-recursive"},(0,l.kt)("inlineCode",{parentName:"h3"},"remove_keys(input_map, keys_list, recursive)")),(0,l.kt)("p",null,"Removes keys from input map. If recursive option is true, will remove keys from maps nested inside the map. "),(0,l.kt)("h4",{id:"input-5"},"Input:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"input_map: Map[Any]")," \u27a1 the input map."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"keys_list: List[string]")," \u27a1 the list of keys that will be removed."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"recursive: boolean (default = false)")," \u27a1 true if keys from nested map shall be removed, false if not.")),(0,l.kt)("h4",{id:"output-5"},"Output:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"result: Map[Any]")," \u27a1 the resulting map.")),(0,l.kt)("h4",{id:"usage-5"},"Usage:"),(0,l.kt)("p",null,"Usage when ",(0,l.kt)("inlineCode",{parentName:"p"},"recursive")," is ",(0,l.kt)("inlineCode",{parentName:"p"},"false"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cypher"},'CALL map.remove_keys({key: 1, key2:{key : 3, key3: 5}},["key"],false) YIELD result RETURN result;\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-plaintext"},'+----------------------------------------+\n| result                                 |\n+----------------------------------------+\n|{"key2": {"key": 3,"key3": 5}}          |\n+----------------------------------------+\n')),(0,l.kt)("p",null,"Usage with recursive = true:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cypher"},'CALL map.remove_keys({key: 1, key2:{key : 3, key3: 5}},["key"],true) YIELD result RETURN result;\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-plaintext"},'+----------------------------------------+\n| result                                 |\n+----------------------------------------+\n|{"key2": {"key3": 5}}                   |\n+----------------------------------------+\n')),(0,l.kt)("h3",{id:"from_nodeslabel-property"},(0,l.kt)("inlineCode",{parentName:"h3"},"from_nodes(label, property)")),(0,l.kt)("p",null,"Returns a map of all nodes which contain the given label and property. The key of each map element will be the value of the property (if it is convertible to a string, otherwise throws ",(0,l.kt)("inlineCode",{parentName:"p"},"ValueException"),")."),(0,l.kt)("h4",{id:"input-6"},"Input:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"label: string")," \u27a1 the wanted label."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"property: string")," \u27a1 the wanted property.")),(0,l.kt)("h4",{id:"output-6"},"Output:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"result: Map")," \u27a1 the resulting map.")),(0,l.kt)("h4",{id:"usage-6"},"Usage:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cypher"},'CREATE (Oppenheimer:Movie {title:\'Oppenheimer\', released:2023});\nCREATE (Barbie:Movie {title:"Barbie", released:2023});\nCREATE (Shawshank:Movie {title:\'The Shawshank Redemption\', released:1994});\n\nCALL map.from_nodes("Movie", "title") YIELD map RETURN map;\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-plaintext"},'{\n   "Barbie": {\n      "identity": 53,\n      "labels": [\n         "Movie"\n      ],\n      "properties": {\n         "released": 2023,\n         "title": "Barbie"\n      }\n   },\n   "Oppenheimer": {\n      "identity": 52,\n      "labels": [\n         "Movie"\n      ],\n      "properties": {\n         "released": 2023,\n         "title": "Oppenheimer"\n      }\n   },\n   "The Shawshank Redemption": {\n      "identity": 54,\n      "labels": [\n         "Movie"\n      ],\n      "properties": {\n         "released": 1994,\n         "title": "The Shawshank Redemption"\n      }\n   }\n}\n')),(0,l.kt)("h3",{id:"from_valuesvalues"},(0,l.kt)("inlineCode",{parentName:"h3"},"from_values(values)")),(0,l.kt)("p",null,"Returns a map from the given list of values. The list has the format: ",(0,l.kt)("inlineCode",{parentName:"p"},"[key1, value1, key2, value2]"),". If the key is not convertible to a string, throws ",(0,l.kt)("inlineCode",{parentName:"p"},"ValueException"),"."),(0,l.kt)("h4",{id:"input-7"},"Input:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"values: List[Any]")," \u27a1 list of values.")),(0,l.kt)("h4",{id:"output-7"},"Output:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"map: Map")," \u27a1 the resulting map.")),(0,l.kt)("h4",{id:"usage-7"},"Usage:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cypher"},'CALL map.from_values(["day", "sunny", 5, 6]) YIELD map RETURN map;\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-plaintext"},'+----------------------------------------+\n|        map                             |\n+----------------------------------------+\n| {"5": 6, "day": "sunny"}               |\n+----------------------------------------+\n')),(0,l.kt)("h3",{id:"set_keymap-key-value"},(0,l.kt)("inlineCode",{parentName:"h3"},"set_key(map, key, value)")),(0,l.kt)("p",null,"Updates the value at the position ",(0,l.kt)("inlineCode",{parentName:"p"},"key")," in ",(0,l.kt)("inlineCode",{parentName:"p"},"map"),". If the key doesn't exist, inserts it."),(0,l.kt)("h4",{id:"input-8"},"Input:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"map: Map")," \u27a1 map to be modified."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"key: string")," \u27a1 the position in ",(0,l.kt)("inlineCode",{parentName:"li"},"map")," to be updated."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"value: any")," \u27a1 new value at the position ",(0,l.kt)("inlineCode",{parentName:"li"},"key")," in ",(0,l.kt)("inlineCode",{parentName:"li"},"map"),".")),(0,l.kt)("h4",{id:"output-8"},"Output:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"map: Map")," \u27a1 the modified map.")),(0,l.kt)("h4",{id:"usage-8"},"Usage:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cypher"},'CALL map.set_key({name:"Ivan",country:"Croatia"}, "name", "Matija") YIELD map RETURN map;\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-plaintext"},'+-------------------------------------------+\n|                     map                   |\n+-------------------------------------------+\n| {"country": "Croatia", "name": "Matija"}  |\n+-------------------------------------------+\n')))}d.isMDXComponent=!0},83523:(e,t,a)=>{a.d(t,{ZP:()=>i});var n=a(87462),l=(a(67294),a(3905));const r={toc:[]};function i(e){let{components:t,...a}=e;return(0,l.kt)("wrapper",(0,n.Z)({},r,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("admonition",{type:"info"},(0,l.kt)("p",{parentName:"admonition"},"If you want to execute this algorithm on graph projections, subgraphs or portions\nof the graph, be sure to check out the guide on\n",(0,l.kt)("a",{parentName:"p",href:"/mage/how-to-guides/run-a-subgraph-module"},"How to run a MAGE module on subgraphs"),".")))}i.isMDXComponent=!0},85162:(e,t,a)=>{a.d(t,{Z:()=>i});var n=a(67294),l=a(86010);const r="tabItem_Ymn6";function i(e){let{children:t,hidden:a,className:i}=e;return n.createElement("div",{role:"tabpanel",className:(0,l.Z)(r,i),hidden:a},t)}},74866:(e,t,a)=>{a.d(t,{Z:()=>_});var n=a(87462),l=a(67294),r=a(86010),i=a(12466),u=a(16550),p=a(91980),o=a(67392),s=a(50012);function m(e){return function(e){var t;return(null==(t=l.Children.map(e,(e=>{if(!e||(0,l.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})))?void 0:t.filter(Boolean))??[]}(e).map((e=>{let{props:{value:t,label:a,attributes:n,default:l}}=e;return{value:t,label:a,attributes:n,default:l}}))}function d(e){const{values:t,children:a}=e;return(0,l.useMemo)((()=>{const e=t??m(a);return function(e){const t=(0,o.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,a])}function c(e){let{value:t,tabValues:a}=e;return a.some((e=>e.value===t))}function k(e){let{queryString:t=!1,groupId:a}=e;const n=(0,u.k6)(),r=function(e){let{queryString:t=!1,groupId:a}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:t,groupId:a});return[(0,p._X)(r),(0,l.useCallback)((e=>{if(!r)return;const t=new URLSearchParams(n.location.search);t.set(r,e),n.replace({...n.location,search:t.toString()})}),[r,n])]}function h(e){const{defaultValue:t,queryString:a=!1,groupId:n}=e,r=d(e),[i,u]=(0,l.useState)((()=>function(e){let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!c({value:t,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${a.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const n=a.find((e=>e.default))??a[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:r}))),[p,o]=k({queryString:a,groupId:n}),[m,h]=function(e){let{groupId:t}=e;const a=function(e){return e?`docusaurus.tab.${e}`:null}(t),[n,r]=(0,s.Nk)(a);return[n,(0,l.useCallback)((e=>{a&&r.set(e)}),[a,r])]}({groupId:n}),g=(()=>{const e=p??m;return c({value:e,tabValues:r})?e:null})();(0,l.useLayoutEffect)((()=>{g&&u(g)}),[g]);return{selectedValue:i,selectValue:(0,l.useCallback)((e=>{if(!c({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);u(e),o(e),h(e)}),[o,h,r]),tabValues:r}}var g=a(72389);const v="tabList__CuJ",y="tabItem_LNqP";function f(e){let{className:t,block:a,selectedValue:u,selectValue:p,tabValues:o}=e;const s=[],{blockElementScrollPositionUntilNextRender:m}=(0,i.o5)(),d=e=>{const t=e.currentTarget,a=s.indexOf(t),n=o[a].value;n!==u&&(m(t),p(n))},c=e=>{var t;let a=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const t=s.indexOf(e.currentTarget)+1;a=s[t]??s[0];break}case"ArrowLeft":{const t=s.indexOf(e.currentTarget)-1;a=s[t]??s[s.length-1];break}}null==(t=a)||t.focus()};return l.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":a},t)},o.map((e=>{let{value:t,label:a,attributes:i}=e;return l.createElement("li",(0,n.Z)({role:"tab",tabIndex:u===t?0:-1,"aria-selected":u===t,key:t,ref:e=>s.push(e),onKeyDown:c,onClick:d},i,{className:(0,r.Z)("tabs__item",y,null==i?void 0:i.className,{"tabs__item--active":u===t})}),a??t)})))}function N(e){let{lazy:t,children:a,selectedValue:n}=e;const r=(Array.isArray(a)?a:[a]).filter(Boolean);if(t){const e=r.find((e=>e.props.value===n));return e?(0,l.cloneElement)(e,{className:"margin-top--md"}):null}return l.createElement("div",{className:"margin-top--md"},r.map(((e,t)=>(0,l.cloneElement)(e,{key:t,hidden:e.props.value!==n}))))}function b(e){const t=h(e);return l.createElement("div",{className:(0,r.Z)("tabs-container",v)},l.createElement(f,(0,n.Z)({},e,t)),l.createElement(N,(0,n.Z)({},e,t)))}function _(e){const t=(0,g.Z)();return l.createElement(b,(0,n.Z)({key:String(t)},e))}}}]);