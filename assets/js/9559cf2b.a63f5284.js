"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[21104],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),m=p(n),h=r,u=m["".concat(l,".").concat(h)]||m[h]||d[h]||o;return n?a.createElement(u,s(s({ref:t},c),{},{components:n})):a.createElement(u,s({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=m;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var p=2;p<o;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},66123:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>m,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var a=n(87462),r=(n(67294),n(3905)),o=n(41434);const s={sidebar_label:"pyg_translator",title:"gqlalchemy.transformations.translators.pyg_translator"},i=void 0,l={unversionedId:"reference/transformations/translators/pyg_translator",id:"reference/transformations/translators/pyg_translator",title:"gqlalchemy.transformations.translators.pyg_translator",description:"Used to translate Memgraph data to PyG graph representation and vice-versa. Only features of numerical types (e.g., float, double, and int) are allowed. They can be scalars, vectors or multi-dimensional tensors (PyG requirement). Each node feature has a unique name and each edge feature has a unique name. A feature is created via tensor assignment, which assigns a feature to each node/edge in the graph. The leading dimension of that tensor must be equal to the number of nodes/edges in the graph. You cannot assign a feature to a subset of the nodes/edges in the graph. Features of the same name must have the same dimensionality and data type.",source:"@site/gqlalchemy/reference/transformations/translators/pyg_translator.md",sourceDirName:"reference/transformations/translators",slug:"/reference/transformations/translators/pyg_translator",permalink:"/docs/gqlalchemy/reference/transformations/translators/pyg_translator",draft:!1,editUrl:"https://github.com/memgraph/docs/tree/master/gqlalchemy/reference/transformations/translators/pyg_translator.md",tags:[],version:"current",frontMatter:{sidebar_label:"pyg_translator",title:"gqlalchemy.transformations.translators.pyg_translator"},sidebar:"gqlalchemy",previous:{title:"dgl_translator",permalink:"/docs/gqlalchemy/reference/transformations/translators/dgl_translator"},next:{title:"nx_translator",permalink:"/docs/gqlalchemy/reference/transformations/translators/nx_translator"}},p={},c=[{value:"Methods",id:"methods",level:3},{value:"<code>__init__</code>",id:"__init__",level:4},{value:"Input",id:"input",level:5},{value:"<code>to_cypher_queries</code>",id:"to_cypher_queries",level:4},{value:"Input",id:"input-1",level:5},{value:"Example",id:"example",level:4},{value:"<code>get_instance</code>",id:"get_instance",level:4},{value:"Example",id:"example-1",level:4}],d={toc:c};function m(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)(o.ZP,{mdxType:"OptionalDependenciesNote"}),(0,r.kt)("p",null,"Used to translate Memgraph data to PyG graph representation and vice-versa. Only features of numerical types (e.g., float, double, and int) are allowed. They can be scalars, vectors or multi-dimensional tensors (PyG requirement). Each node feature has a unique name and each edge feature has a unique name. A feature is created via tensor assignment, which assigns a feature to each node/edge in the graph. The leading dimension of that tensor must be equal to the number of nodes/edges in the graph. You cannot assign a feature to a subset of the nodes/edges in the graph. Features of the same name must have the same dimensionality and data type."),(0,r.kt)("h3",{id:"methods"},"Methods"),(0,r.kt)("h4",{id:"__init__"},(0,r.kt)("inlineCode",{parentName:"h4"},"__init__")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'def __init__(self, \n    default_node_label="NODE",\n    default_edge_type="RELATIONSHIP",\n    host: str = mg_consts.MG_HOST,\n    port: int = mg_consts.MG_PORT,\n    username: str = mg_consts.MG_USERNAME,\n    password: str = mg_consts.MG_PASSWORD,\n    encrypted: bool = mg_consts.MG_ENCRYPTED,\n    client_name: str = mg_consts.MG_CLIENT_NAME,\n    lazy: bool = mg_consts.MG_LAZY,\n    ) -> None\n')),(0,r.kt)("p",null,"Initializes translator object with given parameters."),(0,r.kt)("h5",{id:"input"},"Input"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"default_node_label: str=NODE")," -> Default node label that will be given to nodes when no other can be inferred."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"default_edge_type: str=RELATIONSHIP")," -> Default edge type that will be given to edges when no other can be inferred."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"host: str=127.0.0.1")," -> Host connection info for connecting to the Memgraph instance."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"port: int=7687")," -> Port connection info for connecting to the Memgraph instance."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},'username: str=""')," -> Username connection info for connecting to the Memgraph instance."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},'password: str=""')," -> Password connection info for connecting to the Memgraph instance."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"encrypted: bool=False")," -> Encrypted flag for connecting to the Memgraph instance."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"client_name: str=GQLAlchemy")," -> Client name used for connecting to the Memgraph instance."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"lazy: bool=False")," -> Lazy flag for connecting to the Memgraph instance.")),(0,r.kt)("h4",{id:"to_cypher_queries"},(0,r.kt)("inlineCode",{parentName:"h4"},"to_cypher_queries")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def to_cypher_queries(self, graph) -> None\n")),(0,r.kt)("p",null,"Produces Cypher queries for data saved as part of the ",(0,r.kt)("inlineCode",{parentName:"p"},"PyG")," graph. The method handles both homogeneous and heterogeneous graphs. The method converts 1D, as well as multidimensional features. If there are some isolated nodes inside the graph, they won't get transferred. Nodes and edges created in Memgraph DB will, for consistency reasons, have the property ",(0,r.kt)("inlineCode",{parentName:"p"},"pyg_id")," set to the ",(0,r.kt)("inlineCode",{parentName:"p"},"id")," they have as part of the ",(0,r.kt)("inlineCode",{parentName:"p"},"PyG")," graph. Note that this method doesn't insert anything inside the database, it just creates Cypher queries."),(0,r.kt)("h5",{id:"input-1"},"Input"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"graph: Union[torch_geometric.data.Data, torch_geometric.data.HeteroData]"))),(0,r.kt)("h4",{id:"example"},"Example"),(0,r.kt)("p",null,"Use the following query to transfer ",(0,r.kt)("inlineCode",{parentName:"p"},"PyG")," graph to Cypher queries and execute them in Memgraph:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"memgraph = Memgraph()\npyg_graph = HeteroData(...)\nfor query in PyGTranslator().to_cypher_queries(pyg_graph):\n    memgraph.execute(query)\n")),(0,r.kt)("h4",{id:"get_instance"},(0,r.kt)("inlineCode",{parentName:"h4"},"get_instance")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def get_instance(self) -> dgl.DGLHeteroGraph\n")),(0,r.kt)("p",null,"Creates an instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"PyG")," graph from all edges that are inside Memgraph. Currently, isolated nodes are ignored because they don't contribute to message-passing neural networks. Only numerical features that are set on all nodes or all edges are transferred to the ",(0,r.kt)("inlineCode",{parentName:"p"},"PyG")," instance since this is ",(0,r.kt)("inlineCode",{parentName:"p"},"PyG's")," requirement. That means that any string value properties won't be transferred, as well as numerical properties that aren't set on all nodes. However, features that are of a type list are transferred to the ",(0,r.kt)("inlineCode",{parentName:"p"},"PyG")," instance and can be used as any other feature in the ",(0,r.kt)("inlineCode",{parentName:"p"},"PyG")," graph. Regardless of data residing inside the Memgraph database, the created ",(0,r.kt)("inlineCode",{parentName:"p"},"PyG")," graph is a heterograph instance."),(0,r.kt)("h4",{id:"example-1"},"Example"),(0,r.kt)("p",null,"Use the following block of code to create an instance of the ",(0,r.kt)("inlineCode",{parentName:"p"},"PyG")," graph from the data residing inside ",(0,r.kt)("inlineCode",{parentName:"p"},"Memgraph"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"pyg_translator = PyGTranslator()\npyg_graph = pyg_translator.get_instance()\n")))}m.isMDXComponent=!0},41434:(e,t,n)=>{n.d(t,{ZP:()=>s});var a=n(87462),r=(n(67294),n(3905));const o={toc:[]};function s(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},o,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The features below aren\u2019t included in the default GQLAlchemy installation. To\nuse them, make sure to ",(0,r.kt)("a",{parentName:"p",href:"/gqlalchemy/installation"},"install GQLAlchemy")," with the\nrelevant optional dependencies.")))}s.isMDXComponent=!0}}]);