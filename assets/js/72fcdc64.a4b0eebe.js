(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5060],{3905:function(t,e,n){"use strict";n.d(e,{Zo:function(){return u},kt:function(){return s}});var a=n(67294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function p(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function l(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?p(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):p(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function i(t,e){if(null==t)return{};var n,a,r=function(t,e){if(null==t)return{};var n,a,r={},p=Object.keys(t);for(a=0;a<p.length;a++)n=p[a],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var p=Object.getOwnPropertySymbols(t);for(a=0;a<p.length;a++)n=p[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var m=a.createContext({}),o=function(t){var e=a.useContext(m),n=e;return t&&(n="function"==typeof t?t(e):l(l({},e),t)),n},u=function(t){var e=o(t.components);return a.createElement(m.Provider,{value:e},t.children)},_={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},g=a.forwardRef((function(t,e){var n=t.components,r=t.mdxType,p=t.originalType,m=t.parentName,u=i(t,["components","mdxType","originalType","parentName"]),g=o(n),s=r,c=g["".concat(m,".").concat(s)]||g[s]||_[s]||p;return n?a.createElement(c,l(l({ref:e},u),{},{components:n})):a.createElement(c,l({ref:e},u))}));function s(t,e){var n=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var p=n.length,l=new Array(p);l[0]=g;var i={};for(var m in e)hasOwnProperty.call(e,m)&&(i[m]=e[m]);i.originalType=t,i.mdxType="string"==typeof t?t:r,l[1]=i;for(var o=2;o<p;o++)l[o]=n[o];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}g.displayName="MDXCreateElement"},40016:function(t,e,n){"use strict";n.r(e),n.d(e,{frontMatter:function(){return l},metadata:function(){return i},toc:function(){return m},default:function(){return u}});var a=n(22122),r=n(19756),p=(n(67294),n(3905)),l={id:"c-api",title:"Query modules C API",sidebar_label:"C API"},i={unversionedId:"reference-guide/query-modules/c-api",id:"version-1.3.0/reference-guide/query-modules/c-api",isDocsHomePage:!1,title:"Query modules C API",description:"This is the API documentation for mg_procedure.h which contains declarations of all functions that can be used to implement a query module procedure. The source file can be found in the Memgraph installation directory, under include/memgraph. On the standard Debian installation, this will be under /usr/include/memgraph.",source:"@site/memgraph_versioned_docs/version-1.3.0/reference-guide/query-modules/c-api.md",sourceDirName:"reference-guide/query-modules",slug:"/reference-guide/query-modules/c-api",permalink:"/memgraph/1.3.0/reference-guide/query-modules/c-api",editUrl:"https://github.com/memgraph/docs/tree/master/memgraph_versioned_docs/version-1.3.0/reference-guide/query-modules/c-api.md",version:"1.3.0",sidebar_label:"C API",frontMatter:{id:"c-api",title:"Query modules C API",sidebar_label:"C API"},sidebar:"version-1.3.0/memgraph",previous:{title:"Query modules",permalink:"/memgraph/1.3.0/reference-guide/query-modules"},next:{title:"Query modules Python API",permalink:"/memgraph/1.3.0/reference-guide/query-modules/python-api"}},m=[{value:"Classes",id:"classes",children:[]},{value:"Types",id:"types",children:[]},{value:"Functions",id:"functions",children:[]},{value:"Types Documentation",id:"types-documentation",children:[{value:"enum mgp_value_type",id:"enum-mgp_value_type",children:[]},{value:"typedef mgp_proc_cb",id:"typedef-mgp_proc_cb",children:[]}]},{value:"Functions Documentation",id:"functions-documentation",children:[{value:"function mgp_alloc",id:"function-mgp_alloc",children:[]},{value:"function mgp_aligned_alloc",id:"function-mgp_aligned_alloc",children:[]},{value:"function mgp_free",id:"function-mgp_free",children:[]},{value:"function mgp_value_destroy",id:"function-mgp_value_destroy",children:[]},{value:"function mgp_value_make_null",id:"function-mgp_value_make_null",children:[]},{value:"function mgp_value_make_bool",id:"function-mgp_value_make_bool",children:[]},{value:"function mgp_value_make_int",id:"function-mgp_value_make_int",children:[]},{value:"function mgp_value_make_double",id:"function-mgp_value_make_double",children:[]},{value:"function mgp_value_make_string",id:"function-mgp_value_make_string",children:[]},{value:"function mgp_value_make_list",id:"function-mgp_value_make_list",children:[]},{value:"function mgp_value_make_map",id:"function-mgp_value_make_map",children:[]},{value:"function mgp_value_make_vertex",id:"function-mgp_value_make_vertex",children:[]},{value:"function mgp_value_make_edge",id:"function-mgp_value_make_edge",children:[]},{value:"function mgp_value_make_path",id:"function-mgp_value_make_path",children:[]},{value:"function mgp_value_get_type",id:"function-mgp_value_get_type",children:[]},{value:"function mgp_value_is_null",id:"function-mgp_value_is_null",children:[]},{value:"function mgp_value_is_bool",id:"function-mgp_value_is_bool",children:[]},{value:"function mgp_value_is_int",id:"function-mgp_value_is_int",children:[]},{value:"function mgp_value_is_double",id:"function-mgp_value_is_double",children:[]},{value:"function mgp_value_is_string",id:"function-mgp_value_is_string",children:[]},{value:"function mgp_value_is_list",id:"function-mgp_value_is_list",children:[]},{value:"function mgp_value_is_map",id:"function-mgp_value_is_map",children:[]},{value:"function mgp_value_is_vertex",id:"function-mgp_value_is_vertex",children:[]},{value:"function mgp_value_is_edge",id:"function-mgp_value_is_edge",children:[]},{value:"function mgp_value_is_path",id:"function-mgp_value_is_path",children:[]},{value:"function mgp_value_get_bool",id:"function-mgp_value_get_bool",children:[]},{value:"function mgp_value_get_int",id:"function-mgp_value_get_int",children:[]},{value:"function mgp_value_get_double",id:"function-mgp_value_get_double",children:[]},{value:"function mgp_value_get_string",id:"function-mgp_value_get_string",children:[]},{value:"function mgp_value_get_list",id:"function-mgp_value_get_list",children:[]},{value:"function mgp_value_get_map",id:"function-mgp_value_get_map",children:[]},{value:"function mgp_value_get_vertex",id:"function-mgp_value_get_vertex",children:[]},{value:"function mgp_value_get_edge",id:"function-mgp_value_get_edge",children:[]},{value:"function mgp_value_get_path",id:"function-mgp_value_get_path",children:[]},{value:"function mgp_list_make_empty",id:"function-mgp_list_make_empty",children:[]},{value:"function mgp_list_destroy",id:"function-mgp_list_destroy",children:[]},{value:"function mgp_list_append",id:"function-mgp_list_append",children:[]},{value:"function mgp_list_append_extend",id:"function-mgp_list_append_extend",children:[]},{value:"function mgp_list_size",id:"function-mgp_list_size",children:[]},{value:"function mgp_list_capacity",id:"function-mgp_list_capacity",children:[]},{value:"function mgp_list_at",id:"function-mgp_list_at",children:[]},{value:"function mgp_map_make_empty",id:"function-mgp_map_make_empty",children:[]},{value:"function mgp_map_destroy",id:"function-mgp_map_destroy",children:[]},{value:"function mgp_map_insert",id:"function-mgp_map_insert",children:[]},{value:"function mgp_map_size",id:"function-mgp_map_size",children:[]},{value:"function mgp_map_at",id:"function-mgp_map_at",children:[]},{value:"function mgp_map_item_key",id:"function-mgp_map_item_key",children:[]},{value:"function mgp_map_item_value",id:"function-mgp_map_item_value",children:[]},{value:"function mgp_map_iter_items",id:"function-mgp_map_iter_items",children:[]},{value:"function mgp_map_items_iterator_destroy",id:"function-mgp_map_items_iterator_destroy",children:[]},{value:"function mgp_map_items_iterator_get",id:"function-mgp_map_items_iterator_get",children:[]},{value:"function mgp_map_items_iterator_next",id:"function-mgp_map_items_iterator_next",children:[]},{value:"function mgp_path_make_with_start",id:"function-mgp_path_make_with_start",children:[]},{value:"function mgp_path_copy",id:"function-mgp_path_copy",children:[]},{value:"function mgp_path_destroy",id:"function-mgp_path_destroy",children:[]},{value:"function mgp_path_expand",id:"function-mgp_path_expand",children:[]},{value:"function mgp_path_size",id:"function-mgp_path_size",children:[]},{value:"function mgp_path_vertex_at",id:"function-mgp_path_vertex_at",children:[]},{value:"function mgp_path_edge_at",id:"function-mgp_path_edge_at",children:[]},{value:"function mgp_path_equal",id:"function-mgp_path_equal",children:[]},{value:"function mgp_result_set_error_msg",id:"function-mgp_result_set_error_msg",children:[]},{value:"function mgp_result_new_record",id:"function-mgp_result_new_record",children:[]},{value:"function mgp_result_record_insert",id:"function-mgp_result_record_insert",children:[]},{value:"function mgp_properties_iterator_destroy",id:"function-mgp_properties_iterator_destroy",children:[]},{value:"function mgp_properties_iterator_get",id:"function-mgp_properties_iterator_get",children:[]},{value:"function mgp_properties_iterator_next",id:"function-mgp_properties_iterator_next",children:[]},{value:"function mgp_edges_iterator_destroy",id:"function-mgp_edges_iterator_destroy",children:[]},{value:"function mgp_vertex_get_id",id:"function-mgp_vertex_get_id",children:[]},{value:"function mgp_vertex_copy",id:"function-mgp_vertex_copy",children:[]},{value:"function mgp_vertex_destroy",id:"function-mgp_vertex_destroy",children:[]},{value:"function mgp_vertex_equal",id:"function-mgp_vertex_equal",children:[]},{value:"function mgp_vertex_labels_count",id:"function-mgp_vertex_labels_count",children:[]},{value:"function mgp_vertex_label_at",id:"function-mgp_vertex_label_at",children:[]},{value:"function mgp_vertex_has_label",id:"function-mgp_vertex_has_label",children:[]},{value:"function mgp_vertex_has_label_named",id:"function-mgp_vertex_has_label_named",children:[]},{value:"function mgp_vertex_get_property",id:"function-mgp_vertex_get_property",children:[]},{value:"function mgp_vertex_iter_properties",id:"function-mgp_vertex_iter_properties",children:[]},{value:"function mgp_vertex_iter_in_edges",id:"function-mgp_vertex_iter_in_edges",children:[]},{value:"function mgp_vertex_iter_out_edges",id:"function-mgp_vertex_iter_out_edges",children:[]},{value:"function mgp_edges_iterator_get",id:"function-mgp_edges_iterator_get",children:[]},{value:"function mgp_edges_iterator_next",id:"function-mgp_edges_iterator_next",children:[]},{value:"function mgp_edge_get_id",id:"function-mgp_edge_get_id",children:[]},{value:"function mgp_edge_copy",id:"function-mgp_edge_copy",children:[]},{value:"function mgp_edge_destroy",id:"function-mgp_edge_destroy",children:[]},{value:"function mgp_edge_equal",id:"function-mgp_edge_equal",children:[]},{value:"function mgp_edge_get_type",id:"function-mgp_edge_get_type",children:[]},{value:"function mgp_edge_get_from",id:"function-mgp_edge_get_from",children:[]},{value:"function mgp_edge_get_to",id:"function-mgp_edge_get_to",children:[]},{value:"function mgp_edge_get_property",id:"function-mgp_edge_get_property",children:[]},{value:"function mgp_edge_iter_properties",id:"function-mgp_edge_iter_properties",children:[]},{value:"function mgp_graph_get_vertex_by_id",id:"function-mgp_graph_get_vertex_by_id",children:[]},{value:"function mgp_vertices_iterator_destroy",id:"function-mgp_vertices_iterator_destroy",children:[]},{value:"function mgp_graph_iter_vertices",id:"function-mgp_graph_iter_vertices",children:[]},{value:"function mgp_vertices_iterator_get",id:"function-mgp_vertices_iterator_get",children:[]},{value:"function mgp_vertices_iterator_next",id:"function-mgp_vertices_iterator_next",children:[]},{value:"function mgp_type_any",id:"function-mgp_type_any",children:[]},{value:"function mgp_type_bool",id:"function-mgp_type_bool",children:[]},{value:"function mgp_type_string",id:"function-mgp_type_string",children:[]},{value:"function mgp_type_int",id:"function-mgp_type_int",children:[]},{value:"function mgp_type_float",id:"function-mgp_type_float",children:[]},{value:"function mgp_type_number",id:"function-mgp_type_number",children:[]},{value:"function mgp_type_map",id:"function-mgp_type_map",children:[]},{value:"function mgp_type_node",id:"function-mgp_type_node",children:[]},{value:"function mgp_type_relationship",id:"function-mgp_type_relationship",children:[]},{value:"function mgp_type_path",id:"function-mgp_type_path",children:[]},{value:"function mgp_type_list",id:"function-mgp_type_list",children:[]},{value:"function mgp_type_nullable",id:"function-mgp_type_nullable",children:[]},{value:"function mgp_module_add_read_procedure",id:"function-mgp_module_add_read_procedure",children:[]},{value:"function mgp_proc_add_arg",id:"function-mgp_proc_add_arg",children:[]},{value:"function mgp_proc_add_opt_arg",id:"function-mgp_proc_add_opt_arg",children:[]},{value:"function mgp_proc_add_result",id:"function-mgp_proc_add_result",children:[]},{value:"function mgp_proc_add_deprecated_result",id:"function-mgp_proc_add_deprecated_result",children:[]},{value:"function mgp_must_abort",id:"function-mgp_must_abort",children:[]}]}],o={toc:m};function u(t){var e=t.components,n=(0,r.Z)(t,["components"]);return(0,p.kt)("wrapper",(0,a.Z)({},o,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is the API documentation for ",(0,p.kt)("inlineCode",{parentName:"p"},"mg_procedure.h")," which contains declarations of all functions that can be used to implement a query module procedure. The source file can be found in the Memgraph installation directory, under ",(0,p.kt)("inlineCode",{parentName:"p"},"include/memgraph"),". On the standard Debian installation, this will be under ",(0,p.kt)("inlineCode",{parentName:"p"},"/usr/include/memgraph"),". "),(0,p.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,p.kt)("div",{parentName:"div",className:"admonition-heading"},(0,p.kt)("h5",{parentName:"div"},(0,p.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,p.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,p.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,p.kt)("div",{parentName:"div",className:"admonition-content"},(0,p.kt)("p",{parentName:"div"},(0,p.kt)("strong",{parentName:"p"},"NOTE:")," This part of the documentation is still under development. An updated version will soon be available."))),(0,p.kt)("h2",{id:"classes"},"Classes"),(0,p.kt)("table",null,(0,p.kt)("thead",{parentName:"table"},(0,p.kt)("tr",{parentName:"thead"},(0,p.kt)("th",{parentName:"tr",align:null}),(0,p.kt)("th",{parentName:"tr",align:null},"Name"))),(0,p.kt)("tbody",{parentName:"table"},(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},"mgp_label")," ",(0,p.kt)("br",null),"Label of a vertex.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},"mgp_edge_type")," ",(0,p.kt)("br",null),"Type of an edge.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},"mgp_property")," ",(0,p.kt)("br",null),"Reference to a named property value.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},"mgp_vertex_id")," ",(0,p.kt)("br",null),"ID of a vertex; valid during a single query execution.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},"mgp_edge_id")," ",(0,p.kt)("br",null),"ID of an edge; valid during a single query execution.")))),(0,p.kt)("h2",{id:"types"},"Types"),(0,p.kt)("table",null,(0,p.kt)("thead",{parentName:"table"},(0,p.kt)("tr",{parentName:"thead"},(0,p.kt)("th",{parentName:"tr",align:null}),(0,p.kt)("th",{parentName:"tr",align:null},"Name"))),(0,p.kt)("tbody",{parentName:"table"},(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"enum"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#enum-mgp_value_type"},"mgp_value_type"))," { MGP_VALUE_TYPE_NULL, MGP_VALUE_TYPE_BOOL, MGP_VALUE_TYPE_INT, MGP_VALUE_TYPE_DOUBLE, MGP_VALUE_TYPE_STRING, MGP_VALUE_TYPE_LIST, MGP_VALUE_TYPE_MAP, MGP_VALUE_TYPE_VERTEX, MGP_VALUE_TYPE_EDGE, MGP_VALUE_TYPE_PATH }",(0,p.kt)("br",null),"All available types that can be stored in a mgp_value.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"typedef void(",(0,p.kt)("em",{parentName:"td"},")(const struct mgp_list "),", const struct mgp_graph ",(0,p.kt)("em",{parentName:"td"},", struct mgp_result "),", struct mgp_memory *)"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#typedef-mgp_proc_cb"},"mgp_proc_cb"))," ",(0,p.kt)("br",null),"Entry-point for a query module procedure, invoked through openCypher.")))),(0,p.kt)("h2",{id:"functions"},"Functions"),(0,p.kt)("table",null,(0,p.kt)("thead",{parentName:"table"},(0,p.kt)("tr",{parentName:"thead"},(0,p.kt)("th",{parentName:"tr",align:null}),(0,p.kt)("th",{parentName:"tr",align:null},"Name"))),(0,p.kt)("tbody",{parentName:"table"},(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"void *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_alloc"},"mgp_alloc")),"(struct mgp_memory * memory, size_t size_in_bytes) ",(0,p.kt)("br",null),"Allocate a block of memory with given size in bytes.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"void *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_aligned_alloc"},"mgp_aligned_alloc")),"(struct mgp_memory * memory, size_t size_in_bytes, size_t alignment) ",(0,p.kt)("br",null),"Allocate an aligned block of memory with given size in bytes.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"void"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_free"},"mgp_free")),"(struct mgp_memory ",(0,p.kt)("em",{parentName:"td"}," memory, void ")," ptr) ",(0,p.kt)("br",null),"Deallocate an allocation from mgp_alloc or mgp_aligned_alloc.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"void"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_value_destroy"},"mgp_value_destroy")),"(struct mgp_value * val) ",(0,p.kt)("br",null),"Free the memory used by the given mgp_value instance.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct mgp_value *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_value_make_null"},"mgp_value_make_null")),"(struct mgp_memory * memory) ",(0,p.kt)("br",null),"Construct a value representing ",(0,p.kt)("inlineCode",{parentName:"td"},"null")," in openCypher.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct mgp_value *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_value_make_bool"},"mgp_value_make_bool")),"(int val, struct mgp_memory * memory) ",(0,p.kt)("br",null),"Construct a boolean value.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct mgp_value *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_value_make_int"},"mgp_value_make_int")),"(int64_t val, struct mgp_memory * memory) ",(0,p.kt)("br",null),"Construct an integer value.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct mgp_value *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_value_make_double"},"mgp_value_make_double")),"(double val, struct mgp_memory * memory) ",(0,p.kt)("br",null),"Construct a double floating point value.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct mgp_value *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_value_make_string"},"mgp_value_make_string")),"(const char ",(0,p.kt)("em",{parentName:"td"}," val, struct mgp_memory ")," memory) ",(0,p.kt)("br",null),"Construct a character string value from a NULL terminated string.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct mgp_value *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_value_make_list"},"mgp_value_make_list")),"(struct mgp_list * val) ",(0,p.kt)("br",null),"Create a mgp_value storing a mgp_list.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct mgp_value *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_value_make_map"},"mgp_value_make_map")),"(struct mgp_map * val) ",(0,p.kt)("br",null),"Create a mgp_value storing a mgp_map.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct mgp_value *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_value_make_vertex"},"mgp_value_make_vertex")),"(struct mgp_vertex * val) ",(0,p.kt)("br",null),"Create a mgp_value storing a mgp_vertex.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct mgp_value *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_value_make_edge"},"mgp_value_make_edge")),"(struct mgp_edge * val) ",(0,p.kt)("br",null),"Create a mgp_value storing a mgp_edge.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct mgp_value *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_value_make_path"},"mgp_value_make_path")),"(struct mgp_path * val) ",(0,p.kt)("br",null),"Create a mgp_value storing a mgp_path.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"enum ",(0,p.kt)("a",{parentName:"td",href:"#enum-mgp_value_type"},"mgp_value_type")),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_value_get_type"},"mgp_value_get_type")),"(const struct mgp_value * val) ",(0,p.kt)("br",null),"Return the type of the value contained in mgp_value.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"int"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_value_is_null"},"mgp_value_is_null")),"(const struct mgp_value * val) ",(0,p.kt)("br",null),"Return non-zero if the given mgp_value represents ",(0,p.kt)("inlineCode",{parentName:"td"},"null"),".")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"int"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_value_is_bool"},"mgp_value_is_bool")),"(const struct mgp_value * val) ",(0,p.kt)("br",null),"Return non-zero if the given mgp_value stores a boolean.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"int"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_value_is_int"},"mgp_value_is_int")),"(const struct mgp_value * val) ",(0,p.kt)("br",null),"Return non-zero if the given mgp_value stores an integer.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"int"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_value_is_double"},"mgp_value_is_double")),"(const struct mgp_value * val) ",(0,p.kt)("br",null),"Return non-zero if the given mgp_value stores a double floating-point.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"int"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_value_is_string"},"mgp_value_is_string")),"(const struct mgp_value * val) ",(0,p.kt)("br",null),"Return non-zero if the given mgp_value stores a character string.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"int"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_value_is_list"},"mgp_value_is_list")),"(const struct mgp_value * val) ",(0,p.kt)("br",null),"Return non-zero if the given mgp_value stores a list of values.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"int"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_value_is_map"},"mgp_value_is_map")),"(const struct mgp_value * val) ",(0,p.kt)("br",null),"Return non-zero if the given mgp_value stores a map of values.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"int"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_value_is_vertex"},"mgp_value_is_vertex")),"(const struct mgp_value * val) ",(0,p.kt)("br",null),"Return non-zero if the given mgp_value stores a vertex.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"int"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_value_is_edge"},"mgp_value_is_edge")),"(const struct mgp_value * val) ",(0,p.kt)("br",null),"Return non-zero if the given mgp_value stores an edge.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"int"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_value_is_path"},"mgp_value_is_path")),"(const struct mgp_value * val) ",(0,p.kt)("br",null),"Return non-zero if the given mgp_value stores a path.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"int"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_value_get_bool"},"mgp_value_get_bool")),"(const struct mgp_value * val) ",(0,p.kt)("br",null),"Return the contained boolean value.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"int64_t"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_value_get_int"},"mgp_value_get_int")),"(const struct mgp_value * val) ",(0,p.kt)("br",null),"Return the contained integer.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"double"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_value_get_double"},"mgp_value_get_double")),"(const struct mgp_value * val) ",(0,p.kt)("br",null),"Return the contained double floating-point.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"const char *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_value_get_string"},"mgp_value_get_string")),"(const struct mgp_value * val) ",(0,p.kt)("br",null),"Return the contained character string.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"const struct mgp_list *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_value_get_list"},"mgp_value_get_list")),"(const struct mgp_value * val) ",(0,p.kt)("br",null),"Return the contained list of values.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"const struct mgp_map *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_value_get_map"},"mgp_value_get_map")),"(const struct mgp_value * val) ",(0,p.kt)("br",null),"Return the contained map of values.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"const struct mgp_vertex *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_value_get_vertex"},"mgp_value_get_vertex")),"(const struct mgp_value * val) ",(0,p.kt)("br",null),"Return the contained vertex.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"const struct mgp_edge *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_value_get_edge"},"mgp_value_get_edge")),"(const struct mgp_value * val) ",(0,p.kt)("br",null),"Return the contained edge.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"const struct mgp_path *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_value_get_path"},"mgp_value_get_path")),"(const struct mgp_value * val) ",(0,p.kt)("br",null),"Return the contained path.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct mgp_list *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_list_make_empty"},"mgp_list_make_empty")),"(size_t capacity, struct mgp_memory * memory) ",(0,p.kt)("br",null),"Create an empty list with given capacity.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"void"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_list_destroy"},"mgp_list_destroy")),"(struct mgp_list * list) ",(0,p.kt)("br",null),"Free the memory used by the given mgp_list and contained elements.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"int"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_list_append"},"mgp_list_append")),"(struct mgp_list ",(0,p.kt)("em",{parentName:"td"}," list, const struct mgp_value ")," val) ",(0,p.kt)("br",null),"Append a copy of mgp_value to mgp_list if capacity allows.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"int"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_list_append_extend"},"mgp_list_append_extend")),"(struct mgp_list ",(0,p.kt)("em",{parentName:"td"}," list, const struct mgp_value ")," val) ",(0,p.kt)("br",null),"Append a copy of mgp_value to mgp_list increasing capacity if needed.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"size_t"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_list_size"},"mgp_list_size")),"(const struct mgp_list * list) ",(0,p.kt)("br",null),"Return the number of elements stored in mgp_list.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"size_t"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_list_capacity"},"mgp_list_capacity")),"(const struct mgp_list * list) ",(0,p.kt)("br",null),"Return the total number of elements for which there's already allocated memory in mgp_list.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"const struct mgp_value *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_list_at"},"mgp_list_at")),"(const struct mgp_list * list, size_t index) ",(0,p.kt)("br",null),"Return the element in mgp_list at given position.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct mgp_map *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_map_make_empty"},"mgp_map_make_empty")),"(struct mgp_memory * memory) ",(0,p.kt)("br",null),"Create an empty map of character strings to mgp_value instances.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"void"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_map_destroy"},"mgp_map_destroy")),"(struct mgp_map * map) ",(0,p.kt)("br",null),"Free the memory used by the given mgp_map and contained items.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"int"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_map_insert"},"mgp_map_insert")),"(struct mgp_map ",(0,p.kt)("em",{parentName:"td"}," map, const char ")," key, const struct mgp_value * value) ",(0,p.kt)("br",null),"Insert a new mapping from a NULL terminated character string to a value.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"size_t"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_map_size"},"mgp_map_size")),"(const struct mgp_map * map) ",(0,p.kt)("br",null),"Return the number of items stored in mgp_map.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"const struct mgp_value *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_map_at"},"mgp_map_at")),"(const struct mgp_map ",(0,p.kt)("em",{parentName:"td"}," map, const char ")," key) ",(0,p.kt)("br",null),"Return the mapped mgp_value to the given character string.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"const char *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_map_item_key"},"mgp_map_item_key")),"(const struct mgp_map_item * item) ",(0,p.kt)("br",null),"Get the key of the mapped item.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"const struct mgp_value *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_map_item_value"},"mgp_map_item_value")),"(const struct mgp_map_item * item) ",(0,p.kt)("br",null),"Get the value of the mapped item.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct mgp_map_items_iterator *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_map_iter_items"},"mgp_map_iter_items")),"(const struct mgp_map ",(0,p.kt)("em",{parentName:"td"}," map, struct mgp_memory ")," memory) ",(0,p.kt)("br",null),"Start iterating over items contained in the given map.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"void"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_map_items_iterator_destroy"},"mgp_map_items_iterator_destroy")),"(struct mgp_map_items_iterator * it) ",(0,p.kt)("br",null),"Deallocate memory used by mgp_map_items_iterator.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"const struct mgp_map_item *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_map_items_iterator_get"},"mgp_map_items_iterator_get")),"(const struct mgp_map_items_iterator * it) ",(0,p.kt)("br",null),"Get the current item pointed to by the iterator.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"const struct mgp_map_item *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_map_items_iterator_next"},"mgp_map_items_iterator_next")),"(struct mgp_map_items_iterator * it) ",(0,p.kt)("br",null),"Advance the iterator to the next item stored in map and return it.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct mgp_path *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_path_make_with_start"},"mgp_path_make_with_start")),"(const struct mgp_vertex ",(0,p.kt)("em",{parentName:"td"}," vertex, struct mgp_memory ")," memory) ",(0,p.kt)("br",null),"Create a path with the copy of the given starting vertex.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct mgp_path *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_path_copy"},"mgp_path_copy")),"(const struct mgp_path ",(0,p.kt)("em",{parentName:"td"}," path, struct mgp_memory ")," memory) ",(0,p.kt)("br",null),"Copy a mgp_path.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"void"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_path_destroy"},"mgp_path_destroy")),"(struct mgp_path * path) ",(0,p.kt)("br",null),"Free the memory used by the given mgp_path and contained vertices and edges.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"int"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_path_expand"},"mgp_path_expand")),"(struct mgp_path ",(0,p.kt)("em",{parentName:"td"}," path, const struct mgp_edge ")," edge) ",(0,p.kt)("br",null),"Append an edge continuing from the last vertex on the path.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"size_t"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_path_size"},"mgp_path_size")),"(const struct mgp_path * path) ",(0,p.kt)("br",null),"Return the number of edges in a mgp_path.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"const struct mgp_vertex *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_path_vertex_at"},"mgp_path_vertex_at")),"(const struct mgp_path * path, size_t index) ",(0,p.kt)("br",null),"Return the vertex from a path at given index.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"const struct mgp_edge *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_path_edge_at"},"mgp_path_edge_at")),"(const struct mgp_path * path, size_t index) ",(0,p.kt)("br",null),"Return the edge from a path at given index.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"int"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_path_equal"},"mgp_path_equal")),"(const struct mgp_path ",(0,p.kt)("em",{parentName:"td"}," p1, const struct mgp_path ")," p2) ",(0,p.kt)("br",null),"Return non-zero if given paths are equal, otherwise 0.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"int"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_result_set_error_msg"},"mgp_result_set_error_msg")),"(struct mgp_result ",(0,p.kt)("em",{parentName:"td"}," res, const char ")," error_msg) ",(0,p.kt)("br",null),"Set the error as the result of the procedure.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct mgp_result_record *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_result_new_record"},"mgp_result_new_record")),"(struct mgp_result * res) ",(0,p.kt)("br",null),"Create a new record for results.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"int"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_result_record_insert"},"mgp_result_record_insert")),"(struct mgp_result_record ",(0,p.kt)("em",{parentName:"td"}," record, const char ")," field_name, const struct mgp_value * val) ",(0,p.kt)("br",null),"Assign a value to a field in the given record.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"void"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_properties_iterator_destroy"},"mgp_properties_iterator_destroy")),"(struct mgp_properties_iterator * it) ",(0,p.kt)("br",null),"Free the memory used by a mgp_properties_iterator.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"const struct mgp_property *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_properties_iterator_get"},"mgp_properties_iterator_get")),"(const struct mgp_properties_iterator * it) ",(0,p.kt)("br",null),"Get the current property pointed to by the iterator.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"const struct mgp_property *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_properties_iterator_next"},"mgp_properties_iterator_next")),"(struct mgp_properties_iterator * it) ",(0,p.kt)("br",null),"Advance the iterator to the next property and return it.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"void"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_edges_iterator_destroy"},"mgp_edges_iterator_destroy")),"(struct mgp_edges_iterator * it) ",(0,p.kt)("br",null),"Free the memory used by a mgp_edges_iterator.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct mgp_vertex_id"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_vertex_get_id"},"mgp_vertex_get_id")),"(const struct mgp_vertex * v) ",(0,p.kt)("br",null),"Get the ID of given vertex.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct mgp_vertex *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_vertex_copy"},"mgp_vertex_copy")),"(const struct mgp_vertex ",(0,p.kt)("em",{parentName:"td"}," v, struct mgp_memory ")," memory) ",(0,p.kt)("br",null),"Copy a mgp_vertex.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"void"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_vertex_destroy"},"mgp_vertex_destroy")),"(struct mgp_vertex * v) ",(0,p.kt)("br",null),"Free the memory used by a mgp_vertex.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"int"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_vertex_equal"},"mgp_vertex_equal")),"(const struct mgp_vertex ",(0,p.kt)("em",{parentName:"td"}," v1, const struct mgp_vertex ")," v2) ",(0,p.kt)("br",null),"Return non-zero if given vertices are equal, otherwise 0.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"size_t"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_vertex_labels_count"},"mgp_vertex_labels_count")),"(const struct mgp_vertex * v) ",(0,p.kt)("br",null),"Return the number of labels a given vertex has.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct mgp_label"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_vertex_label_at"},"mgp_vertex_label_at")),"(const struct mgp_vertex * v, size_t index) ",(0,p.kt)("br",null),"Return mgp_label in mgp_vertex at given index.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"int"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_vertex_has_label"},"mgp_vertex_has_label")),"(const struct mgp_vertex * v, struct mgp_label label) ",(0,p.kt)("br",null),"Return non-zero if the given vertex has the given label.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"int"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_vertex_has_label_named"},"mgp_vertex_has_label_named")),"(const struct mgp_vertex ",(0,p.kt)("em",{parentName:"td"}," v, const char ")," label_name) ",(0,p.kt)("br",null),"Return non-zero if the given vertex has a label with given name.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct mgp_value *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_vertex_get_property"},"mgp_vertex_get_property")),"(const struct mgp_vertex ",(0,p.kt)("em",{parentName:"td"}," v, const char ")," property_name, struct mgp_memory * memory) ",(0,p.kt)("br",null),"Get a copy of a vertex property mapped to a given name.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct mgp_properties_iterator *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_vertex_iter_properties"},"mgp_vertex_iter_properties")),"(const struct mgp_vertex ",(0,p.kt)("em",{parentName:"td"}," v, struct mgp_memory ")," memory) ",(0,p.kt)("br",null),"Start iterating over properties stored in the given vertex.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct mgp_edges_iterator *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_vertex_iter_in_edges"},"mgp_vertex_iter_in_edges")),"(const struct mgp_vertex ",(0,p.kt)("em",{parentName:"td"}," v, struct mgp_memory ")," memory) ",(0,p.kt)("br",null),"Start iterating over inbound edges of the given vertex.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct mgp_edges_iterator *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_vertex_iter_out_edges"},"mgp_vertex_iter_out_edges")),"(const struct mgp_vertex ",(0,p.kt)("em",{parentName:"td"}," v, struct mgp_memory ")," memory) ",(0,p.kt)("br",null),"Start iterating over outbound edges of the given vertex.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"const struct mgp_edge *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_edges_iterator_get"},"mgp_edges_iterator_get")),"(const struct mgp_edges_iterator * it) ",(0,p.kt)("br",null),"Get the current edge pointed to by the iterator.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"const struct mgp_edge *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_edges_iterator_next"},"mgp_edges_iterator_next")),"(struct mgp_edges_iterator * it) ",(0,p.kt)("br",null),"Advance the iterator to the next edge and return it.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct mgp_edge_id"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_edge_get_id"},"mgp_edge_get_id")),"(const struct mgp_edge * e) ",(0,p.kt)("br",null),"Get the ID of given edge.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct mgp_edge *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_edge_copy"},"mgp_edge_copy")),"(const struct mgp_edge ",(0,p.kt)("em",{parentName:"td"}," e, struct mgp_memory ")," memory) ",(0,p.kt)("br",null),"Copy a mgp_edge.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"void"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_edge_destroy"},"mgp_edge_destroy")),"(struct mgp_edge * e) ",(0,p.kt)("br",null),"Free the memory used by a mgp_edge.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"int"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_edge_equal"},"mgp_edge_equal")),"(const struct mgp_edge ",(0,p.kt)("em",{parentName:"td"}," e1, const struct mgp_edge ")," e2) ",(0,p.kt)("br",null),"Return non-zero if given edges are equal, otherwise 0.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct mgp_edge_type"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_edge_get_type"},"mgp_edge_get_type")),"(const struct mgp_edge * e) ",(0,p.kt)("br",null),"Return the type of the given edge.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"const struct mgp_vertex *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_edge_get_from"},"mgp_edge_get_from")),"(const struct mgp_edge * e) ",(0,p.kt)("br",null),"Return the source vertex of the given edge.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"const struct mgp_vertex *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_edge_get_to"},"mgp_edge_get_to")),"(const struct mgp_edge * e) ",(0,p.kt)("br",null),"Return the destination vertex of the given edge.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct mgp_value *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_edge_get_property"},"mgp_edge_get_property")),"(const struct mgp_edge ",(0,p.kt)("em",{parentName:"td"}," e, const char ")," property_name, struct mgp_memory * memory) ",(0,p.kt)("br",null),"Get a copy of a edge property mapped to a given name.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct mgp_properties_iterator *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_edge_iter_properties"},"mgp_edge_iter_properties")),"(const struct mgp_edge ",(0,p.kt)("em",{parentName:"td"}," e, struct mgp_memory ")," memory) ",(0,p.kt)("br",null),"Start iterating over properties stored in the given edge.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct mgp_vertex *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_graph_get_vertex_by_id"},"mgp_graph_get_vertex_by_id")),"(const struct mgp_graph ",(0,p.kt)("em",{parentName:"td"}," g, struct mgp_vertex_id id, struct mgp_memory ")," memory) ",(0,p.kt)("br",null),"Return the vertex corresponding to given ID.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"void"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_vertices_iterator_destroy"},"mgp_vertices_iterator_destroy")),"(struct mgp_vertices_iterator * it) ",(0,p.kt)("br",null),"Free the memory used by a mgp_vertices_iterator.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct mgp_vertices_iterator *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_graph_iter_vertices"},"mgp_graph_iter_vertices")),"(const struct mgp_graph ",(0,p.kt)("em",{parentName:"td"}," g, struct mgp_memory ")," memory) ",(0,p.kt)("br",null),"Start iterating over vertices of the given graph.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"const struct mgp_vertex *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_vertices_iterator_get"},"mgp_vertices_iterator_get")),"(const struct mgp_vertices_iterator * it) ",(0,p.kt)("br",null),"Get the current vertex pointed to by the iterator.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"const struct mgp_vertex *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_vertices_iterator_next"},"mgp_vertices_iterator_next")),"(struct mgp_vertices_iterator * it) ",(0,p.kt)("br",null),"Advance the iterator to the next vertex and return it.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"const struct mgp_type *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_type_any"},"mgp_type_any")),"() ",(0,p.kt)("br",null),"Get the type representing any value that isn't ",(0,p.kt)("inlineCode",{parentName:"td"},"null"),".")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"const struct mgp_type *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_type_bool"},"mgp_type_bool")),"() ",(0,p.kt)("br",null),"Get the type representing boolean values.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"const struct mgp_type *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_type_string"},"mgp_type_string")),"() ",(0,p.kt)("br",null),"Get the type representing character string values.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"const struct mgp_type *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_type_int"},"mgp_type_int")),"() ",(0,p.kt)("br",null),"Get the type representing integer values.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"const struct mgp_type *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_type_float"},"mgp_type_float")),"() ",(0,p.kt)("br",null),"Get the type representing floating-point values.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"const struct mgp_type *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_type_number"},"mgp_type_number")),"() ",(0,p.kt)("br",null),"Get the type representing any number value.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"const struct mgp_type *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_type_map"},"mgp_type_map")),"() ",(0,p.kt)("br",null),"Get the type representing map values.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"const struct mgp_type *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_type_node"},"mgp_type_node")),"() ",(0,p.kt)("br",null),"Get the type representing graph node values.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"const struct mgp_type *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_type_relationship"},"mgp_type_relationship")),"() ",(0,p.kt)("br",null),"Get the type representing graph relationship values.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"const struct mgp_type *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_type_path"},"mgp_type_path")),"() ",(0,p.kt)("br",null),"Get the type representing a graph path (walk) from one node to another.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"const struct mgp_type *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_type_list"},"mgp_type_list")),"(const struct mgp_type * element_type) ",(0,p.kt)("br",null),"Build a type representing a list of values of given ",(0,p.kt)("inlineCode",{parentName:"td"},"element_type"),".")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"const struct mgp_type *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_type_nullable"},"mgp_type_nullable")),"(const struct mgp_type * type) ",(0,p.kt)("br",null),"Build a type representing either a ",(0,p.kt)("inlineCode",{parentName:"td"},"null")," value or a value of given ",(0,p.kt)("inlineCode",{parentName:"td"},"type"),".")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"struct mgp_proc *"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_module_add_read_procedure"},"mgp_module_add_read_procedure")),"(struct mgp_module ",(0,p.kt)("em",{parentName:"td"}," module, const char ")," name, ",(0,p.kt)("a",{parentName:"td",href:"#typedef-mgp_proc_cb"},"mgp_proc_cb")," cb) ",(0,p.kt)("br",null),"Register a read-only procedure with a module.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"int"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_proc_add_arg"},"mgp_proc_add_arg")),"(struct mgp_proc ",(0,p.kt)("em",{parentName:"td"}," proc, const char ")," name, const struct mgp_type * type) ",(0,p.kt)("br",null),"Add a required argument to a procedure.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"int"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_proc_add_opt_arg"},"mgp_proc_add_opt_arg")),"(struct mgp_proc ",(0,p.kt)("em",{parentName:"td"}," proc, const char ")," name, const struct mgp_type ",(0,p.kt)("em",{parentName:"td"}," type, const struct mgp_value ")," default_value) ",(0,p.kt)("br",null),"Add an optional argument with a default value to a procedure.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"int"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_proc_add_result"},"mgp_proc_add_result")),"(struct mgp_proc ",(0,p.kt)("em",{parentName:"td"}," proc, const char ")," name, const struct mgp_type * type) ",(0,p.kt)("br",null),"Add a result field to a procedure.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"int"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_proc_add_deprecated_result"},"mgp_proc_add_deprecated_result")),"(struct mgp_proc ",(0,p.kt)("em",{parentName:"td"}," proc, const char ")," name, const struct mgp_type * type) ",(0,p.kt)("br",null),"Add a result field to a procedure and mark it as deprecated.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"int"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("strong",{parentName:"td"},(0,p.kt)("a",{parentName:"strong",href:"#function-mgp_must_abort"},"mgp_must_abort")),"(const struct mgp_graph * graph) ",(0,p.kt)("br",null),"Return non-zero if the currently executing procedure should abort as soon as possible.")))),(0,p.kt)("h2",{id:"types-documentation"},"Types Documentation"),(0,p.kt)("h3",{id:"enum-mgp_value_type"},"enum mgp_value_type"),(0,p.kt)("table",null,(0,p.kt)("thead",{parentName:"table"},(0,p.kt)("tr",{parentName:"thead"},(0,p.kt)("th",{parentName:"tr",align:null},"Enumerator"))),(0,p.kt)("tbody",{parentName:"table"},(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"MGP_VALUE_TYPE_NULL")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"MGP_VALUE_TYPE_BOOL")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"MGP_VALUE_TYPE_INT")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"MGP_VALUE_TYPE_DOUBLE")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"MGP_VALUE_TYPE_STRING")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"MGP_VALUE_TYPE_LIST")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"MGP_VALUE_TYPE_MAP")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"MGP_VALUE_TYPE_VERTEX")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"MGP_VALUE_TYPE_EDGE")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"MGP_VALUE_TYPE_PATH")))),(0,p.kt)("p",null,"All available types that can be stored in a mgp_value. "),(0,p.kt)("h3",{id:"typedef-mgp_proc_cb"},"typedef mgp_proc_cb"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"typedef void(* mgp_proc_cb) (const struct mgp_list *, const struct mgp_graph *, struct mgp_result *, struct mgp_memory *);\n")),(0,p.kt)("p",null,"Entry-point for a query module procedure, invoked through openCypher.\nPassed in arguments will not live longer than the callback's execution. Therefore, you must not store them globally or use the passed in mgp_memory to allocate global resources. "),(0,p.kt)("h2",{id:"functions-documentation"},"Functions Documentation"),(0,p.kt)("h3",{id:"function-mgp_alloc"},"function mgp_alloc"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"void * mgp_alloc(\n    struct mgp_memory * memory,\n    size_t size_in_bytes\n)\n")),(0,p.kt)("p",null,"Allocate a block of memory with given size in bytes.\nUnlike malloc, this function is not thread-safe. ",(0,p.kt)("inlineCode",{parentName:"p"},"size_in_bytes")," must be greater than 0. The returned pointer must be freed with mgp_free. NULL is returned if unable to serve the requested allocation. "),(0,p.kt)("h3",{id:"function-mgp_aligned_alloc"},"function mgp_aligned_alloc"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"void * mgp_aligned_alloc(\n    struct mgp_memory * memory,\n    size_t size_in_bytes,\n    size_t alignment\n)\n")),(0,p.kt)("p",null,"Allocate an aligned block of memory with given size in bytes.\nUnlike malloc and aligned_alloc, this function is not thread-safe. ",(0,p.kt)("inlineCode",{parentName:"p"},"size_in_bytes")," must be greater than 0. ",(0,p.kt)("inlineCode",{parentName:"p"},"alignment")," must be a power of 2 value. The returned pointer must be freed with mgp_free. NULL is returned if unable to serve the requested allocation. "),(0,p.kt)("h3",{id:"function-mgp_free"},"function mgp_free"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"void mgp_free(\n    struct mgp_memory * memory,\n    void * ptr\n)\n")),(0,p.kt)("p",null,"Deallocate an allocation from mgp_alloc or mgp_aligned_alloc.\nUnlike free, this function is not thread-safe. If ",(0,p.kt)("inlineCode",{parentName:"p"},"ptr")," is NULL, this function does nothing. The behavior is undefined if ",(0,p.kt)("inlineCode",{parentName:"p"},"ptr")," is not a value returned from a prior mgp_alloc or mgp_aligned_alloc call with the corresponding ",(0,p.kt)("inlineCode",{parentName:"p"},"memory"),". "),(0,p.kt)("h3",{id:"function-mgp_value_destroy"},"function mgp_value_destroy"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"void mgp_value_destroy(\n    struct mgp_value * val\n)\n")),(0,p.kt)("p",null,"Free the memory used by the given mgp_value instance. "),(0,p.kt)("h3",{id:"function-mgp_value_make_null"},"function mgp_value_make_null"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"struct mgp_value * mgp_value_make_null(\n    struct mgp_memory * memory\n)\n")),(0,p.kt)("p",null,"Construct a value representing ",(0,p.kt)("inlineCode",{parentName:"p"},"null")," in openCypher.\nYou need to free the instance through mgp_value_destroy. NULL is returned if unable to allocate a mgp_value. "),(0,p.kt)("h3",{id:"function-mgp_value_make_bool"},"function mgp_value_make_bool"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"struct mgp_value * mgp_value_make_bool(\n    int val,\n    struct mgp_memory * memory\n)\n")),(0,p.kt)("p",null,"Construct a boolean value.\nNon-zero values represent ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),", while zero represents ",(0,p.kt)("inlineCode",{parentName:"p"},"false"),". You need to free the instance through mgp_value_destroy. NULL is returned if unable to allocate a mgp_value. "),(0,p.kt)("h3",{id:"function-mgp_value_make_int"},"function mgp_value_make_int"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"struct mgp_value * mgp_value_make_int(\n    int64_t val,\n    struct mgp_memory * memory\n)\n")),(0,p.kt)("p",null,"Construct an integer value.\nYou need to free the instance through mgp_value_destroy. NULL is returned if unable to allocate a mgp_value. "),(0,p.kt)("h3",{id:"function-mgp_value_make_double"},"function mgp_value_make_double"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"struct mgp_value * mgp_value_make_double(\n    double val,\n    struct mgp_memory * memory\n)\n")),(0,p.kt)("p",null,"Construct a double floating point value.\nYou need to free the instance through mgp_value_destroy. NULL is returned if unable to allocate a mgp_value. "),(0,p.kt)("h3",{id:"function-mgp_value_make_string"},"function mgp_value_make_string"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"struct mgp_value * mgp_value_make_string(\n    const char * val,\n    struct mgp_memory * memory\n)\n")),(0,p.kt)("p",null,"Construct a character string value from a NULL terminated string.\nYou need to free the instance through mgp_value_destroy. NULL is returned if unable to allocate a mgp_value. "),(0,p.kt)("h3",{id:"function-mgp_value_make_list"},"function mgp_value_make_list"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"struct mgp_value * mgp_value_make_list(\n    struct mgp_list * val\n)\n")),(0,p.kt)("p",null,"Create a mgp_value storing a mgp_list.\nYou need to free the instance through mgp_value_destroy. The ownership of the list is given to the created mgp_value and destroying the mgp_value will destroy the mgp_list. Therefore, if a mgp_value is successfully created you must not call mgp_list_destroy on the given list. NULL is returned if unable to allocate a mgp_value. "),(0,p.kt)("h3",{id:"function-mgp_value_make_map"},"function mgp_value_make_map"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"struct mgp_value * mgp_value_make_map(\n    struct mgp_map * val\n)\n")),(0,p.kt)("p",null,"Create a mgp_value storing a mgp_map.\nYou need to free the instance through mgp_value_destroy. The ownership of the map is given to the created mgp_value and destroying the mgp_value will destroy the mgp_map. Therefore, if a mgp_value is successfully created you must not call mgp_map_destroy on the given map. NULL is returned if unable to allocate a mgp_value. "),(0,p.kt)("h3",{id:"function-mgp_value_make_vertex"},"function mgp_value_make_vertex"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"struct mgp_value * mgp_value_make_vertex(\n    struct mgp_vertex * val\n)\n")),(0,p.kt)("p",null,"Create a mgp_value storing a mgp_vertex.\nYou need to free the instance through mgp_value_destroy. The ownership of the vertex is given to the created mgp_value and destroying the mgp_value will destroy the mgp_vertex. Therefore, if a mgp_value is successfully created you must not call mgp_vertex_destroy on the given vertex. NULL is returned if unable to allocate a mgp_value. "),(0,p.kt)("h3",{id:"function-mgp_value_make_edge"},"function mgp_value_make_edge"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"struct mgp_value * mgp_value_make_edge(\n    struct mgp_edge * val\n)\n")),(0,p.kt)("p",null,"Create a mgp_value storing a mgp_edge.\nYou need to free the instance through mgp_value_destroy. The ownership of the edge is given to the created mgp_value and destroying the mgp_value will destroy the mgp_edge. Therefore, if a mgp_value is successfully created you must not call mgp_edge_destroy on the given edge. NULL is returned if unable to allocate a mgp_value. "),(0,p.kt)("h3",{id:"function-mgp_value_make_path"},"function mgp_value_make_path"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"struct mgp_value * mgp_value_make_path(\n    struct mgp_path * val\n)\n")),(0,p.kt)("p",null,"Create a mgp_value storing a mgp_path.\nYou need to free the instance through mgp_value_destroy. The ownership of the path is given to the created mgp_value and destroying the mgp_value will destroy the mgp_path. Therefore, if a mgp_value is successfully created you must not call mgp_path_destroy on the given path. NULL is returned if unable to allocate a mgp_value. "),(0,p.kt)("h3",{id:"function-mgp_value_get_type"},"function mgp_value_get_type"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"enum mgp_value_type mgp_value_get_type(\n    const struct mgp_value * val\n)\n")),(0,p.kt)("p",null,"Return the type of the value contained in mgp_value. "),(0,p.kt)("h3",{id:"function-mgp_value_is_null"},"function mgp_value_is_null"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"int mgp_value_is_null(\n    const struct mgp_value * val\n)\n")),(0,p.kt)("p",null,"Return non-zero if the given mgp_value represents ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),". "),(0,p.kt)("h3",{id:"function-mgp_value_is_bool"},"function mgp_value_is_bool"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"int mgp_value_is_bool(\n    const struct mgp_value * val\n)\n")),(0,p.kt)("p",null,"Return non-zero if the given mgp_value stores a boolean. "),(0,p.kt)("h3",{id:"function-mgp_value_is_int"},"function mgp_value_is_int"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"int mgp_value_is_int(\n    const struct mgp_value * val\n)\n")),(0,p.kt)("p",null,"Return non-zero if the given mgp_value stores an integer. "),(0,p.kt)("h3",{id:"function-mgp_value_is_double"},"function mgp_value_is_double"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"int mgp_value_is_double(\n    const struct mgp_value * val\n)\n")),(0,p.kt)("p",null,"Return non-zero if the given mgp_value stores a double floating-point. "),(0,p.kt)("h3",{id:"function-mgp_value_is_string"},"function mgp_value_is_string"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"int mgp_value_is_string(\n    const struct mgp_value * val\n)\n")),(0,p.kt)("p",null,"Return non-zero if the given mgp_value stores a character string. "),(0,p.kt)("h3",{id:"function-mgp_value_is_list"},"function mgp_value_is_list"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"int mgp_value_is_list(\n    const struct mgp_value * val\n)\n")),(0,p.kt)("p",null,"Return non-zero if the given mgp_value stores a list of values. "),(0,p.kt)("h3",{id:"function-mgp_value_is_map"},"function mgp_value_is_map"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"int mgp_value_is_map(\n    const struct mgp_value * val\n)\n")),(0,p.kt)("p",null,"Return non-zero if the given mgp_value stores a map of values. "),(0,p.kt)("h3",{id:"function-mgp_value_is_vertex"},"function mgp_value_is_vertex"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"int mgp_value_is_vertex(\n    const struct mgp_value * val\n)\n")),(0,p.kt)("p",null,"Return non-zero if the given mgp_value stores a vertex. "),(0,p.kt)("h3",{id:"function-mgp_value_is_edge"},"function mgp_value_is_edge"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"int mgp_value_is_edge(\n    const struct mgp_value * val\n)\n")),(0,p.kt)("p",null,"Return non-zero if the given mgp_value stores an edge. "),(0,p.kt)("h3",{id:"function-mgp_value_is_path"},"function mgp_value_is_path"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"int mgp_value_is_path(\n    const struct mgp_value * val\n)\n")),(0,p.kt)("p",null,"Return non-zero if the given mgp_value stores a path. "),(0,p.kt)("h3",{id:"function-mgp_value_get_bool"},"function mgp_value_get_bool"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"int mgp_value_get_bool(\n    const struct mgp_value * val\n)\n")),(0,p.kt)("p",null,"Return the contained boolean value.\nNon-zero values represent ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),", while zero represents ",(0,p.kt)("inlineCode",{parentName:"p"},"false"),". The result is undefined if mgp_value does not contain the expected type. "),(0,p.kt)("h3",{id:"function-mgp_value_get_int"},"function mgp_value_get_int"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"int64_t mgp_value_get_int(\n    const struct mgp_value * val\n)\n")),(0,p.kt)("p",null,"Return the contained integer.\nThe result is undefined if mgp_value does not contain the expected type. "),(0,p.kt)("h3",{id:"function-mgp_value_get_double"},"function mgp_value_get_double"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"double mgp_value_get_double(\n    const struct mgp_value * val\n)\n")),(0,p.kt)("p",null,"Return the contained double floating-point.\nThe result is undefined if mgp_value does not contain the expected type. "),(0,p.kt)("h3",{id:"function-mgp_value_get_string"},"function mgp_value_get_string"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"const char * mgp_value_get_string(\n    const struct mgp_value * val\n)\n")),(0,p.kt)("p",null,"Return the contained character string.\nThe result is undefined if mgp_value does not contain the expected type. "),(0,p.kt)("h3",{id:"function-mgp_value_get_list"},"function mgp_value_get_list"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"const struct mgp_list * mgp_value_get_list(\n    const struct mgp_value * val\n)\n")),(0,p.kt)("p",null,"Return the contained list of values.\nThe result is undefined if mgp_value does not contain the expected type. "),(0,p.kt)("h3",{id:"function-mgp_value_get_map"},"function mgp_value_get_map"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"const struct mgp_map * mgp_value_get_map(\n    const struct mgp_value * val\n)\n")),(0,p.kt)("p",null,"Return the contained map of values.\nThe result is undefined if mgp_value does not contain the expected type. "),(0,p.kt)("h3",{id:"function-mgp_value_get_vertex"},"function mgp_value_get_vertex"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"const struct mgp_vertex * mgp_value_get_vertex(\n    const struct mgp_value * val\n)\n")),(0,p.kt)("p",null,"Return the contained vertex.\nThe result is undefined if mgp_value does not contain the expected type. "),(0,p.kt)("h3",{id:"function-mgp_value_get_edge"},"function mgp_value_get_edge"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"const struct mgp_edge * mgp_value_get_edge(\n    const struct mgp_value * val\n)\n")),(0,p.kt)("p",null,"Return the contained edge.\nThe result is undefined if mgp_value does not contain the expected type. "),(0,p.kt)("h3",{id:"function-mgp_value_get_path"},"function mgp_value_get_path"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"const struct mgp_path * mgp_value_get_path(\n    const struct mgp_value * val\n)\n")),(0,p.kt)("p",null,"Return the contained path.\nThe result is undefined if mgp_value does not contain the expected type. "),(0,p.kt)("h3",{id:"function-mgp_list_make_empty"},"function mgp_list_make_empty"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"struct mgp_list * mgp_list_make_empty(\n    size_t capacity,\n    struct mgp_memory * memory\n)\n")),(0,p.kt)("p",null,"Create an empty list with given capacity.\nYou need to free the created instance with mgp_list_destroy. The created list will have allocated enough memory for ",(0,p.kt)("inlineCode",{parentName:"p"},"capacity")," elements of mgp_value, but it will not contain any elements. Therefore, mgp_list_size will return 0. NULL is returned if unable to allocate a new list. "),(0,p.kt)("h3",{id:"function-mgp_list_destroy"},"function mgp_list_destroy"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"void mgp_list_destroy(\n    struct mgp_list * list\n)\n")),(0,p.kt)("p",null,"Free the memory used by the given mgp_list and contained elements. "),(0,p.kt)("h3",{id:"function-mgp_list_append"},"function mgp_list_append"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"int mgp_list_append(\n    struct mgp_list * list,\n    const struct mgp_value * val\n)\n")),(0,p.kt)("p",null,"Append a copy of mgp_value to mgp_list if capacity allows.\nThe list copies the given value and therefore does not take ownership of the original value. You still need to call mgp_value_destroy to free the original value. Return non-zero on success, or 0 if there's no capacity or memory to append the mgp_value to mgp_list. "),(0,p.kt)("h3",{id:"function-mgp_list_append_extend"},"function mgp_list_append_extend"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"int mgp_list_append_extend(\n    struct mgp_list * list,\n    const struct mgp_value * val\n)\n")),(0,p.kt)("p",null,"Append a copy of mgp_value to mgp_list increasing capacity if needed.\nThe list copies the given value and therefore does not take ownership of the original value. You still need to call mgp_value_destroy to free the original value. In case of a capacity change, the previously contained elements will move in memory and any references to them will be invalid. Return non-zero on success, or 0 if there's no memory to append the mgp_value to mgp_list. "),(0,p.kt)("h3",{id:"function-mgp_list_size"},"function mgp_list_size"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"size_t mgp_list_size(\n    const struct mgp_list * list\n)\n")),(0,p.kt)("p",null,"Return the number of elements stored in mgp_list. "),(0,p.kt)("h3",{id:"function-mgp_list_capacity"},"function mgp_list_capacity"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"size_t mgp_list_capacity(\n    const struct mgp_list * list\n)\n")),(0,p.kt)("p",null,"Return the total number of elements for which there's already allocated memory in mgp_list. "),(0,p.kt)("h3",{id:"function-mgp_list_at"},"function mgp_list_at"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"const struct mgp_value * mgp_list_at(\n    const struct mgp_list * list,\n    size_t index\n)\n")),(0,p.kt)("p",null,"Return the element in mgp_list at given position.\nNULL is returned if the index is not within mgp_list_size. "),(0,p.kt)("h3",{id:"function-mgp_map_make_empty"},"function mgp_map_make_empty"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"struct mgp_map * mgp_map_make_empty(\n    struct mgp_memory * memory\n)\n")),(0,p.kt)("p",null,"Create an empty map of character strings to mgp_value instances.\nYou need to free the created instance with mgp_map_destroy. NULL is returned if unable to allocate a new map. "),(0,p.kt)("h3",{id:"function-mgp_map_destroy"},"function mgp_map_destroy"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"void mgp_map_destroy(\n    struct mgp_map * map\n)\n")),(0,p.kt)("p",null,"Free the memory used by the given mgp_map and contained items. "),(0,p.kt)("h3",{id:"function-mgp_map_insert"},"function mgp_map_insert"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"int mgp_map_insert(\n    struct mgp_map * map,\n    const char * key,\n    const struct mgp_value * value\n)\n")),(0,p.kt)("p",null,"Insert a new mapping from a NULL terminated character string to a value.\nIf a mapping with the same key already exists, it is ",(0,p.kt)("em",{parentName:"p"},"not")," replaced. In case of insertion, both the string and the value are copied into the map. Therefore, the map does not take ownership of the original key nor value, so you still need to free their memory explicitly. Return non-zero on success, or 0 if there's no memory to insert a new mapping or a previous mapping already exists. "),(0,p.kt)("h3",{id:"function-mgp_map_size"},"function mgp_map_size"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"size_t mgp_map_size(\n    const struct mgp_map * map\n)\n")),(0,p.kt)("p",null,"Return the number of items stored in mgp_map. "),(0,p.kt)("h3",{id:"function-mgp_map_at"},"function mgp_map_at"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"const struct mgp_value * mgp_map_at(\n    const struct mgp_map * map,\n    const char * key\n)\n")),(0,p.kt)("p",null,"Return the mapped mgp_value to the given character string.\nNULL is returned if no mapping exists. "),(0,p.kt)("h3",{id:"function-mgp_map_item_key"},"function mgp_map_item_key"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"const char * mgp_map_item_key(\n    const struct mgp_map_item * item\n)\n")),(0,p.kt)("p",null,"Get the key of the mapped item. "),(0,p.kt)("h3",{id:"function-mgp_map_item_value"},"function mgp_map_item_value"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"const struct mgp_value * mgp_map_item_value(\n    const struct mgp_map_item * item\n)\n")),(0,p.kt)("p",null,"Get the value of the mapped item. "),(0,p.kt)("h3",{id:"function-mgp_map_iter_items"},"function mgp_map_iter_items"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"struct mgp_map_items_iterator * mgp_map_iter_items(\n    const struct mgp_map * map,\n    struct mgp_memory * memory\n)\n")),(0,p.kt)("p",null,"Start iterating over items contained in the given map.\nThe returned mgp_map_items_iterator needs to be deallocated with mgp_map_items_iterator_destroy. NULL is returned if unable to allocate a new iterator. "),(0,p.kt)("h3",{id:"function-mgp_map_items_iterator_destroy"},"function mgp_map_items_iterator_destroy"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"void mgp_map_items_iterator_destroy(\n    struct mgp_map_items_iterator * it\n)\n")),(0,p.kt)("p",null,"Deallocate memory used by mgp_map_items_iterator. "),(0,p.kt)("h3",{id:"function-mgp_map_items_iterator_get"},"function mgp_map_items_iterator_get"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"const struct mgp_map_item * mgp_map_items_iterator_get(\n    const struct mgp_map_items_iterator * it\n)\n")),(0,p.kt)("p",null,"Get the current item pointed to by the iterator.\nWhen the mgp_map_items_iterator_next is invoked, the returned pointer to mgp_map_item becomes invalid. On the other hand, pointers obtained with mgp_map_item_key and mgp_map_item_value remain valid throughout the lifetime of a map. Therefore, you can store the key as well as the value before, and use them after invoking mgp_map_items_iterator_next. NULL is returned if the end of the iteration has been reached. "),(0,p.kt)("h3",{id:"function-mgp_map_items_iterator_next"},"function mgp_map_items_iterator_next"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"const struct mgp_map_item * mgp_map_items_iterator_next(\n    struct mgp_map_items_iterator * it\n)\n")),(0,p.kt)("p",null,"Advance the iterator to the next item stored in map and return it.\nThe previous pointer obtained through mgp_map_items_iterator_get will be invalidated, but the pointers to key and value will remain valid. NULL is returned if the end of the iteration has been reached. "),(0,p.kt)("h3",{id:"function-mgp_path_make_with_start"},"function mgp_path_make_with_start"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"struct mgp_path * mgp_path_make_with_start(\n    const struct mgp_vertex * vertex,\n    struct mgp_memory * memory\n)\n")),(0,p.kt)("p",null,"Create a path with the copy of the given starting vertex.\nYou need to free the created instance with mgp_path_destroy. NULL is returned if unable to allocate a path. "),(0,p.kt)("h3",{id:"function-mgp_path_copy"},"function mgp_path_copy"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"struct mgp_path * mgp_path_copy(\n    const struct mgp_path * path,\n    struct mgp_memory * memory\n)\n")),(0,p.kt)("p",null,"Copy a mgp_path.\nReturned pointer must be freed with mgp_path_destroy. NULL is returned if unable to allocate a mgp_path. "),(0,p.kt)("h3",{id:"function-mgp_path_destroy"},"function mgp_path_destroy"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"void mgp_path_destroy(\n    struct mgp_path * path\n)\n")),(0,p.kt)("p",null,"Free the memory used by the given mgp_path and contained vertices and edges. "),(0,p.kt)("h3",{id:"function-mgp_path_expand"},"function mgp_path_expand"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"int mgp_path_expand(\n    struct mgp_path * path,\n    const struct mgp_edge * edge\n)\n")),(0,p.kt)("p",null,"Append an edge continuing from the last vertex on the path.\nThe edge is copied into the path. Therefore, the path does not take ownership of the original edge, so you still need to free the edge memory explicitly. The last vertex on the path will become the other endpoint of the given edge, as continued from the current last vertex. Return non-zero on success, or 0 if the current last vertex in the path is not part of the given edge. 0 is also returned if unable to allocate memory for path extension. "),(0,p.kt)("h3",{id:"function-mgp_path_size"},"function mgp_path_size"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"size_t mgp_path_size(\n    const struct mgp_path * path\n)\n")),(0,p.kt)("p",null,"Return the number of edges in a mgp_path. "),(0,p.kt)("h3",{id:"function-mgp_path_vertex_at"},"function mgp_path_vertex_at"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"const struct mgp_vertex * mgp_path_vertex_at(\n    const struct mgp_path * path,\n    size_t index\n)\n")),(0,p.kt)("p",null,"Return the vertex from a path at given index.\nThe valid index range is ","[0, mgp_path_size]",". NULL is returned if index is out of range. "),(0,p.kt)("h3",{id:"function-mgp_path_edge_at"},"function mgp_path_edge_at"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"const struct mgp_edge * mgp_path_edge_at(\n    const struct mgp_path * path,\n    size_t index\n)\n")),(0,p.kt)("p",null,"Return the edge from a path at given index.\nThe valid index range is ","[0, mgp_path_size - 1]",". NULL is returned if index is out of range. "),(0,p.kt)("h3",{id:"function-mgp_path_equal"},"function mgp_path_equal"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"int mgp_path_equal(\n    const struct mgp_path * p1,\n    const struct mgp_path * p2\n)\n")),(0,p.kt)("p",null,"Return non-zero if given paths are equal, otherwise 0. "),(0,p.kt)("h3",{id:"function-mgp_result_set_error_msg"},"function mgp_result_set_error_msg"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"int mgp_result_set_error_msg(\n    struct mgp_result * res,\n    const char * error_msg\n)\n")),(0,p.kt)("p",null,"Set the error as the result of the procedure.\nIf there's no memory for copying the error message, 0 is returned. "),(0,p.kt)("h3",{id:"function-mgp_result_new_record"},"function mgp_result_new_record"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"struct mgp_result_record * mgp_result_new_record(\n    struct mgp_result * res\n)\n")),(0,p.kt)("p",null,"Create a new record for results.\nThe previously returned pointer to mgp_result_record is no longer valid, and you must not use it. Return NULL if unable to allocate a mgp_result_record. "),(0,p.kt)("h3",{id:"function-mgp_result_record_insert"},"function mgp_result_record_insert"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"int mgp_result_record_insert(\n    struct mgp_result_record * record,\n    const char * field_name,\n    const struct mgp_value * val\n)\n")),(0,p.kt)("p",null,"Assign a value to a field in the given record.\nReturn 0 if there's no memory to copy the mgp_value to mgp_result_record or if the combination of ",(0,p.kt)("inlineCode",{parentName:"p"},"field_name")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"val")," does not satisfy the procedure's result signature. "),(0,p.kt)("h3",{id:"function-mgp_properties_iterator_destroy"},"function mgp_properties_iterator_destroy"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"void mgp_properties_iterator_destroy(\n    struct mgp_properties_iterator * it\n)\n")),(0,p.kt)("p",null,"Free the memory used by a mgp_properties_iterator. "),(0,p.kt)("h3",{id:"function-mgp_properties_iterator_get"},"function mgp_properties_iterator_get"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"const struct mgp_property * mgp_properties_iterator_get(\n    const struct mgp_properties_iterator * it\n)\n")),(0,p.kt)("p",null,"Get the current property pointed to by the iterator.\nWhen the mgp_properties_iterator_next is invoked, the previous mgp_property is invalidated and its value must not be used. NULL is returned if the end of the iteration has been reached. "),(0,p.kt)("h3",{id:"function-mgp_properties_iterator_next"},"function mgp_properties_iterator_next"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"const struct mgp_property * mgp_properties_iterator_next(\n    struct mgp_properties_iterator * it\n)\n")),(0,p.kt)("p",null,"Advance the iterator to the next property and return it.\nThe previous mgp_property obtained through mgp_properties_iterator_get will be invalidated, and you must not use its value. NULL is returned if the end of the iteration has been reached. "),(0,p.kt)("h3",{id:"function-mgp_edges_iterator_destroy"},"function mgp_edges_iterator_destroy"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"void mgp_edges_iterator_destroy(\n    struct mgp_edges_iterator * it\n)\n")),(0,p.kt)("p",null,"Free the memory used by a mgp_edges_iterator. "),(0,p.kt)("h3",{id:"function-mgp_vertex_get_id"},"function mgp_vertex_get_id"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"struct mgp_vertex_id mgp_vertex_get_id(\n    const struct mgp_vertex * v\n)\n")),(0,p.kt)("p",null,"Get the ID of given vertex.\nThe ID is only valid for a single query execution, you should never store it globally in a query module. "),(0,p.kt)("h3",{id:"function-mgp_vertex_copy"},"function mgp_vertex_copy"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"struct mgp_vertex * mgp_vertex_copy(\n    const struct mgp_vertex * v,\n    struct mgp_memory * memory\n)\n")),(0,p.kt)("p",null,"Copy a mgp_vertex.\nReturned pointer must be freed with mgp_vertex_destroy. NULL is returned if unable to allocate a mgp_vertex. "),(0,p.kt)("h3",{id:"function-mgp_vertex_destroy"},"function mgp_vertex_destroy"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"void mgp_vertex_destroy(\n    struct mgp_vertex * v\n)\n")),(0,p.kt)("p",null,"Free the memory used by a mgp_vertex. "),(0,p.kt)("h3",{id:"function-mgp_vertex_equal"},"function mgp_vertex_equal"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"int mgp_vertex_equal(\n    const struct mgp_vertex * v1,\n    const struct mgp_vertex * v2\n)\n")),(0,p.kt)("p",null,"Return non-zero if given vertices are equal, otherwise 0. "),(0,p.kt)("h3",{id:"function-mgp_vertex_labels_count"},"function mgp_vertex_labels_count"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"size_t mgp_vertex_labels_count(\n    const struct mgp_vertex * v\n)\n")),(0,p.kt)("p",null,"Return the number of labels a given vertex has. "),(0,p.kt)("h3",{id:"function-mgp_vertex_label_at"},"function mgp_vertex_label_at"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"struct mgp_label mgp_vertex_label_at(\n    const struct mgp_vertex * v,\n    size_t index\n)\n")),(0,p.kt)("p",null,"Return mgp_label in mgp_vertex at given index.\nIf the index is out of bounds, mgp_label.name is set to NULL. "),(0,p.kt)("h3",{id:"function-mgp_vertex_has_label"},"function mgp_vertex_has_label"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"int mgp_vertex_has_label(\n    const struct mgp_vertex * v,\n    struct mgp_label label\n)\n")),(0,p.kt)("p",null,"Return non-zero if the given vertex has the given label. "),(0,p.kt)("h3",{id:"function-mgp_vertex_has_label_named"},"function mgp_vertex_has_label_named"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"int mgp_vertex_has_label_named(\n    const struct mgp_vertex * v,\n    const char * label_name\n)\n")),(0,p.kt)("p",null,"Return non-zero if the given vertex has a label with given name. "),(0,p.kt)("h3",{id:"function-mgp_vertex_get_property"},"function mgp_vertex_get_property"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"struct mgp_value * mgp_vertex_get_property(\n    const struct mgp_vertex * v,\n    const char * property_name,\n    struct mgp_memory * memory\n)\n")),(0,p.kt)("p",null,"Get a copy of a vertex property mapped to a given name.\nReturned value must be freed with mgp_value_destroy. NULL is returned if unable to allocate a mgp_value. "),(0,p.kt)("h3",{id:"function-mgp_vertex_iter_properties"},"function mgp_vertex_iter_properties"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"struct mgp_properties_iterator * mgp_vertex_iter_properties(\n    const struct mgp_vertex * v,\n    struct mgp_memory * memory\n)\n")),(0,p.kt)("p",null,"Start iterating over properties stored in the given vertex.\nThe returned mgp_properties_iterator needs to be deallocated with mgp_properties_iterator_destroy. NULL is returned if unable to allocate a new iterator. "),(0,p.kt)("h3",{id:"function-mgp_vertex_iter_in_edges"},"function mgp_vertex_iter_in_edges"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"struct mgp_edges_iterator * mgp_vertex_iter_in_edges(\n    const struct mgp_vertex * v,\n    struct mgp_memory * memory\n)\n")),(0,p.kt)("p",null,"Start iterating over inbound edges of the given vertex.\nThe returned mgp_edges_iterator needs to be deallocated with mgp_edges_iterator_destroy. NULL is returned if unable to allocate a new iterator. "),(0,p.kt)("h3",{id:"function-mgp_vertex_iter_out_edges"},"function mgp_vertex_iter_out_edges"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"struct mgp_edges_iterator * mgp_vertex_iter_out_edges(\n    const struct mgp_vertex * v,\n    struct mgp_memory * memory\n)\n")),(0,p.kt)("p",null,"Start iterating over outbound edges of the given vertex.\nThe returned mgp_edges_iterator needs to be deallocated with mgp_edges_iterator_destroy. NULL is returned if unable to allocate a new iterator. "),(0,p.kt)("h3",{id:"function-mgp_edges_iterator_get"},"function mgp_edges_iterator_get"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"const struct mgp_edge * mgp_edges_iterator_get(\n    const struct mgp_edges_iterator * it\n)\n")),(0,p.kt)("p",null,"Get the current edge pointed to by the iterator.\nWhen the mgp_edges_iterator_next is invoked, the previous mgp_edge is invalidated and its value must not be used. NULL is returned if the end of the iteration has been reached. "),(0,p.kt)("h3",{id:"function-mgp_edges_iterator_next"},"function mgp_edges_iterator_next"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"const struct mgp_edge * mgp_edges_iterator_next(\n    struct mgp_edges_iterator * it\n)\n")),(0,p.kt)("p",null,"Advance the iterator to the next edge and return it.\nThe previous mgp_edge obtained through mgp_edges_iterator_get will be invalidated, and you must not use its value. NULL is returned if the end of the iteration has been reached. "),(0,p.kt)("h3",{id:"function-mgp_edge_get_id"},"function mgp_edge_get_id"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"struct mgp_edge_id mgp_edge_get_id(\n    const struct mgp_edge * e\n)\n")),(0,p.kt)("p",null,"Get the ID of given edge.\nThe ID is only valid for a single query execution, you should never store it globally in a query module. "),(0,p.kt)("h3",{id:"function-mgp_edge_copy"},"function mgp_edge_copy"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"struct mgp_edge * mgp_edge_copy(\n    const struct mgp_edge * e,\n    struct mgp_memory * memory\n)\n")),(0,p.kt)("p",null,"Copy a mgp_edge.\nReturned pointer must be freed with mgp_edge_destroy. NULL is returned if unable to allocate a mgp_edge. "),(0,p.kt)("h3",{id:"function-mgp_edge_destroy"},"function mgp_edge_destroy"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"void mgp_edge_destroy(\n    struct mgp_edge * e\n)\n")),(0,p.kt)("p",null,"Free the memory used by a mgp_edge. "),(0,p.kt)("h3",{id:"function-mgp_edge_equal"},"function mgp_edge_equal"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"int mgp_edge_equal(\n    const struct mgp_edge * e1,\n    const struct mgp_edge * e2\n)\n")),(0,p.kt)("p",null,"Return non-zero if given edges are equal, otherwise 0. "),(0,p.kt)("h3",{id:"function-mgp_edge_get_type"},"function mgp_edge_get_type"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"struct mgp_edge_type mgp_edge_get_type(\n    const struct mgp_edge * e\n)\n")),(0,p.kt)("p",null,"Return the type of the given edge. "),(0,p.kt)("h3",{id:"function-mgp_edge_get_from"},"function mgp_edge_get_from"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"const struct mgp_vertex * mgp_edge_get_from(\n    const struct mgp_edge * e\n)\n")),(0,p.kt)("p",null,"Return the source vertex of the given edge. "),(0,p.kt)("h3",{id:"function-mgp_edge_get_to"},"function mgp_edge_get_to"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"const struct mgp_vertex * mgp_edge_get_to(\n    const struct mgp_edge * e\n)\n")),(0,p.kt)("p",null,"Return the destination vertex of the given edge. "),(0,p.kt)("h3",{id:"function-mgp_edge_get_property"},"function mgp_edge_get_property"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"struct mgp_value * mgp_edge_get_property(\n    const struct mgp_edge * e,\n    const char * property_name,\n    struct mgp_memory * memory\n)\n")),(0,p.kt)("p",null,"Get a copy of a edge property mapped to a given name.\nReturned value must be freed with mgp_value_destroy. NULL is returned if unable to allocate a mgp_value. "),(0,p.kt)("h3",{id:"function-mgp_edge_iter_properties"},"function mgp_edge_iter_properties"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"struct mgp_properties_iterator * mgp_edge_iter_properties(\n    const struct mgp_edge * e,\n    struct mgp_memory * memory\n)\n")),(0,p.kt)("p",null,"Start iterating over properties stored in the given edge.\nThe returned mgp_properties_iterator needs to be deallocated with mgp_properties_iterator_destroy. NULL is returned if unable to allocate a new iterator. "),(0,p.kt)("h3",{id:"function-mgp_graph_get_vertex_by_id"},"function mgp_graph_get_vertex_by_id"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"struct mgp_vertex * mgp_graph_get_vertex_by_id(\n    const struct mgp_graph * g,\n    struct mgp_vertex_id id,\n    struct mgp_memory * memory\n)\n")),(0,p.kt)("p",null,"Return the vertex corresponding to given ID.\nThe returned vertex must be freed using mgp_vertex_destroy. NULL is returned if unable to allocate the vertex or if ID is not valid. "),(0,p.kt)("h3",{id:"function-mgp_vertices_iterator_destroy"},"function mgp_vertices_iterator_destroy"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"void mgp_vertices_iterator_destroy(\n    struct mgp_vertices_iterator * it\n)\n")),(0,p.kt)("p",null,"Free the memory used by a mgp_vertices_iterator. "),(0,p.kt)("h3",{id:"function-mgp_graph_iter_vertices"},"function mgp_graph_iter_vertices"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"struct mgp_vertices_iterator * mgp_graph_iter_vertices(\n    const struct mgp_graph * g,\n    struct mgp_memory * memory\n)\n")),(0,p.kt)("p",null,"Start iterating over vertices of the given graph.\nThe returned mgp_vertices_iterator needs to be deallocated with mgp_vertices_iterator_destroy. NULL is returned if unable to allocate a new iterator. "),(0,p.kt)("h3",{id:"function-mgp_vertices_iterator_get"},"function mgp_vertices_iterator_get"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"const struct mgp_vertex * mgp_vertices_iterator_get(\n    const struct mgp_vertices_iterator * it\n)\n")),(0,p.kt)("p",null,"Get the current vertex pointed to by the iterator.\nWhen the mgp_vertices_iterator_next is invoked, the previous mgp_vertex is invalidated and its value must not be used. NULL is returned if the end of the iteration has been reached. "),(0,p.kt)("h3",{id:"function-mgp_vertices_iterator_next"},"function mgp_vertices_iterator_next"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"const struct mgp_vertex * mgp_vertices_iterator_next(\n    struct mgp_vertices_iterator * it\n)\n")),(0,p.kt)("p",null,"Advance the iterator to the next vertex and return it.\nThe previous mgp_vertex obtained through mgp_vertices_iterator_get will be invalidated, and you must not use its value. NULL is returned if the end of the iteration has been reached. "),(0,p.kt)("h3",{id:"function-mgp_type_any"},"function mgp_type_any"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"const struct mgp_type * mgp_type_any()\n")),(0,p.kt)("p",null,"Get the type representing any value that isn't ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),".\nThe ANY type is the parent type of all types. "),(0,p.kt)("h3",{id:"function-mgp_type_bool"},"function mgp_type_bool"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"const struct mgp_type * mgp_type_bool()\n")),(0,p.kt)("p",null,"Get the type representing boolean values. "),(0,p.kt)("h3",{id:"function-mgp_type_string"},"function mgp_type_string"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"const struct mgp_type * mgp_type_string()\n")),(0,p.kt)("p",null,"Get the type representing character string values. "),(0,p.kt)("h3",{id:"function-mgp_type_int"},"function mgp_type_int"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"const struct mgp_type * mgp_type_int()\n")),(0,p.kt)("p",null,"Get the type representing integer values. "),(0,p.kt)("h3",{id:"function-mgp_type_float"},"function mgp_type_float"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"const struct mgp_type * mgp_type_float()\n")),(0,p.kt)("p",null,"Get the type representing floating-point values. "),(0,p.kt)("h3",{id:"function-mgp_type_number"},"function mgp_type_number"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"const struct mgp_type * mgp_type_number()\n")),(0,p.kt)("p",null,"Get the type representing any number value.\nThis is the parent type for numeric types, i.e. INTEGER and FLOAT. "),(0,p.kt)("h3",{id:"function-mgp_type_map"},"function mgp_type_map"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"const struct mgp_type * mgp_type_map()\n")),(0,p.kt)("p",null,"Get the type representing map values. "),(0,p.kt)("p",null,(0,p.kt)("strong",{parentName:"p"},"See"),": "),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("a",{parentName:"li",href:"#function-mgp_type_node"},"mgp_type_node")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("a",{parentName:"li",href:"#function-mgp_type_relationship"},"mgp_type_relationship"))),(0,p.kt)("p",null,"Map values are those which map string keys to values of any type. For example ",(0,p.kt)("inlineCode",{parentName:"p"},'{ database: "Memgraph", version: 1.42 }'),". Note that graph nodes contain property maps, so a node value will also satisfy the MAP type. The same applies for graph relationship values."),(0,p.kt)("h3",{id:"function-mgp_type_node"},"function mgp_type_node"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"const struct mgp_type * mgp_type_node()\n")),(0,p.kt)("p",null,"Get the type representing graph node values.\nSince a node contains a map of properties, the node itself is also of MAP type. "),(0,p.kt)("h3",{id:"function-mgp_type_relationship"},"function mgp_type_relationship"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"const struct mgp_type * mgp_type_relationship()\n")),(0,p.kt)("p",null,"Get the type representing graph relationship values.\nSince a relationship contains a map of properties, the relationship itself is also of MAP type. "),(0,p.kt)("h3",{id:"function-mgp_type_path"},"function mgp_type_path"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"const struct mgp_type * mgp_type_path()\n")),(0,p.kt)("p",null,"Get the type representing a graph path (walk) from one node to another. "),(0,p.kt)("h3",{id:"function-mgp_type_list"},"function mgp_type_list"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"const struct mgp_type * mgp_type_list(\n    const struct mgp_type * element_type\n)\n")),(0,p.kt)("p",null,"Build a type representing a list of values of given ",(0,p.kt)("inlineCode",{parentName:"p"},"element_type"),".\nNULL is returned if unable to allocate the new type. "),(0,p.kt)("h3",{id:"function-mgp_type_nullable"},"function mgp_type_nullable"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"const struct mgp_type * mgp_type_nullable(\n    const struct mgp_type * type\n)\n")),(0,p.kt)("p",null,"Build a type representing either a ",(0,p.kt)("inlineCode",{parentName:"p"},"null")," value or a value of given ",(0,p.kt)("inlineCode",{parentName:"p"},"type"),".\nNULL is returned if unable to allocate the new type. "),(0,p.kt)("h3",{id:"function-mgp_module_add_read_procedure"},"function mgp_module_add_read_procedure"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"struct mgp_proc * mgp_module_add_read_procedure(\n    struct mgp_module * module,\n    const char * name,\n    mgp_proc_cb cb\n)\n")),(0,p.kt)("p",null,"Register a read-only procedure with a module.\nThe ",(0,p.kt)("inlineCode",{parentName:"p"},"name")," must be a sequence of digits, underscores, lowercase and uppercase Latin letters. The name must begin with a non-digit character. Note that Unicode characters are not allowed. Additionally, names are case-sensitive."),(0,p.kt)("p",null,"NULL is returned if unable to allocate memory for mgp_proc; if ",(0,p.kt)("inlineCode",{parentName:"p"},"name")," is not valid or a procedure with the same name was already registered. "),(0,p.kt)("h3",{id:"function-mgp_proc_add_arg"},"function mgp_proc_add_arg"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"int mgp_proc_add_arg(\n    struct mgp_proc * proc,\n    const char * name,\n    const struct mgp_type * type\n)\n")),(0,p.kt)("p",null,"Add a required argument to a procedure.\nThe order of adding arguments will correspond to the order the procedure must receive them through openCypher. Required arguments will be followed by optional arguments."),(0,p.kt)("p",null,"The ",(0,p.kt)("inlineCode",{parentName:"p"},"name")," must be a valid identifier, following the same rules as the procedure",(0,p.kt)("inlineCode",{parentName:"p"},"name")," in mgp_module_add_read_procedure."),(0,p.kt)("p",null,"Passed in ",(0,p.kt)("inlineCode",{parentName:"p"},"type")," describes what kind of values can be used as the argument."),(0,p.kt)("p",null,"0 is returned if unable to allocate memory for an argument; if invoking this function after setting an optional argument or if ",(0,p.kt)("inlineCode",{parentName:"p"},"name")," is not valid. Non-zero is returned on success. "),(0,p.kt)("h3",{id:"function-mgp_proc_add_opt_arg"},"function mgp_proc_add_opt_arg"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"int mgp_proc_add_opt_arg(\n    struct mgp_proc * proc,\n    const char * name,\n    const struct mgp_type * type,\n    const struct mgp_value * default_value\n)\n")),(0,p.kt)("p",null,"Add an optional argument with a default value to a procedure.\nThe order of adding arguments will correspond to the order the procedure must receive them through openCypher. Optional arguments must follow the required arguments."),(0,p.kt)("p",null,"The ",(0,p.kt)("inlineCode",{parentName:"p"},"name")," must be a valid identifier, following the same rules as the procedure ",(0,p.kt)("inlineCode",{parentName:"p"},"name")," in mgp_module_add_read_procedure."),(0,p.kt)("p",null,"Passed in ",(0,p.kt)("inlineCode",{parentName:"p"},"type")," describes what kind of values can be used as the argument."),(0,p.kt)("p",null,(0,p.kt)("inlineCode",{parentName:"p"},"default_value")," is copied and set as the default value for the argument. Don't forget to call mgp_value_destroy when you are done using ",(0,p.kt)("inlineCode",{parentName:"p"},"default_value"),". When the procedure is called, if this argument is not provided, ",(0,p.kt)("inlineCode",{parentName:"p"},"default_value")," will be used instead. ",(0,p.kt)("inlineCode",{parentName:"p"},"default_value")," must not be a graph element (node, relationship, path) and it must satisfy the given ",(0,p.kt)("inlineCode",{parentName:"p"},"type"),"."),(0,p.kt)("p",null,"0 is returned if unable to allocate memory for an argument; if ",(0,p.kt)("inlineCode",{parentName:"p"},"name")," is not valid or ",(0,p.kt)("inlineCode",{parentName:"p"},"default_value")," does not satisfy ",(0,p.kt)("inlineCode",{parentName:"p"},"type"),". Non-zero is returned on success. "),(0,p.kt)("h3",{id:"function-mgp_proc_add_result"},"function mgp_proc_add_result"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"int mgp_proc_add_result(\n    struct mgp_proc * proc,\n    const char * name,\n    const struct mgp_type * type\n)\n")),(0,p.kt)("p",null,"Add a result field to a procedure.\nThe ",(0,p.kt)("inlineCode",{parentName:"p"},"name")," must be a valid identifier, following the same rules as the procedure ",(0,p.kt)("inlineCode",{parentName:"p"},"name")," in mgp_module_add_read_procedure."),(0,p.kt)("p",null,"Passed in ",(0,p.kt)("inlineCode",{parentName:"p"},"type")," describes what kind of values can be returned through the result field."),(0,p.kt)("p",null,"0 is returned if unable to allocate memory for a result field; if ",(0,p.kt)("inlineCode",{parentName:"p"},"name")," is not valid or if a result field with the same name was already added. Non-zero is returned on success. "),(0,p.kt)("h3",{id:"function-mgp_proc_add_deprecated_result"},"function mgp_proc_add_deprecated_result"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"int mgp_proc_add_deprecated_result(\n    struct mgp_proc * proc,\n    const char * name,\n    const struct mgp_type * type\n)\n")),(0,p.kt)("p",null,"Add a result field to a procedure and mark it as deprecated.\nThis is the same as mgp_proc_add_result, but the result field will be marked as deprecated. "),(0,p.kt)("h3",{id:"function-mgp_must_abort"},"function mgp_must_abort"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cpp"},"int mgp_must_abort(\n    const struct mgp_graph * graph\n)\n")),(0,p.kt)("p",null,"Return non-zero if the currently executing procedure should abort as soon as possible.\nProcedures which perform heavyweight processing run the risk of running too long and going over the query execution time limit. To prevent this, such procedures should periodically call this function at critical points in their code in order to determine whether they should abort or not. Note that this mechanism is purely cooperative and depends on the procedure doing the checking and aborting on its own."))}u.isMDXComponent=!0}}]);