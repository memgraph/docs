"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[62037],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>N});var a=n(67294);function d(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){d(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,d=function(e,t){if(null==e)return{};var n,a,d={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(d[n]=e[n]);return d}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(d[n]=e[n])}return d}var l=a.createContext({}),s=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=s(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,d=e.mdxType,i=e.originalType,l=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),c=s(n),N=d,m=c["".concat(l,".").concat(N)]||c[N]||p[N]||i;return n?a.createElement(m,o(o({ref:t},u),{},{components:n})):a.createElement(m,o({ref:t},u))}));function N(e,t){var n=arguments,d=t&&t.mdxType;if("string"==typeof e||d){var i=n.length,o=new Array(i);o[0]=c;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:d,o[1]=r;for(var s=2;s<i;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},17795:(e,t,n)=>{n.r(t),n.d(t,{Highlight:()=>N,assets:()=>p,contentTitle:()=>s,default:()=>E,frontMatter:()=>l,metadata:()=>u,toc:()=>c});var a=n(87462),d=(n(67294),n(3905)),i=n(74866),o=n(85162),r=n(83523);const l={id:"node-similarity",title:"node_similarity",sidebar_label:"node_similarity"},s=void 0,u={unversionedId:"query-modules/python/node-similarity",id:"query-modules/python/node-similarity",title:"node_similarity",description:"If we're interested in how similar two nodes in a graph are, we'll want to get a numerical value that represents the node similarity between those two nodes. There are many node similarity measures and currently this module contains the following:",source:"@site/mage/query-modules/python/node-similarity.md",sourceDirName:"query-modules/python",slug:"/query-modules/python/node-similarity",permalink:"/docs/mage/query-modules/python/node-similarity",draft:!1,editUrl:"https://github.com/memgraph/docs/tree/master/mage/query-modules/python/node-similarity.md",tags:[],version:"current",frontMatter:{id:"node-similarity",title:"node_similarity",sidebar_label:"node_similarity"},sidebar:"mage",previous:{title:"node2vec_online",permalink:"/docs/mage/query-modules/python/node2vec-online"},next:{title:"nxalg",permalink:"/docs/mage/query-modules/python/nxalg"}},p={},c=[{value:"Procedures",id:"procedures",level:2},{value:"<code>cosine(node1, node2, mode)</code>",id:"cosinenode1-node2-mode",level:3},{value:"Input:",id:"input",level:4},{value:"Output:",id:"output",level:4},{value:"Usage:",id:"usage",level:4},{value:"<code>jaccard(node1, node2, mode)</code>",id:"jaccardnode1-node2-mode",level:3},{value:"Input:",id:"input-1",level:4},{value:"Output:",id:"output-1",level:4},{value:"Usage:",id:"usage-1",level:4},{value:"<code>overlap(node1, node2, mode)</code>",id:"overlapnode1-node2-mode",level:3},{value:"Input:",id:"input-2",level:4},{value:"Output:",id:"output-2",level:4},{value:"Usage:",id:"usage-2",level:4},{value:"Example - cosine similarity",id:"example---cosine-similarity",level:2},{value:"Example - Jaccard similarity",id:"example---jaccard-similarity",level:2},{value:"Example - overlap similarity",id:"example---overlap-similarity",level:2}],N=e=>{let{children:t,color:n}=e;return(0,d.kt)("span",{style:{backgroundColor:n,borderRadius:"2px",color:"#fff",padding:"0.2rem"}},t)},m={toc:c,Highlight:N};function E(e){let{components:t,...l}=e;return(0,d.kt)("wrapper",(0,a.Z)({},m,l,{components:t,mdxType:"MDXLayout"}),(0,d.kt)("p",null,"If we're interested in how similar two nodes in a graph are, we'll want to get a numerical value that represents the ",(0,d.kt)("em",null,"node similarity")," between those two nodes. There are many node similarity measures and currently this module contains the following: "),(0,d.kt)("ul",null,(0,d.kt)("li",{parentName:"ul"},"cosine similarity"),(0,d.kt)("li",{parentName:"ul"},"Jaccard similarity "),(0,d.kt)("li",{parentName:"ul"},"overlap similarity")),(0,d.kt)("p",null,(0,d.kt)("strong",{parentName:"p"},"The cosine similarity")," is computed using the following formula:"),(0,d.kt)("a",{href:"https://www.codecogs.com/eqnedit.php?latex=Cosine(A,B)&space;=&space;\\frac{|A&space;\\cap&space;B|}&space;{\\sqrt{|A|&space;\\cdot&space;|B|}}",target:"_blank"},(0,d.kt)("img",{src:"https://latex.codecogs.com/gif.latex?Cosine(A,B)&space;=&space;\\frac{|A&space;\\cap&space;B|}&space;{\\sqrt{|A|&space;\\cdot&space;|B|}}",title:"Cosine(A,B) = \\frac{|A \\cap B|} {\\sqrt{|A| \\cdot |B|}}"})),(0,d.kt)("p",null,(0,d.kt)("strong",{parentName:"p"},"The Jaccard similarity")," is computed using the following formula:"),(0,d.kt)("a",{href:"https://www.codecogs.com/eqnedit.php?latex=Jaccard(A,B)&space;=&space;\\frac{|A&space;\\cap&space;B|}&space;{|A|&space;&plus;&space;|B|&space;-&space;|A&space;\\cap&space;B|}",target:"_blank"},(0,d.kt)("img",{src:"https://latex.codecogs.com/gif.latex?Jaccard(A,B)&space;=&space;\\frac{|A&space;\\cap&space;B|}&space;{|A|&space;&plus;&space;|B|&space;-&space;|A&space;\\cap&space;B|}",title:"Jaccard(A,B) = \\frac{|A \\cap B|} {|A| + |B| - |A \\cap B|}"})),(0,d.kt)("p",null,(0,d.kt)("strong",{parentName:"p"},"The overalap similarity")," is computed using the following formula:"),(0,d.kt)("a",{href:"https://www.codecogs.com/eqnedit.php?latex=Overlap(A,B)&space;=&space;\\frac{|A&space;\\cap&space;B|}&space;{min(|A|,&space;|B|)}",target:"_blank"},(0,d.kt)("img",{src:"https://latex.codecogs.com/gif.latex?Overlap(A,B)&space;=&space;\\frac{|A&space;\\cap&space;B|}&space;{min(|A|,&space;|B|)}",title:"Overlap(A,B) = \\frac{|A \\cap B|} {min(|A|, |B|)}"})),(0,d.kt)("p",null,"Set A represents all neighbors of one node, set B represents all neighbors of the other node. In all the given formulas, the numerator is the cardinality of the intersection of set A and set B (in other words, the cardinality of the common neighbors set). The denominator differs but requires the cardinality of sets A and B in some way."),(0,d.kt)("p",null,"The algorithm is implemented so that it ignores whether the graph is directed or undirected and treats the edges as if they were undirected. It also ignores multiple edges between two nodes and treats them as if there were only one edge."),(0,d.kt)("p",null,(0,d.kt)("a",{parentName:"p",href:"https://github.com/memgraph/mage/blob/main/python/node_similarity.py"},(0,d.kt)("img",{parentName:"a",src:"https://img.shields.io/badge/source-node_similarity-FB6E00?logo=github&style=for-the-badge",alt:"docs-source"}))),(0,d.kt)("table",null,(0,d.kt)("thead",{parentName:"table"},(0,d.kt)("tr",{parentName:"thead"},(0,d.kt)("th",{parentName:"tr",align:null},"Trait"),(0,d.kt)("th",{parentName:"tr",align:null},"Value"))),(0,d.kt)("tbody",{parentName:"table"},(0,d.kt)("tr",{parentName:"tbody"},(0,d.kt)("td",{parentName:"tr",align:null},(0,d.kt)("strong",{parentName:"td"},"Module type")),(0,d.kt)("td",{parentName:"tr",align:null},(0,d.kt)(N,{color:"#FB6E00",mdxType:"Highlight"},(0,d.kt)("strong",{parentName:"td"},"algorithm")))),(0,d.kt)("tr",{parentName:"tbody"},(0,d.kt)("td",{parentName:"tr",align:null},(0,d.kt)("strong",{parentName:"td"},"Implementation")),(0,d.kt)("td",{parentName:"tr",align:null},(0,d.kt)(N,{color:"#FB6E00",mdxType:"Highlight"},(0,d.kt)("strong",{parentName:"td"},"Python")))),(0,d.kt)("tr",{parentName:"tbody"},(0,d.kt)("td",{parentName:"tr",align:null},(0,d.kt)("strong",{parentName:"td"},"Graph direction")),(0,d.kt)("td",{parentName:"tr",align:null},(0,d.kt)(N,{color:"#FB6E00",mdxType:"Highlight"},(0,d.kt)("strong",{parentName:"td"},"undirected")))),(0,d.kt)("tr",{parentName:"tbody"},(0,d.kt)("td",{parentName:"tr",align:null},(0,d.kt)("strong",{parentName:"td"},"Edge weights")),(0,d.kt)("td",{parentName:"tr",align:null},(0,d.kt)(N,{color:"#FB6E00",mdxType:"Highlight"},(0,d.kt)("strong",{parentName:"td"},"unweighted")))),(0,d.kt)("tr",{parentName:"tbody"},(0,d.kt)("td",{parentName:"tr",align:null},(0,d.kt)("strong",{parentName:"td"},"Parallelism")),(0,d.kt)("td",{parentName:"tr",align:null},(0,d.kt)(N,{color:"#FB6E00",mdxType:"Highlight"},(0,d.kt)("strong",{parentName:"td"},"sequential")))))),(0,d.kt)("h2",{id:"procedures"},"Procedures"),(0,d.kt)(r.ZP,{mdxType:"RunOnSubgraph"}),(0,d.kt)("h3",{id:"cosinenode1-node2-mode"},(0,d.kt)("inlineCode",{parentName:"h3"},"cosine(node1, node2, mode)")),(0,d.kt)("h4",{id:"input"},"Input:"),(0,d.kt)("ul",null,(0,d.kt)("li",{parentName:"ul"},(0,d.kt)("inlineCode",{parentName:"li"},"node1: Union[Vertex, Tuple[Vertex]")," \u27a1 The first node or a tuple of nodes."),(0,d.kt)("li",{parentName:"ul"},(0,d.kt)("inlineCode",{parentName:"li"},"node2: Union[Vertex, Tuple[Vertex]]")," \u27a1 The second node or a tuple of nodes."),(0,d.kt)("li",{parentName:"ul"},(0,d.kt)("inlineCode",{parentName:"li"},'mode: string (default="cartesian")'),' \u27a1 If the given arguments are tuples, this argument determines whether to calculate the similarity between nodes pairwise ("pairwise") or calculate the similarity between one and each node ("cartesian"). The default value is "cartesian".')),(0,d.kt)("h4",{id:"output"},"Output:"),(0,d.kt)("ul",null,(0,d.kt)("li",{parentName:"ul"},(0,d.kt)("inlineCode",{parentName:"li"},"node1: Vertex")," \u27a1 The first node."),(0,d.kt)("li",{parentName:"ul"},(0,d.kt)("inlineCode",{parentName:"li"},"node2: Vertex")," \u27a1 The second node."),(0,d.kt)("li",{parentName:"ul"},(0,d.kt)("inlineCode",{parentName:"li"},"similarity: float")," \u27a1  The cosine similarity between the first and the second node.")),(0,d.kt)("h4",{id:"usage"},"Usage:"),(0,d.kt)("pre",null,(0,d.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (m)\nWITH COLLECT(m) AS nodes1\nMATCH (n)\nWITH COLLECT(n) AS nodes2, nodes1\nCALL node_similarity.cosine(nodes1, nodes2) YIELD node1, node2, similarity\nRETURN node1, node2, similarity\n")),(0,d.kt)("h3",{id:"jaccardnode1-node2-mode"},(0,d.kt)("inlineCode",{parentName:"h3"},"jaccard(node1, node2, mode)")),(0,d.kt)("h4",{id:"input-1"},"Input:"),(0,d.kt)("ul",null,(0,d.kt)("li",{parentName:"ul"},(0,d.kt)("inlineCode",{parentName:"li"},"node1: Union[Vertex, Tuple[Vertex]")," \u27a1 The first node or a tuple of nodes."),(0,d.kt)("li",{parentName:"ul"},(0,d.kt)("inlineCode",{parentName:"li"},"node2: Union[Vertex, Tuple[Vertex]]")," \u27a1 The second node or a tuple of nodes."),(0,d.kt)("li",{parentName:"ul"},(0,d.kt)("inlineCode",{parentName:"li"},'mode: string (default="cartesian")'),' \u27a1 If the given arguments are tuples, this argument determines whether to calculate the similarity between nodes pairwise ("pairwise") or calculate the similarity between one and each node ("cartesian"). The default value is "cartesian".')),(0,d.kt)("h4",{id:"output-1"},"Output:"),(0,d.kt)("ul",null,(0,d.kt)("li",{parentName:"ul"},(0,d.kt)("inlineCode",{parentName:"li"},"node1: Vertex")," \u27a1 The first node."),(0,d.kt)("li",{parentName:"ul"},(0,d.kt)("inlineCode",{parentName:"li"},"node2: Vertex")," \u27a1 The second node."),(0,d.kt)("li",{parentName:"ul"},(0,d.kt)("inlineCode",{parentName:"li"},"similarity: float")," \u27a1  The Jaccard similarity between the first and the second node.")),(0,d.kt)("h4",{id:"usage-1"},"Usage:"),(0,d.kt)("pre",null,(0,d.kt)("code",{parentName:"pre",className:"language-cypher"},'MATCH (m)\nWITH COLLECT(m) AS nodes1\nMATCH (n)\nWITH COLLECT(n) AS nodes2, nodes1\nCALL node_similarity.jaccard(nodes1, nodes2, "cartesian") YIELD node1, node2, similarity\nRETURN node1, node2, similarity\n')),(0,d.kt)("h3",{id:"overlapnode1-node2-mode"},(0,d.kt)("inlineCode",{parentName:"h3"},"overlap(node1, node2, mode)")),(0,d.kt)("h4",{id:"input-2"},"Input:"),(0,d.kt)("ul",null,(0,d.kt)("li",{parentName:"ul"},(0,d.kt)("inlineCode",{parentName:"li"},"node1: Union[Vertex, Tuple[Vertex]")," \u27a1 The first node or a tuple of nodes."),(0,d.kt)("li",{parentName:"ul"},(0,d.kt)("inlineCode",{parentName:"li"},"node2: Union[Vertex, Tuple[Vertex]]")," \u27a1 The second node or a tuple of nodes."),(0,d.kt)("li",{parentName:"ul"},(0,d.kt)("inlineCode",{parentName:"li"},'mode: string (default="cartesian")'),' \u27a1 If the given arguments are tuples, this argument determines whether to calculate the similarity between nodes pairwise ("pairwise") or calculate the similarity between one and each node ("cartesian"). The default value is "cartesian".')),(0,d.kt)("h4",{id:"output-2"},"Output:"),(0,d.kt)("ul",null,(0,d.kt)("li",{parentName:"ul"},(0,d.kt)("inlineCode",{parentName:"li"},"node1: Vertex")," \u27a1 The first node."),(0,d.kt)("li",{parentName:"ul"},(0,d.kt)("inlineCode",{parentName:"li"},"node2: Vertex")," \u27a1 The second node."),(0,d.kt)("li",{parentName:"ul"},(0,d.kt)("inlineCode",{parentName:"li"},"similarity: float")," \u27a1  The overlap similarity between the first and the second node.")),(0,d.kt)("h4",{id:"usage-2"},"Usage:"),(0,d.kt)("pre",null,(0,d.kt)("code",{parentName:"pre",className:"language-cypher"},'MATCH (m)\nWITH COLLECT(m) AS nodes1\nMATCH (n)\nWITH COLLECT(n) AS nodes2, nodes1\nCALL node_similarity.overlap(nodes1, nodes2, "pairwise") YIELD node1, node2, similarity\nRETURN node1, node2, similarity\n')),(0,d.kt)("h2",{id:"example---cosine-similarity"},"Example - cosine similarity"),(0,d.kt)(i.Z,{groupId:"example1",defaultValue:"visualization",values:[{label:"Step 1: Input graph",value:"visualization"},{label:"Step 2: Cypher load commands",value:"cypher"},{label:"Step 3: Running command",value:"run"},{label:"Step 4: Results",value:"result"}],mdxType:"Tabs"},(0,d.kt)(o.Z,{value:"visualization",mdxType:"TabItem"},(0,d.kt)("img",{src:n(82389).Z})),(0,d.kt)(o.Z,{value:"cypher",mdxType:"TabItem"},(0,d.kt)("pre",null,(0,d.kt)("code",{parentName:"pre",className:"language-cypher"},"MERGE (a:Node {id: 0}) MERGE (b:Node {id: 2}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 0}) MERGE (b:Node {id: 3}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 0}) MERGE (b:Node {id: 4}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 0}) MERGE (b:Node {id: 5}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 1}) MERGE (b:Node {id: 0}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 1}) MERGE (b:Node {id: 1}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 1}) MERGE (b:Node {id: 2}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 2}) MERGE (b:Node {id: 1}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 2}) MERGE (b:Node {id: 4}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 2}) MERGE (b:Node {id: 5}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 4}) MERGE (b:Node {id: 0}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 4}) MERGE (b:Node {id: 1}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 5}) MERGE (b:Node {id: 2}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 5}) MERGE (b:Node {id: 3}) CREATE (a)-[:RELATION]->(b);\n"))),(0,d.kt)(o.Z,{value:"run",mdxType:"TabItem"},(0,d.kt)("pre",null,(0,d.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (m)\nWITH COLLECT(m) AS nodes1\nMATCH (n)\nWITH COLLECT(n) AS nodes2, nodes1\nCALL node_similarity.cosine(nodes1, nodes2) YIELD node1, node2, similarity AS cosine_similarity\nRETURN node1, node2, cosine_similarity;\n"))),(0,d.kt)(o.Z,{value:"result",mdxType:"TabItem"},(0,d.kt)("pre",null,(0,d.kt)("code",{parentName:"pre",className:"language-plaintext"},"+-------------------+-------------------+-------------------+\n| node1             | node2             | cosine_similarity |\n+-------------------+-------------------+-------------------+\n| (:Node {id: 0})   | (:Node {id: 0})   | 1                 |\n| (:Node {id: 0})   | (:Node {id: 2})   | 0.67082           |\n| (:Node {id: 0})   | (:Node {id: 3})   | 0.316228          |\n| (:Node {id: 0})   | (:Node {id: 4})   | 0.516398          |\n| (:Node {id: 0})   | (:Node {id: 5})   | 0.516398          |\n| (:Node {id: 0})   | (:Node {id: 1})   | 0.67082           |\n| (:Node {id: 2})   | (:Node {id: 0})   | 0.67082           |\n| (:Node {id: 2})   | (:Node {id: 2})   | 1                 |\n| (:Node {id: 2})   | (:Node {id: 3})   | 0.707107          |\n| (:Node {id: 2})   | (:Node {id: 4})   | 0.57735           |\n| (:Node {id: 2})   | (:Node {id: 5})   | 0.288675          |\n| (:Node {id: 2})   | (:Node {id: 1})   | 0.75              |\n| (:Node {id: 3})   | (:Node {id: 0})   | 0.316228          |\n| (:Node {id: 3})   | (:Node {id: 2})   | 0.707107          |\n| (:Node {id: 3})   | (:Node {id: 3})   | 1                 |\n| (:Node {id: 3})   | (:Node {id: 4})   | 0.408248          |\n| (:Node {id: 3})   | (:Node {id: 5})   | 0.408248          |\n| (:Node {id: 3})   | (:Node {id: 1})   | 0.353553          |\n| (:Node {id: 4})   | (:Node {id: 0})   | 0.516398          |\n| (:Node {id: 4})   | (:Node {id: 2})   | 0.57735           |\n| (:Node {id: 4})   | (:Node {id: 3})   | 0.408248          |\n| (:Node {id: 4})   | (:Node {id: 4})   | 1                 |\n| (:Node {id: 4})   | (:Node {id: 5})   | 0.666667          |\n| (:Node {id: 4})   | (:Node {id: 1})   | 0.866025          |\n| (:Node {id: 5})   | (:Node {id: 0})   | 0.516398          |\n| (:Node {id: 5})   | (:Node {id: 2})   | 0.288675          |\n| (:Node {id: 5})   | (:Node {id: 3})   | 0.408248          |\n| (:Node {id: 5})   | (:Node {id: 4})   | 0.666667          |\n| (:Node {id: 5})   | (:Node {id: 5})   | 1                 |\n| (:Node {id: 5})   | (:Node {id: 1})   | 0.57735           |\n| (:Node {id: 1})   | (:Node {id: 0})   | 0.67082           |\n| (:Node {id: 1})   | (:Node {id: 2})   | 0.75              |\n| (:Node {id: 1})   | (:Node {id: 3})   | 0.353553          |\n| (:Node {id: 1})   | (:Node {id: 4})   | 0.866025          |\n| (:Node {id: 1})   | (:Node {id: 5})   | 0.57735           |\n| (:Node {id: 1})   | (:Node {id: 1})   | 1                 |\n+-------------------+-------------------+-------------------+\n\n")))),(0,d.kt)("h2",{id:"example---jaccard-similarity"},"Example - Jaccard similarity"),(0,d.kt)(i.Z,{groupId:"example2",defaultValue:"visualization",values:[{label:"Step 1: Input graph",value:"visualization"},{label:"Step 2: Cypher load commands",value:"cypher"},{label:"Step 3: Running command",value:"run"},{label:"Step 4: Results",value:"result"}],mdxType:"Tabs"},(0,d.kt)(o.Z,{value:"visualization",mdxType:"TabItem"},(0,d.kt)("img",{src:n(82389).Z})),(0,d.kt)(o.Z,{value:"cypher",mdxType:"TabItem"},(0,d.kt)("pre",null,(0,d.kt)("code",{parentName:"pre",className:"language-cypher"},"MERGE (a:Node {id: 0}) MERGE (b:Node {id: 2}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 0}) MERGE (b:Node {id: 3}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 0}) MERGE (b:Node {id: 4}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 0}) MERGE (b:Node {id: 5}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 1}) MERGE (b:Node {id: 0}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 1}) MERGE (b:Node {id: 1}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 1}) MERGE (b:Node {id: 2}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 2}) MERGE (b:Node {id: 1}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 2}) MERGE (b:Node {id: 4}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 2}) MERGE (b:Node {id: 5}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 4}) MERGE (b:Node {id: 0}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 4}) MERGE (b:Node {id: 1}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 5}) MERGE (b:Node {id: 2}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 5}) MERGE (b:Node {id: 3}) CREATE (a)-[:RELATION]->(b);\n"))),(0,d.kt)(o.Z,{value:"run",mdxType:"TabItem"},(0,d.kt)("pre",null,(0,d.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (m)\nWITH COLLECT(m) AS nodes1\nMATCH (n)\nWITH COLLECT(n) AS nodes2, nodes1\nCALL node_similarity.jaccard(nodes1, nodes2) YIELD node1, node2, similarity AS jaccard_similarity\nRETURN node1, node2, jaccard_similarity;\n"))),(0,d.kt)(o.Z,{value:"result",mdxType:"TabItem"},(0,d.kt)("pre",null,(0,d.kt)("code",{parentName:"pre",className:"language-plaintext"},"+--------------------+--------------------+--------------------+\n| node1              | node2              | jaccard_similarity |\n+--------------------+--------------------+--------------------+\n| (:Node {id: 0})    | (:Node {id: 0})    | 1                  |\n| (:Node {id: 0})    | (:Node {id: 2})    | 0.5                |\n| (:Node {id: 0})    | (:Node {id: 3})    | 0.166667           |\n| (:Node {id: 0})    | (:Node {id: 4})    | 0.333333           |\n| (:Node {id: 0})    | (:Node {id: 5})    | 0.333333           |\n| (:Node {id: 0})    | (:Node {id: 1})    | 0.5                |\n| (:Node {id: 2})    | (:Node {id: 0})    | 0.5                |\n| (:Node {id: 2})    | (:Node {id: 2})    | 1                  |\n| (:Node {id: 2})    | (:Node {id: 3})    | 0.5                |\n| (:Node {id: 2})    | (:Node {id: 4})    | 0.4                |\n| (:Node {id: 2})    | (:Node {id: 5})    | 0.166667           |\n| (:Node {id: 2})    | (:Node {id: 1})    | 0.6                |\n| (:Node {id: 3})    | (:Node {id: 0})    | 0.166667           |\n| (:Node {id: 3})    | (:Node {id: 2})    | 0.5                |\n| (:Node {id: 3})    | (:Node {id: 3})    | 1                  |\n| (:Node {id: 3})    | (:Node {id: 4})    | 0.25               |\n| (:Node {id: 3})    | (:Node {id: 5})    | 0.25               |\n| (:Node {id: 3})    | (:Node {id: 1})    | 0.2                |\n| (:Node {id: 4})    | (:Node {id: 0})    | 0.333333           |\n| (:Node {id: 4})    | (:Node {id: 2})    | 0.4                |\n| (:Node {id: 4})    | (:Node {id: 3})    | 0.25               |\n| (:Node {id: 4})    | (:Node {id: 4})    | 1                  |\n| (:Node {id: 4})    | (:Node {id: 5})    | 0.5                |\n| (:Node {id: 4})    | (:Node {id: 1})    | 0.75               |\n| (:Node {id: 5})    | (:Node {id: 0})    | 0.333333           |\n| (:Node {id: 5})    | (:Node {id: 2})    | 0.166667           |\n| (:Node {id: 5})    | (:Node {id: 3})    | 0.25               |\n| (:Node {id: 5})    | (:Node {id: 4})    | 0.5                |\n| (:Node {id: 5})    | (:Node {id: 5})    | 1                  |\n| (:Node {id: 5})    | (:Node {id: 1})    | 0.4                |\n| (:Node {id: 1})    | (:Node {id: 0})    | 0.5                |\n| (:Node {id: 1})    | (:Node {id: 2})    | 0.6                |\n| (:Node {id: 1})    | (:Node {id: 3})    | 0.2                |\n| (:Node {id: 1})    | (:Node {id: 4})    | 0.75               |\n| (:Node {id: 1})    | (:Node {id: 5})    | 0.4                |\n| (:Node {id: 1})    | (:Node {id: 1})    | 1                  |\n+--------------------+--------------------+--------------------+\n\n")))),(0,d.kt)("h2",{id:"example---overlap-similarity"},"Example - overlap similarity"),(0,d.kt)(i.Z,{groupId:"example3",defaultValue:"visualization",values:[{label:"Step 1: Input graph",value:"visualization"},{label:"Step 2: Cypher load commands",value:"cypher"},{label:"Step 3: Running command",value:"run"},{label:"Step 4: Results",value:"result"}],mdxType:"Tabs"},(0,d.kt)(o.Z,{value:"visualization",mdxType:"TabItem"},(0,d.kt)("img",{src:n(82389).Z})),(0,d.kt)(o.Z,{value:"cypher",mdxType:"TabItem"},(0,d.kt)("pre",null,(0,d.kt)("code",{parentName:"pre",className:"language-cypher"},"MERGE (a:Node {id: 0}) MERGE (b:Node {id: 2}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 0}) MERGE (b:Node {id: 3}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 0}) MERGE (b:Node {id: 4}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 0}) MERGE (b:Node {id: 5}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 1}) MERGE (b:Node {id: 0}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 1}) MERGE (b:Node {id: 1}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 1}) MERGE (b:Node {id: 2}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 2}) MERGE (b:Node {id: 1}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 2}) MERGE (b:Node {id: 4}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 2}) MERGE (b:Node {id: 5}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 4}) MERGE (b:Node {id: 0}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 4}) MERGE (b:Node {id: 1}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 5}) MERGE (b:Node {id: 2}) CREATE (a)-[:RELATION]->(b);\nMERGE (a:Node {id: 5}) MERGE (b:Node {id: 3}) CREATE (a)-[:RELATION]->(b);\n"))),(0,d.kt)(o.Z,{value:"run",mdxType:"TabItem"},(0,d.kt)("pre",null,(0,d.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (m)\nWITH COLLECT(m) AS nodes1\nMATCH (n)\nWITH COLLECT(n) AS nodes2, nodes1\nCALL node_similarity.overlap(nodes1, nodes2) YIELD node1, node2, similarity AS overlap_similarity\nRETURN node1, node2, overlap_similarity;\n"))),(0,d.kt)(o.Z,{value:"result",mdxType:"TabItem"},(0,d.kt)("pre",null,(0,d.kt)("code",{parentName:"pre",className:"language-plaintext"},"+--------------------+--------------------+--------------------+\n| node1              | node2              | overlap_similarity |\n+--------------------+--------------------+--------------------+\n| (:Node {id: 0})    | (:Node {id: 0})    | 1                  |\n| (:Node {id: 0})    | (:Node {id: 2})    | 0.75               |\n| (:Node {id: 0})    | (:Node {id: 3})    | 0.5                |\n| (:Node {id: 0})    | (:Node {id: 4})    | 0.666667           |\n| (:Node {id: 0})    | (:Node {id: 5})    | 0.666667           |\n| (:Node {id: 0})    | (:Node {id: 1})    | 0.75               |\n| (:Node {id: 2})    | (:Node {id: 0})    | 0.75               |\n| (:Node {id: 2})    | (:Node {id: 2})    | 1                  |\n| (:Node {id: 2})    | (:Node {id: 3})    | 1                  |\n| (:Node {id: 2})    | (:Node {id: 4})    | 0.666667           |\n| (:Node {id: 2})    | (:Node {id: 5})    | 0.333333           |\n| (:Node {id: 2})    | (:Node {id: 1})    | 0.75               |\n| (:Node {id: 3})    | (:Node {id: 0})    | 0.5                |\n| (:Node {id: 3})    | (:Node {id: 2})    | 1                  |\n| (:Node {id: 3})    | (:Node {id: 3})    | 1                  |\n| (:Node {id: 3})    | (:Node {id: 4})    | 0.5                |\n| (:Node {id: 3})    | (:Node {id: 5})    | 0.5                |\n| (:Node {id: 3})    | (:Node {id: 1})    | 0.5                |\n| (:Node {id: 4})    | (:Node {id: 0})    | 0.666667           |\n| (:Node {id: 4})    | (:Node {id: 2})    | 0.666667           |\n| (:Node {id: 4})    | (:Node {id: 3})    | 0.5                |\n| (:Node {id: 4})    | (:Node {id: 4})    | 1                  |\n| (:Node {id: 4})    | (:Node {id: 5})    | 0.666667           |\n| (:Node {id: 4})    | (:Node {id: 1})    | 1                  |\n| (:Node {id: 5})    | (:Node {id: 0})    | 0.666667           |\n| (:Node {id: 5})    | (:Node {id: 2})    | 0.333333           |\n| (:Node {id: 5})    | (:Node {id: 3})    | 0.5                |\n| (:Node {id: 5})    | (:Node {id: 4})    | 0.666667           |\n| (:Node {id: 5})    | (:Node {id: 5})    | 1                  |\n| (:Node {id: 5})    | (:Node {id: 1})    | 0.666667           |\n| (:Node {id: 1})    | (:Node {id: 0})    | 0.75               |\n| (:Node {id: 1})    | (:Node {id: 2})    | 0.75               |\n| (:Node {id: 1})    | (:Node {id: 3})    | 0.5                |\n| (:Node {id: 1})    | (:Node {id: 4})    | 1                  |\n| (:Node {id: 1})    | (:Node {id: 5})    | 0.666667           |\n| (:Node {id: 1})    | (:Node {id: 1})    | 1                  |\n+--------------------+--------------------+--------------------+\n\n")))))}E.isMDXComponent=!0},83523:(e,t,n)=>{n.d(t,{ZP:()=>o});var a=n(87462),d=(n(67294),n(3905));const i={toc:[]};function o(e){let{components:t,...n}=e;return(0,d.kt)("wrapper",(0,a.Z)({},i,n,{components:t,mdxType:"MDXLayout"}),(0,d.kt)("admonition",{type:"info"},(0,d.kt)("p",{parentName:"admonition"},"If you want to execute this algorithm on graph projections, subgraphs or portions\nof the graph, be sure to check out the guide on\n",(0,d.kt)("a",{parentName:"p",href:"/mage/how-to-guides/run-a-subgraph-module"},"How to run a MAGE module on subgraphs"),".")))}o.isMDXComponent=!0},85162:(e,t,n)=>{n.d(t,{Z:()=>o});var a=n(67294),d=n(86010);const i="tabItem_Ymn6";function o(e){let{children:t,hidden:n,className:o}=e;return a.createElement("div",{role:"tabpanel",className:(0,d.Z)(i,o),hidden:n},t)}},74866:(e,t,n)=>{n.d(t,{Z:()=>R});var a=n(87462),d=n(67294),i=n(86010),o=n(12466),r=n(16550),l=n(91980),s=n(67392),u=n(50012);function p(e){return function(e){return d.Children.map(e,(e=>{if((0,d.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:d}}=e;return{value:t,label:n,attributes:a,default:d}}))}function c(e){const{values:t,children:n}=e;return(0,d.useMemo)((()=>{const e=t??p(n);return function(e){const t=(0,s.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function N(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function m(e){let{queryString:t=!1,groupId:n}=e;const a=(0,r.k6)(),i=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,l._X)(i),(0,d.useCallback)((e=>{if(!i)return;const t=new URLSearchParams(a.location.search);t.set(i,e),a.replace({...a.location,search:t.toString()})}),[i,a])]}function E(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,i=c(e),[o,r]=(0,d.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!N({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:i}))),[l,s]=m({queryString:n,groupId:a}),[p,E]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,i]=(0,u.Nk)(n);return[a,(0,d.useCallback)((e=>{n&&i.set(e)}),[n,i])]}({groupId:a}),h=(()=>{const e=l??p;return N({value:e,tabValues:i})?e:null})();(0,d.useEffect)((()=>{h&&r(h)}),[h]);return{selectedValue:o,selectValue:(0,d.useCallback)((e=>{if(!N({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);r(e),s(e),E(e)}),[s,E,i]),tabValues:i}}var h=n(72389);const b="tabList__CuJ",g="tabItem_LNqP";function T(e){let{className:t,block:n,selectedValue:r,selectValue:l,tabValues:s}=e;const u=[],{blockElementScrollPositionUntilNextRender:p}=(0,o.o5)(),c=e=>{const t=e.currentTarget,n=u.indexOf(t),a=s[n].value;a!==r&&(p(t),l(a))},N=e=>{var t;let n=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const t=u.indexOf(e.currentTarget)+1;n=u[t]??u[0];break}case"ArrowLeft":{const t=u.indexOf(e.currentTarget)-1;n=u[t]??u[u.length-1];break}}null==(t=n)||t.focus()};return d.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":n},t)},s.map((e=>{let{value:t,label:n,attributes:o}=e;return d.createElement("li",(0,a.Z)({role:"tab",tabIndex:r===t?0:-1,"aria-selected":r===t,key:t,ref:e=>u.push(e),onKeyDown:N,onClick:c},o,{className:(0,i.Z)("tabs__item",g,null==o?void 0:o.className,{"tabs__item--active":r===t})}),n??t)})))}function y(e){let{lazy:t,children:n,selectedValue:a}=e;if(t){const e=n.find((e=>e.props.value===a));return e?(0,d.cloneElement)(e,{className:"margin-top--md"}):null}return d.createElement("div",{className:"margin-top--md"},n.map(((e,t)=>(0,d.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function k(e){const t=E(e);return d.createElement("div",{className:(0,i.Z)("tabs-container",b)},d.createElement(T,(0,a.Z)({},e,t)),d.createElement(y,(0,a.Z)({},e,t)))}function R(e){const t=(0,h.Z)();return d.createElement(k,(0,a.Z)({key:String(t)},e))}},82389:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/node-similarity-1-5fd5e2699b4725c45d85f6d49b3d8114.png"}}]);