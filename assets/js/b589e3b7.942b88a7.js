(window.webpackJsonp=window.webpackJsonp||[]).push([[197],{274:function(t,e,n){"use strict";n.r(e),n.d(e,"frontMatter",(function(){return b})),n.d(e,"metadata",(function(){return i})),n.d(e,"toc",(function(){return o})),n.d(e,"default",(function(){return p}));var a=n(3),r=n(8),l=(n(0),n(356)),b={id:"graph-coloring",title:"The graph_coloring module",sidebar_label:"graph_coloring"},i={unversionedId:"query-modules/python/graph-coloring",id:"query-modules/python/graph-coloring",isDocsHomePage:!1,title:"The graph_coloring module",description:"colorgraph(context, parameters, edgeproperty)",source:"@site/mage/query-modules/python/graph-coloring.md",slug:"/query-modules/python/graph-coloring",permalink:"/mage/query-modules/python/graph-coloring",editUrl:"https://github.com/memgraph/docs/tree/master/mage/query-modules/python/graph-coloring.md",version:"current",sidebar_label:"graph_coloring",sidebar:"mage",previous:{title:"The graph_analyzer module",permalink:"/mage/query-modules/python/graph-analyzer"},next:{title:"The nxalg module",permalink:"/mage/query-modules/python/nxalg"}},o=[{value:"<code> color_graph(context, parameters, edge_property)</code>",id:"color_graphcontext-parameters-edge_property",children:[]},{value:"<code> color_subgraph(context, vertices, edges, parameters, edge_property)</code>",id:"color_subgraphcontext-vertices-edges-parameters-edge_property",children:[]}],c={toc:o};function p(t){var e=t.components,n=Object(r.a)(t,["components"]);return Object(l.b)("wrapper",Object(a.a)({},c,n,{components:e,mdxType:"MDXLayout"}),Object(l.b)("h2",{id:"color_graphcontext-parameters-edge_property"},Object(l.b)("inlineCode",{parentName:"h2"}," color_graph(context, parameters, edge_property)")),Object(l.b)("p",null,"A procedure that performs the graph coloring algorithm."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Parameters")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"context")," (",Object(l.b)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"parameters")," (",Object(l.b)("em",{parentName:"li"},"mgp.Map"),") \u2013 (default={})\nA dictionary that specifies the algorithm configuration. Configuration parameters are explained in the table below.")),Object(l.b)("table",null,Object(l.b)("thead",{parentName:"table"},Object(l.b)("tr",{parentName:"thead"},Object(l.b)("th",{parentName:"tr",align:null},"Name"),Object(l.b)("th",{parentName:"tr",align:null},"Type"),Object(l.b)("th",{parentName:"tr",align:null},"Default"),Object(l.b)("th",{parentName:"tr",align:null},"Description"))),Object(l.b)("tbody",{parentName:"table"},Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"algorithm"),Object(l.b)("td",{parentName:"tr",align:null},"String"),Object(l.b)("td",{parentName:"tr",align:null},"QA"),Object(l.b)("td",{parentName:"tr",align:null},"An optimization strategy used to find graph coloring.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"no_of_colors"),Object(l.b)("td",{parentName:"tr",align:null},"Integer"),Object(l.b)("td",{parentName:"tr",align:null},"10"),Object(l.b)("td",{parentName:"tr",align:null},"The number of colors used to color the nodes of the graph.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"no_of_processes"),Object(l.b)("td",{parentName:"tr",align:null},"Integer"),Object(l.b)("td",{parentName:"tr",align:null},"1"),Object(l.b)("td",{parentName:"tr",align:null},"The number of processes used to execute the algorithm in parallel.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"population_size"),Object(l.b)("td",{parentName:"tr",align:null},"Integer"),Object(l.b)("td",{parentName:"tr",align:null},"15"),Object(l.b)("td",{parentName:"tr",align:null},"The number of different solutions that are improved through iterations.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"population_factory"),Object(l.b)("td",{parentName:"tr",align:null},"String"),Object(l.b)("td",{parentName:"tr",align:null},"ChainChunkFactory"),Object(l.b)("td",{parentName:"tr",align:null},"The name of a function that generates an initial population.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"init_algorithms"),Object(l.b)("td",{parentName:"tr",align:null},"List","[String]"),Object(l.b)("td",{parentName:"tr",align:null},"[SDO, LDO]"),Object(l.b)("td",{parentName:"tr",align:null},"Contains algorithms used to initialize the solutions.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"error"),Object(l.b)("td",{parentName:"tr",align:null},"String"),Object(l.b)("td",{parentName:"tr",align:null},"ConflictError"),Object(l.b)("td",{parentName:"tr",align:null},"The name of an error function that is minimized by an optimization strategy.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"max_iterations"),Object(l.b)("td",{parentName:"tr",align:null},"Integer"),Object(l.b)("td",{parentName:"tr",align:null},"10"),Object(l.b)("td",{parentName:"tr",align:null},"The maximum number of iterations of an algorithm.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"iteration_callbacks"),Object(l.b)("td",{parentName:"tr",align:null},"List","[String]"),Object(l.b)("td",{parentName:"tr",align:null},"[]"),Object(l.b)("td",{parentName:"tr",align:null},"Contains iteration callbacks. Iteration callback is called after each iteration of the iterative algorithm. Iteration callback saves certain population information and calls specified actions if certain conditions are met.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"communication_delay"),Object(l.b)("td",{parentName:"tr",align:null},"Integer"),Object(l.b)("td",{parentName:"tr",align:null},"10"),Object(l.b)("td",{parentName:"tr",align:null},"The number of iterations that must pass for neighboring parts to exchange solutions.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"logging_delay"),Object(l.b)("td",{parentName:"tr",align:null},"Integer"),Object(l.b)("td",{parentName:"tr",align:null},"10"),Object(l.b)("td",{parentName:"tr",align:null},"The number of iteration after the algorithm information is logged.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"QA_temperature"),Object(l.b)("td",{parentName:"tr",align:null},"Float"),Object(l.b)("td",{parentName:"tr",align:null},"0.035"),Object(l.b)("td",{parentName:"tr",align:null},"The temperature parameter of the quantum annealing algorithm.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"QA_max_steps"),Object(l.b)("td",{parentName:"tr",align:null},"Float"),Object(l.b)("td",{parentName:"tr",align:null},"10"),Object(l.b)("td",{parentName:"tr",align:null},"The maximum number of steps in one iteration.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"conflict_err_alpha"),Object(l.b)("td",{parentName:"tr",align:null},"Float"),Object(l.b)("td",{parentName:"tr",align:null},"0.1"),Object(l.b)("td",{parentName:"tr",align:null},"The number that scales the sum of the conflicting edges in the error function formula.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"conflict_err_beta"),Object(l.b)("td",{parentName:"tr",align:null},"Float"),Object(l.b)("td",{parentName:"tr",align:null},"0.001"),Object(l.b)("td",{parentName:"tr",align:null},"The number that scales the correlation between solutions in the error function formula.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"mutation"),Object(l.b)("td",{parentName:"tr",align:null},"String"),Object(l.b)("td",{parentName:"tr",align:null},"SimpleMutation"),Object(l.b)("td",{parentName:"tr",align:null},"The name of a function that changes the solutions.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"multiple_mutation_no_of_nodes"),Object(l.b)("td",{parentName:"tr",align:null},"Integer"),Object(l.b)("td",{parentName:"tr",align:null},"2"),Object(l.b)("td",{parentName:"tr",align:null},"The number of nodes that will change color.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"random_mutation_probability"),Object(l.b)("td",{parentName:"tr",align:null},"Float"),Object(l.b)("td",{parentName:"tr",align:null},"0.1"),Object(l.b)("td",{parentName:"tr",align:null},"The probability that the color of the random node (it does not have to be conflicting) will be changed.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"simple_tunneling_mutation"),Object(l.b)("td",{parentName:"tr",align:null},"String"),Object(l.b)("td",{parentName:"tr",align:null},"MultipleMutation"),Object(l.b)("td",{parentName:"tr",align:null},"The name of a mutation function.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"simple_tunneling_probability"),Object(l.b)("td",{parentName:"tr",align:null},"Float"),Object(l.b)("td",{parentName:"tr",align:null},"0.5"),Object(l.b)("td",{parentName:"tr",align:null},"The probability of changing an individual.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"simple_tunneling_error_correction"),Object(l.b)("td",{parentName:"tr",align:null},"Float"),Object(l.b)("td",{parentName:"tr",align:null},"2"),Object(l.b)("td",{parentName:"tr",align:null},"The mutated individual is accepted only if its error is less than the error of the old individual multiplied by this parameter.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"simple_tunneling_max_attempts"),Object(l.b)("td",{parentName:"tr",align:null},"Integer"),Object(l.b)("td",{parentName:"tr",align:null},"25"),Object(l.b)("td",{parentName:"tr",align:null},"The maximum number of mutation attempts until the individual is accepted.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"convergence_callback_tolerance"),Object(l.b)("td",{parentName:"tr",align:null},"Integer"),Object(l.b)("td",{parentName:"tr",align:null},"500"),Object(l.b)("td",{parentName:"tr",align:null},"The maximum number of iterations in which if the algorithm does not find a better solution convergence occurs and defined actions are called.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"convergence_callback_actions"),Object(l.b)("td",{parentName:"tr",align:null},"String"),Object(l.b)("td",{parentName:"tr",align:null},"[SimpleTunneling]"),Object(l.b)("td",{parentName:"tr",align:null},"Actions that are called when convergence is detected.")))),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"edge_property")," (",Object(l.b)("em",{parentName:"li"},"str"),') \u2013 (default="weight")\nA string that determines the edge attribute that stores the edge weight.\nAny edge attribute not present defaults to 1.')),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,"The return value of the procedure is a map that contains the mapping of nodes to colors."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Return type")),Object(l.b)("p",null,"mgp.Record(node=str, color=str)"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Example")),Object(l.b)("p",null,"The procedure can be invoked in Cypher using the following query:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cypher"},"CALL graph_coloring.color_graph() YIELD *;\n")),Object(l.b)("h2",{id:"color_subgraphcontext-vertices-edges-parameters-edge_property"},Object(l.b)("inlineCode",{parentName:"h2"}," color_subgraph(context, vertices, edges, parameters, edge_property)")),Object(l.b)("p",null,"A procedure that performs graph coloring algorithm on the given subgraph."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Parameters")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"context")," (",Object(l.b)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"vertices")," (",Object(l.b)("em",{parentName:"li"},"mgp.List","[mgp.Vertex]"),") - List of vertices in the subgraph.")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"edges")," (",Object(l.b)("em",{parentName:"li"},"mgp.List","[mgp.Edge]"),") \u2013 List of edges in the subgraph.")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"parameters")," (",Object(l.b)("em",{parentName:"li"},"mgp.Map"),") \u2013 (default={})\nA dictionary that specifies the algorithm configuration. Configuration parameters are explained in the table below.")),Object(l.b)("table",null,Object(l.b)("thead",{parentName:"table"},Object(l.b)("tr",{parentName:"thead"},Object(l.b)("th",{parentName:"tr",align:null},"Name"),Object(l.b)("th",{parentName:"tr",align:null},"Type"),Object(l.b)("th",{parentName:"tr",align:null},"Default"),Object(l.b)("th",{parentName:"tr",align:null},"Description"))),Object(l.b)("tbody",{parentName:"table"},Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"algorithm"),Object(l.b)("td",{parentName:"tr",align:null},"String"),Object(l.b)("td",{parentName:"tr",align:null},"QA"),Object(l.b)("td",{parentName:"tr",align:null},"An optimization strategy used to find graph coloring.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"no_of_colors"),Object(l.b)("td",{parentName:"tr",align:null},"Integer"),Object(l.b)("td",{parentName:"tr",align:null},"10"),Object(l.b)("td",{parentName:"tr",align:null},"The number of colors used to color the nodes of the graph.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"no_of_processes"),Object(l.b)("td",{parentName:"tr",align:null},"Integer"),Object(l.b)("td",{parentName:"tr",align:null},"1"),Object(l.b)("td",{parentName:"tr",align:null},"The number of processes used to execute the algorithm in parallel.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"population_size"),Object(l.b)("td",{parentName:"tr",align:null},"Integer"),Object(l.b)("td",{parentName:"tr",align:null},"15"),Object(l.b)("td",{parentName:"tr",align:null},"The number of different solutions that are improved through iterations.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"population_factory"),Object(l.b)("td",{parentName:"tr",align:null},"String"),Object(l.b)("td",{parentName:"tr",align:null},"ChainChunkFactory"),Object(l.b)("td",{parentName:"tr",align:null},"The name of a function that generates an initial population.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"init_algorithms"),Object(l.b)("td",{parentName:"tr",align:null},"List","[String]"),Object(l.b)("td",{parentName:"tr",align:null},"[SDO, LDO]"),Object(l.b)("td",{parentName:"tr",align:null},"Contains algorithms used to initialize the solutions.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"error"),Object(l.b)("td",{parentName:"tr",align:null},"String"),Object(l.b)("td",{parentName:"tr",align:null},"ConflictError"),Object(l.b)("td",{parentName:"tr",align:null},"The name of an error function that is minimized by an optimization strategy.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"max_iterations"),Object(l.b)("td",{parentName:"tr",align:null},"Integer"),Object(l.b)("td",{parentName:"tr",align:null},"10"),Object(l.b)("td",{parentName:"tr",align:null},"The maximum number of iterations of an algorithm.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"iteration_callbacks"),Object(l.b)("td",{parentName:"tr",align:null},"List","[String]"),Object(l.b)("td",{parentName:"tr",align:null},"[]"),Object(l.b)("td",{parentName:"tr",align:null},"Contains iteration callbacks. Iteration callback is called after each iteration of the iterative algorithm. Iteration callback saves certain population information and calls specified actions if certain conditions are met.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"communication_delay"),Object(l.b)("td",{parentName:"tr",align:null},"Integer"),Object(l.b)("td",{parentName:"tr",align:null},"10"),Object(l.b)("td",{parentName:"tr",align:null},"The number of iterations that must pass for neighboring parts to exchange solutions.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"logging_delay"),Object(l.b)("td",{parentName:"tr",align:null},"Integer"),Object(l.b)("td",{parentName:"tr",align:null},"10"),Object(l.b)("td",{parentName:"tr",align:null},"The number of iteration after the algorithm information is logged.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"QA_temperature"),Object(l.b)("td",{parentName:"tr",align:null},"Float"),Object(l.b)("td",{parentName:"tr",align:null},"0.035"),Object(l.b)("td",{parentName:"tr",align:null},"The temperature parameter of the quantum annealing algorithm.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"QA_max_steps"),Object(l.b)("td",{parentName:"tr",align:null},"Float"),Object(l.b)("td",{parentName:"tr",align:null},"10"),Object(l.b)("td",{parentName:"tr",align:null},"The maximum number of steps in one iteration.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"conflict_err_alpha"),Object(l.b)("td",{parentName:"tr",align:null},"Float"),Object(l.b)("td",{parentName:"tr",align:null},"0.1"),Object(l.b)("td",{parentName:"tr",align:null},"The number that scales the sum of the conflicting edges in the error function formula.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"conflict_err_beta"),Object(l.b)("td",{parentName:"tr",align:null},"Float"),Object(l.b)("td",{parentName:"tr",align:null},"0.001"),Object(l.b)("td",{parentName:"tr",align:null},"The number that scales the correlation between solutions in the error function formula.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"mutation"),Object(l.b)("td",{parentName:"tr",align:null},"String"),Object(l.b)("td",{parentName:"tr",align:null},"SimpleMutation"),Object(l.b)("td",{parentName:"tr",align:null},"The name of a function that changes the solutions.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"multiple_mutation_no_of_nodes"),Object(l.b)("td",{parentName:"tr",align:null},"Integer"),Object(l.b)("td",{parentName:"tr",align:null},"2"),Object(l.b)("td",{parentName:"tr",align:null},"The number of nodes that will change color.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"random_mutation_probability"),Object(l.b)("td",{parentName:"tr",align:null},"Float"),Object(l.b)("td",{parentName:"tr",align:null},"0.1"),Object(l.b)("td",{parentName:"tr",align:null},"The probability that the color of the random node (it does not have to be conflicting) will be changed.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"simple_tunneling_mutation"),Object(l.b)("td",{parentName:"tr",align:null},"String"),Object(l.b)("td",{parentName:"tr",align:null},"MultipleMutation"),Object(l.b)("td",{parentName:"tr",align:null},"The name of a mutation function.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"simple_tunneling_probability"),Object(l.b)("td",{parentName:"tr",align:null},"Float"),Object(l.b)("td",{parentName:"tr",align:null},"0.5"),Object(l.b)("td",{parentName:"tr",align:null},"The probability of changing an individual.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"simple_tunneling_error_correction"),Object(l.b)("td",{parentName:"tr",align:null},"Float"),Object(l.b)("td",{parentName:"tr",align:null},"2"),Object(l.b)("td",{parentName:"tr",align:null},"The mutated individual is accepted only if its error is less than the error of the old individual multiplied by this parameter.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"simple_tunneling_max_attempts"),Object(l.b)("td",{parentName:"tr",align:null},"Integer"),Object(l.b)("td",{parentName:"tr",align:null},"25"),Object(l.b)("td",{parentName:"tr",align:null},"The maximum number of mutation attempts until the individual is accepted.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"convergence_callback_tolerance"),Object(l.b)("td",{parentName:"tr",align:null},"Integer"),Object(l.b)("td",{parentName:"tr",align:null},"500"),Object(l.b)("td",{parentName:"tr",align:null},"The maximum number of iterations in which if the algorithm does not find a better solution convergence occurs and defined actions are called.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"convergence_callback_actions"),Object(l.b)("td",{parentName:"tr",align:null},"String"),Object(l.b)("td",{parentName:"tr",align:null},"[SimpleTunneling]"),Object(l.b)("td",{parentName:"tr",align:null},"Actions that are called when convergence is detected.")))),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"edge_property")," (",Object(l.b)("em",{parentName:"li"},"str"),') \u2013 (default="weight")\nA string that determines the edge attribute that stores the edge weight.\nAny edge attribute not present defaults to 1.')),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,"The return value of the procedure is a map that contains the mapping of nodes to colors."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Return type")),Object(l.b)("p",null,"mgp.Record(node=str, color=str)"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Example")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cypher"},"MATCH (a:)-[e:CLOSE_TO]->(b:)\nWITH collect(a) as nodes, collect (e) as edges\nCALL graph_coloring.color_subgraph(nodes, edges, {no_of_colors: 2})\nYIELD color, node\nRETURN color, node;\n")))}p.isMDXComponent=!0},356:function(t,e,n){"use strict";n.d(e,"a",(function(){return m})),n.d(e,"b",(function(){return d}));var a=n(0),r=n.n(a);function l(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function b(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function i(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?b(Object(n),!0).forEach((function(e){l(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):b(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function o(t,e){if(null==t)return{};var n,a,r=function(t,e){if(null==t)return{};var n,a,r={},l=Object.keys(t);for(a=0;a<l.length;a++)n=l[a],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(t);for(a=0;a<l.length;a++)n=l[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var c=r.a.createContext({}),p=function(t){var e=r.a.useContext(c),n=e;return t&&(n="function"==typeof t?t(e):i(i({},e),t)),n},m=function(t){var e=p(t.components);return r.a.createElement(c.Provider,{value:e},t.children)},u={inlineCode:"code",wrapper:function(t){var e=t.children;return r.a.createElement(r.a.Fragment,{},e)}},g=r.a.forwardRef((function(t,e){var n=t.components,a=t.mdxType,l=t.originalType,b=t.parentName,c=o(t,["components","mdxType","originalType","parentName"]),m=p(n),g=a,d=m["".concat(b,".").concat(g)]||m[g]||u[g]||l;return n?r.a.createElement(d,i(i({ref:e},c),{},{components:n})):r.a.createElement(d,i({ref:e},c))}));function d(t,e){var n=arguments,a=e&&e.mdxType;if("string"==typeof t||a){var l=n.length,b=new Array(l);b[0]=g;var i={};for(var o in e)hasOwnProperty.call(e,o)&&(i[o]=e[o]);i.originalType=t,i.mdxType="string"==typeof t?t:a,b[1]=i;for(var c=2;c<l;c++)b[c]=n[c];return r.a.createElement.apply(null,b)}return r.a.createElement.apply(null,n)}g.displayName="MDXCreateElement"}}]);