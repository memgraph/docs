(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3961],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return d},kt:function(){return c}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),u=s(n),c=r,k=u["".concat(p,".").concat(c)]||u[c]||m[c]||i;return n?a.createElement(k,l(l({ref:t},d),{},{components:n})):a.createElement(k,l({ref:t},d))}));function c(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=u;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var s=2;s<i;s++)l[s]=n[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},89646:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return p},metadata:function(){return s},toc:function(){return d},default:function(){return u}});var a=n(22122),r=n(19756),i=(n(67294),n(3905)),l=["components"],o={id:"nxalg",title:"NetworkX Algorithms",sidebar_label:"NetworkX Algorithms"},p=void 0,s={unversionedId:"reference-guide/networkx/nxalg",id:"version-1.5.0/reference-guide/networkx/nxalg",isDocsHomePage:!1,title:"NetworkX Algorithms",description:"In addition to standalone community graph algorithms implemented as Python modules,",source:"@site/memgraph_versioned_docs/version-1.5.0/reference-guide/networkx/nxalg.md",sourceDirName:"reference-guide/networkx",slug:"/reference-guide/networkx/nxalg",permalink:"/memgraph/reference-guide/networkx/nxalg",editUrl:"https://github.com/memgraph/docs/tree/master/memgraph_versioned_docs/version-1.5.0/reference-guide/networkx/nxalg.md",version:"1.5.0",frontMatter:{id:"nxalg",title:"NetworkX Algorithms",sidebar_label:"NetworkX Algorithms"},sidebar:"version-1.5.0/memgraph",previous:{title:"Graph Analyzer",permalink:"/memgraph/reference-guide/networkx/graph-analyzer"},next:{title:"Weakly Connected Components",permalink:"/memgraph/reference-guide/networkx/wcc"}},d=[{value:"<code>all_shortest_paths(ctx, source, target, weight, method)</code>",id:"all_shortest_pathsctx-source-target-weight-method",children:[]},{value:"<code>all_simple_paths(ctx, source, target, cutoff)</code>",id:"all_simple_pathsctx-source-target-cutoff",children:[]},{value:"<code>ancestors(ctx, source)</code>",id:"ancestorsctx-source",children:[]},{value:"<code>betweenness_centrality(ctx, k, normalized, weight, endpoints, seed)</code>",id:"betweenness_centralityctx-k-normalized-weight-endpoints-seed",children:[]},{value:"<code>bfs_edges(ctx, source, reverse, depth_limit)</code>",id:"bfs_edgesctx-source-reverse-depth_limit",children:[]},{value:"<code>bfs_predecessors(ctx, source, depth_limit)</code>",id:"bfs_predecessorsctx-source-depth_limit",children:[]},{value:"<code>bfs_successors(ctx, source, depth_limit)</code>",id:"bfs_successorsctx-source-depth_limit",children:[]},{value:"<code>bfs_tree(ctx, source, reverse, depth_limit)</code>",id:"bfs_treectx-source-reverse-depth_limit",children:[]},{value:"<code>biconnected_components(ctx)</code>",id:"biconnected_componentsctx",children:[]},{value:"<code>bridges(ctx, root)</code>",id:"bridgesctx-root",children:[]},{value:"<code>center(ctx)</code>",id:"centerctx",children:[]},{value:"<code>chain_decomposition(ctx, root)</code>",id:"chain_decompositionctx-root",children:[]},{value:"<code>check_planarity(ctx)</code>",id:"check_planarityctx",children:[]},{value:"<code>clustering(ctx, nodes, weight)</code>",id:"clusteringctx-nodes-weight",children:[]},{value:"<code>communicability(ctx)</code>",id:"communicabilityctx",children:[]},{value:"<code>core_number(ctx)</code>",id:"core_numberctx",children:[]},{value:"<code>degree_assortativity_coefficient(ctx, x, y, weight, nodes)</code>",id:"degree_assortativity_coefficientctx-x-y-weight-nodes",children:[]},{value:"<code>descendants(ctx, source)</code>",id:"descendantsctx-source",children:[]},{value:"<code>dfs_postorder_nodes(ctx, source, depth_limit)</code>",id:"dfs_postorder_nodesctx-source-depth_limit",children:[]},{value:"<code>dfs_predecessors(ctx, source, depth_limit)</code>",id:"dfs_predecessorsctx-source-depth_limit",children:[]},{value:"<code>dfs_preorder_nodes(ctx, source, depth_limit)</code>",id:"dfs_preorder_nodesctx-source-depth_limit",children:[]},{value:"<code>dfs_successors(ctx, source, depth_limit)</code>",id:"dfs_successorsctx-source-depth_limit",children:[]},{value:"<code>dfs_tree(ctx, source, depth_limit)</code>",id:"dfs_treectx-source-depth_limit",children:[]},{value:"<code>diameter(ctx)</code>",id:"diameterctx",children:[]},{value:"<code>dominance_frontiers(ctx, start)</code>",id:"dominance_frontiersctx-start",children:[]},{value:"<code>dominating_set(ctx, start)</code>",id:"dominating_setctx-start",children:[]},{value:"<code>edge_bfs(ctx, source, orientation)</code>",id:"edge_bfsctx-source-orientation",children:[]},{value:"<code>edge_dfs(ctx, source, orientation)</code>",id:"edge_dfsctx-source-orientation",children:[]},{value:"<code>find_cliques(ctx)</code>",id:"find_cliquesctx",children:[]},{value:"<code>find_cycle(ctx, source, orientation)</code>",id:"find_cyclectx-source-orientation",children:[]},{value:"<code>flow_hierarchy(ctx, weight)</code>",id:"flow_hierarchyctx-weight",children:[]},{value:"<code>global_efficiency(ctx)</code>",id:"global_efficiencyctx",children:[]},{value:"<code>greedy_color(ctx, strategy, interchange)</code>",id:"greedy_colorctx-strategy-interchange",children:[]},{value:"<code>has_eulerian_path(ctx)</code>",id:"has_eulerian_pathctx",children:[]},{value:"<code>has_path(ctx, source, target)</code>",id:"has_pathctx-source-target",children:[]},{value:"<code>immediate_dominators(ctx, start)</code>",id:"immediate_dominatorsctx-start",children:[]},{value:"<code>is_arborescence(ctx)</code>",id:"is_arborescencectx",children:[]},{value:"<code>is_at_free(ctx)</code>",id:"is_at_freectx",children:[]},{value:"<code>is_bipartite(ctx)</code>",id:"is_bipartitectx",children:[]},{value:"<code>is_branching(ctx)</code>",id:"is_branchingctx",children:[]},{value:"<code>is_chordal(ctx)</code>",id:"is_chordalctx",children:[]},{value:"<code>is_distance_regular(ctx)</code>",id:"is_distance_regularctx",children:[]},{value:"<code>is_edge_cover(ctx, cover)</code>",id:"is_edge_coverctx-cover",children:[]},{value:"<code>is_eulerian(ctx)</code>",id:"is_eulerianctx",children:[]},{value:"<code>is_forest(ctx)</code>",id:"is_forestctx",children:[]},{value:"<code>is_isolate(ctx, n)</code>",id:"is_isolatectx-n",children:[]},{value:"<code>is_isomorphic(ctx, nodes1, edges1, nodes2, edges2)</code>",id:"is_isomorphicctx-nodes1-edges1-nodes2-edges2",children:[]},{value:"<code>is_semieulerian(ctx)</code>",id:"is_semieulerianctx",children:[]},{value:"<code>is_simple_path(ctx, nodes)</code>",id:"is_simple_pathctx-nodes",children:[]},{value:"<code>is_strongly_regular(ctx)</code>",id:"is_strongly_regularctx",children:[]},{value:"<code>is_tournament(ctx)</code>",id:"is_tournamentctx",children:[]},{value:"<code>is_tree(ctx)</code>",id:"is_treectx",children:[]},{value:"<code>isolates(ctx)</code>",id:"isolatesctx",children:[]},{value:"<code>jaccard_coefficient(ctx, ebunch)</code>",id:"jaccard_coefficientctx-ebunch",children:[]},{value:"<code>k_clique_communities(ctx, k, cliques)</code>",id:"k_clique_communitiesctx-k-cliques",children:[]},{value:"<code>k_components(ctx, density)</code>",id:"k_componentsctx-density",children:[]},{value:"<code>k_edge_components(ctx, k)</code>",id:"k_edge_componentsctx-k",children:[]},{value:"<code>local_efficiency(ctx)</code>",id:"local_efficiencyctx",children:[]},{value:"<code>lowest_common_ancestor(ctx, node1, node2)</code>",id:"lowest_common_ancestorctx-node1-node2",children:[]},{value:"<code>maximal_matching(ctx)</code>",id:"maximal_matchingctx",children:[]},{value:"<code>minimum_spanning_tree(ctx, weight, algorithm, ignore_nan)</code>",id:"minimum_spanning_treectx-weight-algorithm-ignore_nan",children:[]},{value:"<code>multi_source_dijkstra_path(ctx, ources, cutoff, weight)</code>",id:"multi_source_dijkstra_pathctx-ources-cutoff-weight",children:[]},{value:"<code>multi_source_dijkstra_path_length(ctx, sources, cutoff, weight)</code>",id:"multi_source_dijkstra_path_lengthctx-sources-cutoff-weight",children:[]},{value:"<code>node_boundary(ctx, nbunch1, bunch2)</code>",id:"node_boundaryctx-nbunch1-bunch2",children:[]},{value:"<code>node_connectivity(ctx, source, target)</code>",id:"node_connectivityctx-source-target",children:[]},{value:"<code>node_expansion(ctx, s)</code>",id:"node_expansionctx-s",children:[]},{value:"<code>non_randomness(ctx, k)</code>",id:"non_randomnessctx-k",children:[]},{value:"<code>pagerank(ctx, alpha, personalization, max_iter, tol, nstart, weight, dangling)</code>",id:"pagerankctx-alpha-personalization-max_iter-tol-nstart-weight-dangling",children:[]},{value:"<code>reciprocity(ctx, nodes)</code>",id:"reciprocityctx-nodes",children:[]},{value:"<code>shortest_path(ctx, source, target, weight, method)</code>",id:"shortest_pathctx-source-target-weight-method",children:[]},{value:"<code>shortest_path_length(ctx, source, target, weight, method)</code>",id:"shortest_path_lengthctx-source-target-weight-method",children:[]},{value:"<code>simple_cycles(ctx)</code>",id:"simple_cyclesctx",children:[]},{value:"<code>strongly_connected_components(ctx)</code>",id:"strongly_connected_componentsctx",children:[]},{value:"<code>topological_sort(ctx)</code>",id:"topological_sortctx",children:[]},{value:"<code>triadic_census(ctx)</code>",id:"triadic_censusctx",children:[]},{value:"<code>voronoi_cells(ctx, center_nodes, weight)</code>",id:"voronoi_cellsctx-center_nodes-weight",children:[]},{value:"<code>wiener_index(ctx, weight)</code>",id:"wiener_indexctx-weight",children:[]}],m={toc:d};function u(e){var t=e.components,n=(0,r.Z)(e,l);return(0,i.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"In addition to standalone community graph algorithms implemented as Python modules,\nwe implemented a module providing NetworkX integration with Memgraph.\nThis module, named ",(0,i.kt)("strong",{parentName:"p"},"nxalg"),", provides a comprehensive set of thin wrappers\naround most of the algorithms present in the NetworkX package.\nThe wrapper functions now have the capability to create a NetworkX\ncompatible graph-like object that can stream the native database graph\ndirectly saving on memory usage significantly."),(0,i.kt)("h2",{id:"all_shortest_pathsctx-source-target-weight-method"},(0,i.kt)("inlineCode",{parentName:"h2"},"all_shortest_paths(ctx, source, target, weight, method)")),(0,i.kt)("p",null,"Compute all shortest simple paths in the graph."),(0,i.kt)("p",null,"A simple path is a path with no repeated nodes."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"source")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Vertex"),") \u2013 Starting node for the path.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"target")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Vertex"),") \u2013 Ending node for the path.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"weight")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[str]"),") \u2013 (default=None)\nIf ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", every edge has weight/distance/cost 1.\nIf a string, use this edge attribute as the edge weight.\nAny edge attribute not present defaults to 1.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"method")," (",(0,i.kt)("em",{parentName:"li"},"str"),") \u2013 (default=\u2019dijkstra\u2019)\nThe algorithm to use to compute the path lengths.\nSupported options: \u2018dijkstra\u2019, \u2018bellman-ford\u2019.\nOther inputs produce a ValueError.\nIf ",(0,i.kt)("inlineCode",{parentName:"li"},"weight")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", unweighted graph methods are used, and this\nsuggestion is ignored.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"A list of all paths between source and target."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(paths=mgp.List[mgp.List","[mgp.Vertex]","])"),(0,i.kt)("h2",{id:"all_simple_pathsctx-source-target-cutoff"},(0,i.kt)("inlineCode",{parentName:"h2"},"all_simple_paths(ctx, source, target, cutoff)")),(0,i.kt)("p",null,"Returns all simple paths in the graph ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," from source to target."),(0,i.kt)("p",null,"A simple path is a path with no repeated nodes."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"source")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Vertex"),") \u2013 Starting node for the path.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"target")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Vertex"),") \u2013 Ending node for the path.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"cutoff")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[int]"),") \u2013 (default=None)\nDepth to stop the search. Only paths of ",(0,i.kt)("inlineCode",{parentName:"li"},"length <= cutoff")," are returned.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"A list of simple path lists. If there are no paths\nbetween the source and target within the given cutoff there is no output."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(paths=mgp.List[mgp.List","[mgp.Vertex]","])"),(0,i.kt)("h2",{id:"ancestorsctx-source"},(0,i.kt)("inlineCode",{parentName:"h2"},"ancestors(ctx, source)")),(0,i.kt)("p",null,"Returns all nodes having a path to ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"source")," (",(0,i.kt)("em",{parentName:"li"},"node"),") \u2013 A node in ",(0,i.kt)("inlineCode",{parentName:"li"},"G"),".")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"The ancestors of source in ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(ancestors=mgp.List","[mgp.Vertex]",")"),(0,i.kt)("h2",{id:"betweenness_centralityctx-k-normalized-weight-endpoints-seed"},(0,i.kt)("inlineCode",{parentName:"h2"},"betweenness_centrality(ctx, k, normalized, weight, endpoints, seed)")),(0,i.kt)("p",null,"Compute the shortest-path betweenness centrality for nodes."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Betweenness centrality")," is a measure of centrality in a graph based on shortest\npaths. Centrality identifies the most important nodes within a graph."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"k")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[str]"),") \u2013 (default=None)\nIf ",(0,i.kt)("inlineCode",{parentName:"li"},"k")," is not ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", use ",(0,i.kt)("inlineCode",{parentName:"li"},"k")," node samples to estimate betweenness.\nThe value of ",(0,i.kt)("inlineCode",{parentName:"li"},"k <= n")," where ",(0,i.kt)("inlineCode",{parentName:"li"},"n")," is the number of nodes in the graph.\nHigher values give a better approximation.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"normalized")," (",(0,i.kt)("em",{parentName:"li"},"bool"),") \u2013 (default=True)\nIf ",(0,i.kt)("inlineCode",{parentName:"li"},"True")," the betweenness values are normalized by ",(0,i.kt)("inlineCode",{parentName:"li"},"2/((n-1)(n-2))"),"\nfor graphs, and ",(0,i.kt)("inlineCode",{parentName:"li"},"1/((n-1)(n-2))")," for directed graphs where ",(0,i.kt)("inlineCode",{parentName:"li"},"n"),"\nis the number of nodes in ",(0,i.kt)("inlineCode",{parentName:"li"},"G"),".")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"weight")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[str]"),") \u2013 (default=None)\nIf ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"endpoints")," (",(0,i.kt)("em",{parentName:"li"},"bool"),") \u2013 (default=False)\nIf ",(0,i.kt)("inlineCode",{parentName:"li"},"True"),", includes the endpoints in the shortest path counts.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"seed")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[int]"),") \u2013 (default=None)\nIndicator of random number generation state.\nNote that this is only used if ",(0,i.kt)("inlineCode",{parentName:"li"},"k")," is not ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),".")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"Dictionary of nodes with betweenness centrality as the value."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(node=mgp.Vertex, betweenness=mgp.Number)"),(0,i.kt)("h2",{id:"bfs_edgesctx-source-reverse-depth_limit"},(0,i.kt)("inlineCode",{parentName:"h2"},"bfs_edges(ctx, source, reverse, depth_limit)")),(0,i.kt)("p",null,"Iterate over edges in a breadth-first-search starting at source."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"source")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Vertex"),") \u2013 Specify starting node for breadth-first search; this function\niterates over only those edges in the component reachable from\nthis node.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"reverse")," (",(0,i.kt)("em",{parentName:"li"},"bool"),") \u2013 (default=False)\nIf ",(0,i.kt)("inlineCode",{parentName:"li"},"True"),", traverse a directed graph in the reverse direction.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"depth_limit")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[int]"),") \u2013 (default=None)\nSpecify the maximum search depth.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"A list of edges in the breadth-first-search."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(edges=mgp.List","[mgp.Edge]",")"),(0,i.kt)("h2",{id:"bfs_predecessorsctx-source-depth_limit"},(0,i.kt)("inlineCode",{parentName:"h2"},"bfs_predecessors(ctx, source, depth_limit)")),(0,i.kt)("p",null,"Returns an iterator of predecessors in breadth-first-search from source."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"source")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Vertex"),") \u2013 Specify starting node for breadth-first search.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"depth_limit")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[int]"),") \u2013 (default=None)\nSpecify the maximum search depth.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"(node, predecessors)")," iterator where ",(0,i.kt)("inlineCode",{parentName:"p"},"predecessors")," is the list of\npredecessors of the node."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(node=mgp.Vertex, predecessor=mgp.Vertex)"),(0,i.kt)("h2",{id:"bfs_successorsctx-source-depth_limit"},(0,i.kt)("inlineCode",{parentName:"h2"},"bfs_successors(ctx, source, depth_limit)")),(0,i.kt)("p",null,"Returns an iterator of successors in breadth-first-search from source."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"source")," (",(0,i.kt)("em",{parentName:"li"},"node"),") \u2013 Specify starting node for breadth-first search.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"depth_limit")," (",(0,i.kt)("em",{parentName:"li"},"int optional"),") \u2013 (default=None)\nSpecify the maximum search depth.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"(node, successors)")," iterator where ",(0,i.kt)("inlineCode",{parentName:"p"},"successors")," is the list of\nsuccessors of the node."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(node=mgp.Vertex, successors=mgp.List","[mgp.Vertex]",")"),(0,i.kt)("h2",{id:"bfs_treectx-source-reverse-depth_limit"},(0,i.kt)("inlineCode",{parentName:"h2"},"bfs_tree(ctx, source, reverse, depth_limit)")),(0,i.kt)("p",null,"Returns an oriented tree constructed from of a breadth-first-search\nstarting at ",(0,i.kt)("inlineCode",{parentName:"p"},"source"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"source")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Vertex"),") \u2013 Specify starting node for breadth-first search.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"reverse")," (",(0,i.kt)("em",{parentName:"li"},"bool"),") \u2013 (default=False)\nIf ",(0,i.kt)("inlineCode",{parentName:"li"},"True"),", traverse a directed graph in the reverse direction.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"depth_limit")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[int]"),") \u2013 (default=None)\nSpecify the maximum search depth.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"An oriented tree."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(tree=mgp.List","[mgp.Vertex]",")"),(0,i.kt)("h2",{id:"biconnected_componentsctx"},(0,i.kt)("inlineCode",{parentName:"h2"},"biconnected_components(ctx)")),(0,i.kt)("p",null,"Returns a list of sets of nodes, one set for each biconnected\ncomponent of the graph"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Biconnected components")," are maximal subgraphs such that the removal of a\nnode (and all edges incident on that node) will not disconnect the\nsubgraph. Note that nodes may be part of more than one biconnected\ncomponent.  Those nodes are articulation points or cut vertices.  The\nremoval of articulation points will increase the number of connected\ncomponents of the graph."),(0,i.kt)("p",null,"Notice that by convention a dyad is considered a biconnected component."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"A list of sets of nodes, one set for each biconnected component."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(components=mgp.List[mgp.List","[mgp.Vertex]","])"),(0,i.kt)("h2",{id:"bridgesctx-root"},(0,i.kt)("inlineCode",{parentName:"h2"},"bridges(ctx, root)")),(0,i.kt)("p",null,"Returns all bridges in a graph."),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"bridge")," in a graph is an edge whose removal causes the number of\nconnected components of the graph to increase.  Equivalently, a bridge is an\nedge that does not belong to any cycle."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"root")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[mgp.Vertex]"),") \u2013 (default=None)\nA node in the graph ",(0,i.kt)("inlineCode",{parentName:"li"},"G"),". If specified, only the bridges in the\nconnected components containing this node will be returned.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"A list of edges in the graph whose removal disconnects the graph (or\ncauses the number of connected components to increase)."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(bridges=mgp.List","[mgp.Edge]",")"),(0,i.kt)("h2",{id:"centerctx"},(0,i.kt)("inlineCode",{parentName:"h2"},"center(ctx)")),(0,i.kt)("p",null,"Returns the center of the graph ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("em",{parentName:"p"},"center")," is the set of nodes with eccentricity equal to the radius."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"List of nodes in center."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(center=mgp.List","[mgp.Vertex]",")"),(0,i.kt)("h2",{id:"chain_decompositionctx-root"},(0,i.kt)("inlineCode",{parentName:"h2"},"chain_decomposition(ctx, root)")),(0,i.kt)("p",null,"Returns the chain decomposition of a graph."),(0,i.kt)("p",null,"The ",(0,i.kt)("em",{parentName:"p"},"chain decomposition")," of a graph with respect a depth-first\nsearch tree is a set of cycles or paths derived from the set of\nfundamental cycles of the tree in the following manner. Consider\neach fundamental cycle with respect to the given tree, represented\nas a list of edges beginning with the non tree edge oriented away\nfrom the root of the tree. For each fundamental cycle, if it\noverlaps with any previous fundamental cycle, just take the initial\nnon-overlapping segment, which is a path instead of a cycle. Each\ncycle or path is called a ",(0,i.kt)("em",{parentName:"p"},"chain"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"root")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[mgp.Vertex]"),") \u2013 (default=None)\nOptional. A node in the graph ",(0,i.kt)("inlineCode",{parentName:"li"},"G"),". If specified, only the chain\ndecomposition for the connected component containing this node\nwill be returned. This node indicates the root of the depth-first\nsearch tree.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"A list of edges representing a chain. There is no guarantee on\nthe orientation of the edges in each chain (for example, if a\nchain includes the edge joining nodes 1 and 2, the chain may\ninclude either (1, 2) or (2, 1))."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(chains=mgp.List[mgp.List","[mgp.Edge]","])"),(0,i.kt)("h2",{id:"check_planarityctx"},(0,i.kt)("inlineCode",{parentName:"h2"},"check_planarity(ctx)")),(0,i.kt)("p",null,"Check if a graph is planar."),(0,i.kt)("p",null,"A graph is planar if it can be drawn in a plane without\nany edge intersections."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"is_planar")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," if the graph is planar."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(is_planar=bool)"),(0,i.kt)("h2",{id:"clusteringctx-nodes-weight"},(0,i.kt)("inlineCode",{parentName:"h2"},"clustering(ctx, nodes, weight)")),(0,i.kt)("p",null,"Compute the clustering coefficient for nodes."),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"clustering coefficient")," is a measure of the degree to which nodes\nin a graph tend to cluster together."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"nodes")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable[mgp.List","[mgp.Vertex]","]"),") \u2013 (default=None)\nCompute clustering for nodes in this container.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"weight")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[str]"),") \u2013 (default=None)\nThe edge attribute that holds the numerical value used as a weight.\nIf ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", then each edge has weight 1.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"Clustering coefficient at specified nodes."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(node=mgp.Vertex, clustering=mgp.Number)"),(0,i.kt)("h2",{id:"communicabilityctx"},(0,i.kt)("inlineCode",{parentName:"h2"},"communicability(ctx)")),(0,i.kt)("p",null,"Returns communicability between all pairs of nodes in ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("em",{parentName:"p"},"communicability")," between pairs of nodes in ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is the sum of\nclosed walks of different lengths starting at node ",(0,i.kt)("inlineCode",{parentName:"p"},"u")," and ending at node ",(0,i.kt)("inlineCode",{parentName:"p"},"v"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"Dictionary of dictionaries keyed by nodes with communicability\nas the value."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(node1=mgp.Vertex, node2=mgp.Vertex, communicability=mgp.Number)"),(0,i.kt)("h2",{id:"core_numberctx"},(0,i.kt)("inlineCode",{parentName:"h2"},"core_number(ctx)")),(0,i.kt)("p",null,"Returns the core number for each vertex."),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"k-core")," is a maximal subgraph that contains nodes of degree ",(0,i.kt)("inlineCode",{parentName:"p"},"k")," or more."),(0,i.kt)("p",null,"The core number of a node is the largest value ",(0,i.kt)("inlineCode",{parentName:"p"},"k")," of a k-core containing\nthat node."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"A dictionary keyed by node to the core number."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(node=mgp.Vertex, core=mgp.Number)"),(0,i.kt)("h2",{id:"degree_assortativity_coefficientctx-x-y-weight-nodes"},(0,i.kt)("inlineCode",{parentName:"h2"},"degree_assortativity_coefficient(ctx, x, y, weight, nodes)")),(0,i.kt)("p",null,"Compute degree assortativity of a graph."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Assortativity")," measures the similarity of connections\nin the graph with respect to the node degree."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"x")," (",(0,i.kt)("em",{parentName:"li"},"str('in','out')"),") \u2013 (default=\u2019out\u2019)\nThe degree type for source node (directed graphs only).")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"y")," (",(0,i.kt)("em",{parentName:"li"},"str('in','out')"),") \u2013 (default=\u2019in\u2019)\nThe degree type for target node (directed graphs only).")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"weight")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[str]"),") \u2013 (default=None)\nThe edge attribute that holds the numerical value used\nas a weight.  If ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"nodes")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable[mgp.List","[mgp.Vertex]","]"),") \u2013 (default=None)\nCompute degree assortativity only for nodes in a container.\nThe default is all nodes.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"Assortativity of graph by degree."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(assortativity=float)"),(0,i.kt)("h2",{id:"descendantsctx-source"},(0,i.kt)("inlineCode",{parentName:"h2"},"descendants(ctx, source)")),(0,i.kt)("p",null,"Returns all nodes reachable from ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"source")," (",(0,i.kt)("em",{parentName:"li"},"node"),") \u2013 A node in ",(0,i.kt)("inlineCode",{parentName:"li"},"G"),".")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"The descendants of ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(descendants=mgp.List","[mgp.Vertex]",")"),(0,i.kt)("h2",{id:"dfs_postorder_nodesctx-source-depth_limit"},(0,i.kt)("inlineCode",{parentName:"h2"},"dfs_postorder_nodes(ctx, source, depth_limit)")),(0,i.kt)("p",null,"Returns nodes in a depth-first-search post-ordering starting at source."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"source")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Vertex"),") \u2013 Specify starting node for depth-first search.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"depth_limit")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[int]"),") \u2013 (default=None)\nSpecify the maximum search depth.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"A list of nodes in a depth-first-search post-ordering."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(nodes=mgp.List","[mgp.Vertex]",")"),(0,i.kt)("h2",{id:"dfs_predecessorsctx-source-depth_limit"},(0,i.kt)("inlineCode",{parentName:"h2"},"dfs_predecessors(ctx, source, depth_limit)")),(0,i.kt)("p",null,"Returns a dictionary of predecessors in depth-first-search from source."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"source")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Vertex"),") \u2013 Specify starting node for depth-first search.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"depth_limit")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[int]"),") \u2013 (default=None)\nSpecify the maximum search depth.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"A dictionary with nodes as keys and predecessor nodes as values."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(node=mgp.Vertex, predecessor=mgp.Vertex)"),(0,i.kt)("h2",{id:"dfs_preorder_nodesctx-source-depth_limit"},(0,i.kt)("inlineCode",{parentName:"h2"},"dfs_preorder_nodes(ctx, source, depth_limit)")),(0,i.kt)("p",null,"Returns nodes in a depth-first-search pre-ordering starting at source."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"source")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Vertex"),") \u2013 Specify starting node for depth-first search and return nodes in\nthe component reachable from\nthis node.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"depth_limit")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[int]"),") \u2013 (default=None)\nSpecify the maximum search depth.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"A list of nodes in a depth-first-search pre-ordering."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(nodes=mgp.List","[mgp.Vertex]",")"),(0,i.kt)("h2",{id:"dfs_successorsctx-source-depth_limit"},(0,i.kt)("inlineCode",{parentName:"h2"},"dfs_successors(ctx, source, depth_limit)")),(0,i.kt)("p",null,"Returns a dictionary of successors in depth-first-search from source."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"source")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Vertex"),") \u2013 Specify starting node for depth-first search.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"depth_limit")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[int]"),") \u2013 (default=None)\nSpecify the maximum search depth.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"A dictionary with nodes as keys and list of successor nodes as values."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(node=mgp.Vertex, successors=mgp.List","[mgp.Vertex]",")"),(0,i.kt)("h2",{id:"dfs_treectx-source-depth_limit"},(0,i.kt)("inlineCode",{parentName:"h2"},"dfs_tree(ctx, source, depth_limit)")),(0,i.kt)("p",null,"Returns an oriented tree constructed from a depth-first-search from source."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"source")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Vertex"),") \u2013 Specify starting node for depth-first search.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"depth_limit")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[int]"),") \u2013 (default=None)\nSpecify the maximum search depth.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"An oriented tree."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(tree=mgp.List","[mgp.Vertex]",")"),(0,i.kt)("h2",{id:"diameterctx"},(0,i.kt)("inlineCode",{parentName:"h2"},"diameter(ctx)")),(0,i.kt)("p",null,"Returns the diameter of the graph ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),"."),(0,i.kt)("p",null,"The diameter is the maximum eccentricity."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"Diameter of graph."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(diameter=int)"),(0,i.kt)("h2",{id:"dominance_frontiersctx-start"},(0,i.kt)("inlineCode",{parentName:"h2"},"dominance_frontiers(ctx, start)")),(0,i.kt)("p",null,"Returns the dominance frontiers of all nodes of a directed graph."),(0,i.kt)("p",null,"The ",(0,i.kt)("em",{parentName:"p"},"dominance frontier")," of a node ",(0,i.kt)("inlineCode",{parentName:"p"},"d")," is the set of all\nnodes such that ",(0,i.kt)("inlineCode",{parentName:"p"},"d")," dominates an immediate\npredecessor of a node, but ",(0,i.kt)("inlineCode",{parentName:"p"},"d")," does not strictly dominate that node."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"start")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Vertex"),") \u2013 The start node of dominance computation.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"A dictionary containing the dominance frontiers of each node reachable from\n",(0,i.kt)("inlineCode",{parentName:"p"},"start")," as lists."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(node=mgp.Vertex, frontier=mgp.List","[mgp.Vertex]",")"),(0,i.kt)("h2",{id:"dominating_setctx-start"},(0,i.kt)("inlineCode",{parentName:"h2"},"dominating_set(ctx, start)")),(0,i.kt)("p",null,"Finds a dominating set for the graph ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),"."),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"dominating set")," for a graph with node set ",(0,i.kt)("inlineCode",{parentName:"p"},"V")," is a subset ",(0,i.kt)("inlineCode",{parentName:"p"},"D")," of\n",(0,i.kt)("inlineCode",{parentName:"p"},"V")," such that every node not in ",(0,i.kt)("inlineCode",{parentName:"p"},"D")," is adjacent to at least one\nmember of ",(0,i.kt)("inlineCode",{parentName:"p"},"D"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"start")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Vertex"),") \u2013 Node to use as a starting point for the algorithm.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"A dominating set for ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(dominating_set=mgp.List","[mgp.Vertex]",")"),(0,i.kt)("h2",{id:"edge_bfsctx-source-orientation"},(0,i.kt)("inlineCode",{parentName:"h2"},"edge_bfs(ctx, source, orientation)")),(0,i.kt)("p",null,"A directed, breadth-first-search of edges in ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),", beginning at ",(0,i.kt)("inlineCode",{parentName:"p"},"source"),"."),(0,i.kt)("p",null,"Return the edges of ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," in a breadth-first-search order continuing until\nall edges are generated."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"source")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[mgp.Vertex]"),") \u2013 (default=None)\nThe node from which the traversal begins. If ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", then a source\nis chosen arbitrarily and repeatedly until all edges from each node in\nthe graph are searched.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"orientation")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[str]"),") \u2013 (default=None)\nFor directed graphs and directed multigraphs, edge traversals\nneed not respect the original orientation of the edges.\nWhen set to \u2018reverse\u2019, every edge is traversed in the reverse direction.\nWhen set to \u2018ignore\u2019, every edge is treated as undirected.\nWhen set to \u2018original\u2019, every edge is treated as directed.\nIn all three cases, the returned edge tuples add a last entry to\nindicate the direction in which that edge was traversed.\nIf ",(0,i.kt)("inlineCode",{parentName:"li"},"orientation")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", the returned edge has no direction indicated.\nThe direction is respected, but not reported.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"A directed edge indicating the path taken by the breadth-first-search.\nFor graphs, edge is of the form ",(0,i.kt)("inlineCode",{parentName:"p"},"(u, v)")," where ",(0,i.kt)("inlineCode",{parentName:"p"},"u")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"v"),"\nare the tail and head of the edge as determined by the traversal.\nFor multigraphs, edge is of the form ",(0,i.kt)("inlineCode",{parentName:"p"},"(u, v, key)"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," is\nthe key of the edge. When the graph is directed, then u and ",(0,i.kt)("inlineCode",{parentName:"p"},"v"),"\nare always in the order of the actual directed edge.\nIf ",(0,i.kt)("inlineCode",{parentName:"p"},"orientation")," is not ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," then the edge tuple is extended to include\nthe direction of traversal (\u2018forward\u2019 or \u2018reverse\u2019) on that edge."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(edges=mgp.List","[mgp.Edge]",")"),(0,i.kt)("h2",{id:"edge_dfsctx-source-orientation"},(0,i.kt)("inlineCode",{parentName:"h2"},"edge_dfs(ctx, source, orientation)")),(0,i.kt)("p",null,"A directed, depth-first-search of edges in ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),", beginning at ",(0,i.kt)("inlineCode",{parentName:"p"},"source"),"."),(0,i.kt)("p",null,"Return the edges of ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," in a depth-first-search order continuing until\nall edges are generated."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"source")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[mgp.Vertex]"),") \u2013 The node from which the traversal begins. If ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", then a source\nis chosen arbitrarily and repeatedly until all edges from each node in\nthe graph are searched.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"orientation")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[str]"),") \u2013 (default=None)\nFor directed graphs and directed multigraphs, edge traversals\nneed not respect the original orientation of the edges.\nWhen set to \u2018reverse\u2019, every edge is traversed in the reverse direction.\nWhen set to \u2018ignore\u2019, every edge is treated as undirected.\nWhen set to \u2018original\u2019, every edge is treated as directed.\nIn all three cases, the returned edge tuples add a last entry to\nindicate the direction in which that edge was traversed.\nIf ",(0,i.kt)("inlineCode",{parentName:"li"},"orientation")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", the returned edge has no direction indicated.\nThe direction is respected, but not reported.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"A directed edge indicating the path taken by the depth-first traversal.\nFor graphs, edge is of the form ",(0,i.kt)("inlineCode",{parentName:"p"},"(u, v)")," where ",(0,i.kt)("inlineCode",{parentName:"p"},"u")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"v"),"\nare the tail and head of the edge as determined by the traversal.\nFor multigraphs, edge is of the form ",(0,i.kt)("inlineCode",{parentName:"p"},"(u, v, key)"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," is\nthe key of the edge. When the graph is directed, then ",(0,i.kt)("inlineCode",{parentName:"p"},"u")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"v"),"\nare always in the order of the actual directed edge.\nIf ",(0,i.kt)("inlineCode",{parentName:"p"},"orientation")," is not ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," then the edge tuple is extended to include\nthe direction of traversal (\u2018forward\u2019 or \u2018reverse\u2019) on that edge."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(edges=mgp.List","[mgp.Edge]",")"),(0,i.kt)("h2",{id:"find_cliquesctx"},(0,i.kt)("inlineCode",{parentName:"h2"},"find_cliques(ctx)")),(0,i.kt)("p",null,"Returns all maximal cliques in an undirected graph."),(0,i.kt)("p",null,"For each node ",(0,i.kt)("inlineCode",{parentName:"p"},"v"),", a ",(0,i.kt)("em",{parentName:"p"},"maximal clique")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," is a largest complete\nsubgraph containing ",(0,i.kt)("inlineCode",{parentName:"p"},"v"),". The largest maximal clique is sometimes\ncalled the ",(0,i.kt)("em",{parentName:"p"},"maximum clique"),"."),(0,i.kt)("p",null,"This function returns an iterator over cliques, each of which is a\nlist of nodes. It is an iterative implementation, so should not\nsuffer from recursion depth issues."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"An iterator over maximal cliques, each of which is a list of\nnodes in ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),". The order of cliques is arbitrary."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(cliques=mgp.List[mgp.List","[mgp.Vertex]","])"),(0,i.kt)("h2",{id:"find_cyclectx-source-orientation"},(0,i.kt)("inlineCode",{parentName:"h2"},"find_cycle(ctx, source, orientation)")),(0,i.kt)("p",null,"Returns a cycle found via depth-first traversal."),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"cycle")," is a closed path in the graph.\nThe orientation of directed edges is determined by ",(0,i.kt)("inlineCode",{parentName:"p"},"orientation"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"source")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable[mgp.List","[mgp.Vertex]","]"),") \u2013 (default=None)\nThe node from which the traversal begins. If ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", then a source\nis chosen arbitrarily and repeatedly until all edges from each node in\nthe graph are searched.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"orientation")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[str]"),") \u2013 (default=None)\nFor directed graphs and directed multigraphs, edge traversals\nneed not respect the original orientation of the edges.\nWhen set to \u2018reverse\u2019 every edge is traversed in the reverse direction.\nWhen set to \u2018ignore\u2019, every edge is treated as undirected.\nWhen set to \u2018original\u2019, every edge is treated as directed.\nIn all three cases, the yielded edge tuples add a last entry to\nindicate the direction in which that edge was traversed.\nIf ",(0,i.kt)("inlineCode",{parentName:"li"},"orientation")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", the yielded edge has no direction indicated.\nThe direction is respected, but not reported.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"A list of directed edges indicating the path taken for the loop.\nIf no cycle is found, then an exception is raised.\nFor graphs, an edge is of the form ",(0,i.kt)("inlineCode",{parentName:"p"},"(u, v)")," where ",(0,i.kt)("inlineCode",{parentName:"p"},"u")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"v"),"\nare the tail and the head of the edge as determined by the traversal.\nFor multigraphs, an edge is of the form ",(0,i.kt)("inlineCode",{parentName:"p"},"(u, v, key)"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," is\nthe key of the edge. When the graph is directed, then ",(0,i.kt)("inlineCode",{parentName:"p"},"u")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"v"),"\nare always in the order of the actual directed edge.\nIf ",(0,i.kt)("inlineCode",{parentName:"p"},"orientation")," is not ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," then the edge tuple is extended to include\nthe direction of traversal (\u2018forward\u2019 or \u2018reverse\u2019) on that edge."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(cycle=mgp.Nullable[mgp.List","[mgp.Edge]","])"),(0,i.kt)("h2",{id:"flow_hierarchyctx-weight"},(0,i.kt)("inlineCode",{parentName:"h2"},"flow_hierarchy(ctx, weight)")),(0,i.kt)("p",null,"Returns the flow hierarchy of a directed network."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Flow hierarchy")," is defined as the fraction of edges not participating\nin cycles in a directed graph."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"weight")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[str]"),") \u2013 (default=None)\nAttribute to use for node weights. If ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", the weight defaults to 1.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"Flow hierarchy value."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(flow_hierarchy=float)"),(0,i.kt)("h2",{id:"global_efficiencyctx"},(0,i.kt)("inlineCode",{parentName:"h2"},"global_efficiency(ctx)")),(0,i.kt)("p",null,"Returns the average global efficiency of the graph."),(0,i.kt)("p",null,"The ",(0,i.kt)("em",{parentName:"p"},"efficiency")," of a pair of nodes in a graph is the multiplicative\ninverse of the shortest path distance between the nodes. The ",(0,i.kt)("em",{parentName:"p"},"average\nglobal efficiency")," of a graph is the average efficiency of all pairs of\nnodes."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"The average global efficiency of the graph."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(global_efficiency=float)"),(0,i.kt)("h2",{id:"greedy_colorctx-strategy-interchange"},(0,i.kt)("inlineCode",{parentName:"h2"},"greedy_color(ctx, strategy, interchange)")),(0,i.kt)("p",null,"Color a graph using various strategies of greedy graph coloring."),(0,i.kt)("p",null,"Attempts to color a graph using as few colors as possible, where no\nneighbours of a node can have the same color as the node itself.\nThe given strategy determines the order in which nodes are colored."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"strategy")," (",(0,i.kt)("em",{parentName:"li"},"str"),") \u2013 (default=\u2019largest_first\u2019)\nThe parameter ",(0,i.kt)("inlineCode",{parentName:"li"},"function(G,colors)")," is a function\n(or a string representing a function) that provides\nthe coloring strategy, by returning nodes in the order they\nshould be colored. ",(0,i.kt)("inlineCode",{parentName:"li"},"G")," is the graph, and ",(0,i.kt)("inlineCode",{parentName:"li"},"colors")," is a\ndictionary of the currently assigned colors, keyed by nodes. The\nfunction must return an iterable over all the nodes in ",(0,i.kt)("inlineCode",{parentName:"li"},"G"),".\nIf the strategy function is an iterator generator (a function with\n",(0,i.kt)("inlineCode",{parentName:"li"},"yield")," statements), keep in mind that the ",(0,i.kt)("inlineCode",{parentName:"li"},"colors")," dictionary\nwill be updated after each ",(0,i.kt)("inlineCode",{parentName:"li"},"yield"),", since\nthis function chooses colors greedily.\nIf ",(0,i.kt)("inlineCode",{parentName:"li"},"strategy")," is a string, it must be one of the following,\neach of which represents one of the built-in strategy functions.\n",(0,i.kt)("inlineCode",{parentName:"li"},"'largest_first'"),(0,i.kt)("inlineCode",{parentName:"li"},"'random_sequential'"),(0,i.kt)("inlineCode",{parentName:"li"},"'smallest_last'"),(0,i.kt)("inlineCode",{parentName:"li"},"'independent_set'"),(0,i.kt)("inlineCode",{parentName:"li"},"'connected_sequential_bfs'"),(0,i.kt)("inlineCode",{parentName:"li"},"'connected_sequential_dfs'"),(0,i.kt)("inlineCode",{parentName:"li"},"'connected_sequential'")," (alias for the previous strategy)\n",(0,i.kt)("inlineCode",{parentName:"li"},"'saturation_largest_first'"),(0,i.kt)("inlineCode",{parentName:"li"},"'DSATUR'")," (alias for the previous strategy)")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"interchange")," (",(0,i.kt)("em",{parentName:"li"},"bool"),") \u2013 (default=False)\nWill use the color interchange algorithm if set to ",(0,i.kt)("inlineCode",{parentName:"li"},"True"),".\nNote that ",(0,i.kt)("inlineCode",{parentName:"li"},"saturation_largest_first")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"independent_set"),"\ndo not work with interchange. Furthermore, if you use\ninterchange with your own strategy function, you cannot rely\non the values in the ",(0,i.kt)("inlineCode",{parentName:"li"},"colors")," argument.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"A dictionary with keys representing nodes and values representing\ncorresponding coloring."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(node=mgp.Vertex, color=int)"),(0,i.kt)("h2",{id:"has_eulerian_pathctx"},(0,i.kt)("inlineCode",{parentName:"h2"},"has_eulerian_path(ctx)")),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," has an Eulerian path."),(0,i.kt)("p",null,"An ",(0,i.kt)("em",{parentName:"p"},"Eulerian path")," is a path in a graph that uses each edge of a graph\nexactly once."),(0,i.kt)("p",null,"A directed graph has an Eulerian path if:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"at most one vertex has ",(0,i.kt)("inlineCode",{parentName:"li"},"out_degree - in_degree = 1"),","),(0,i.kt)("li",{parentName:"ul"},"at most one vertex has ",(0,i.kt)("inlineCode",{parentName:"li"},"in_degree - out_degree = 1"),","),(0,i.kt)("li",{parentName:"ul"},"every other vertex has equal in_degree and out_degree,"),(0,i.kt)("li",{parentName:"ul"},"and all of its vertices with nonzero degree belong to a\nsingle connected component of the underlying undirected graph.")),(0,i.kt)("p",null,"An undirected graph has an Eulerian path if exactly zero or\ntwo vertices have an odd degree and all of its vertices with\nnonzero degrees belong to a single connected component."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," has an eulerian path."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(has_eulerian_path=bool)"),(0,i.kt)("h2",{id:"has_pathctx-source-target"},(0,i.kt)("inlineCode",{parentName:"h2"},"has_path(ctx, source, target)")),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," has a path from ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"target"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"source")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Vertex"),") \u2013 Starting node for the path.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"target")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Vertex"),") \u2013 Ending node for the path.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," has a path from ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"target"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(has_path=bool)"),(0,i.kt)("h2",{id:"immediate_dominatorsctx-start"},(0,i.kt)("inlineCode",{parentName:"h2"},"immediate_dominators(ctx, start)")),(0,i.kt)("p",null,"Returns the immediate dominators of all nodes of a directed graph."),(0,i.kt)("p",null,"The immediate dominator of a node is the unique node that\nStrictly dominates a node ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," but does not strictly dominate any other node\nThat dominates ",(0,i.kt)("inlineCode",{parentName:"p"},"n"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"start")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Vertex"),") \u2013 The start node of dominance computation.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"A dictionary containing the immediate dominators of each node reachable from\n",(0,i.kt)("inlineCode",{parentName:"p"},"start"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(node=mgp.Vertex, dominator=mgp.Vertex)"),(0,i.kt)("h2",{id:"is_arborescencectx"},(0,i.kt)("inlineCode",{parentName:"h2"},"is_arborescence(ctx)")),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is an arborescence."),(0,i.kt)("p",null,"An ",(0,i.kt)("em",{parentName:"p"},"arborescence")," is a directed tree with maximum in-degree equal to 1."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"A boolean that is ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is an arborescence."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(is_arborescence=bool)"),(0,i.kt)("h2",{id:"is_at_freectx"},(0,i.kt)("inlineCode",{parentName:"h2"},"is_at_free(ctx)")),(0,i.kt)("p",null,"Check if a graph is AT-free."),(0,i.kt)("p",null,"The method uses the find_asteroidal_triple method to recognize\nan AT-free graph. If no asteroidal triple is found, the graph is\nAT-free and ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," is returned. If at least one asteroidal triple is\nfound, the graph is not AT-free and ",(0,i.kt)("inlineCode",{parentName:"p"},"False")," is returned."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is AT-free and ",(0,i.kt)("inlineCode",{parentName:"p"},"False")," otherwise."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(is_at_free=bool)"),(0,i.kt)("h2",{id:"is_bipartitectx"},(0,i.kt)("inlineCode",{parentName:"h2"},"is_bipartite(ctx)")),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," if graph ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is bipartite, ",(0,i.kt)("inlineCode",{parentName:"p"},"False")," if not."),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"bipartite graph")," (or bigraph) is a graph whose vertices can be\ndivided into two disjoint and independent sets","`","`","u","`","`"," and ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," and such that\nevery edge connects a vertex in ",(0,i.kt)("inlineCode",{parentName:"p"},"u")," one in ",(0,i.kt)("inlineCode",{parentName:"p"},"v"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is bipartite and ",(0,i.kt)("inlineCode",{parentName:"p"},"False")," otherwise."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(is_bipartite=bool)"),(0,i.kt)("h2",{id:"is_branchingctx"},(0,i.kt)("inlineCode",{parentName:"h2"},"is_branching(ctx)")),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is a branching."),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"branching")," is a directed forest with maximum in-degree equal to 1."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"A boolean that is ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is a branching."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(is_branching=bool)"),(0,i.kt)("h2",{id:"is_chordalctx"},(0,i.kt)("inlineCode",{parentName:"h2"},"is_chordal(ctx)")),(0,i.kt)("p",null,"Checks whether ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is a chordal graph."),(0,i.kt)("p",null,"A graph is ",(0,i.kt)("em",{parentName:"p"},"chordal")," if every cycle of length at least 4 has a chord\n(an edge joining two nodes not adjacent in the cycle)."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is a chordal graph and ",(0,i.kt)("inlineCode",{parentName:"p"},"False")," otherwise."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(is_chordal=bool)"),(0,i.kt)("h2",{id:"is_distance_regularctx"},(0,i.kt)("inlineCode",{parentName:"h2"},"is_distance_regular(ctx)")),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," if the graph is distance regular, ",(0,i.kt)("inlineCode",{parentName:"p"},"False")," otherwise."),(0,i.kt)("p",null,"A connected graph ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is distance-regular if for any nodes ",(0,i.kt)("inlineCode",{parentName:"p"},"x,y"),"\nand any integers ",(0,i.kt)("inlineCode",{parentName:"p"},"i,j=0,1,...,d")," (where ",(0,i.kt)("inlineCode",{parentName:"p"},"d")," is the graph\ndiameter), the number of vertices at distance ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," from ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and\ndistance ",(0,i.kt)("inlineCode",{parentName:"p"},"j")," from ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," depends only on ",(0,i.kt)("inlineCode",{parentName:"p"},"i,j")," and the graph distance\nbetween ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),", independently of the choice of ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"True")," if the graph is Distance Regular, ",(0,i.kt)("inlineCode",{parentName:"p"},"False")," otherwise."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(is_distance_regular=bool)"),(0,i.kt)("h2",{id:"is_edge_coverctx-cover"},(0,i.kt)("inlineCode",{parentName:"h2"},"is_edge_cover(ctx, cover)")),(0,i.kt)("p",null,"Decides whether a set of edges is a valid edge cover of the graph."),(0,i.kt)("p",null,"Given a set of edges, it can be decided whether the set is\nan ",(0,i.kt)("em",{parentName:"p"},"edge covering")," if checked whether all nodes of the graph\nhave an edge from the set incident on it."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"cover")," (",(0,i.kt)("em",{parentName:"li"},"mgp.List","[mgp.Edge]"),") \u2013 A list of edges to be checked.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"Whether the set of edges is a valid edge cover of the graph."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(is_edge_cover=bool)"),(0,i.kt)("h2",{id:"is_eulerianctx"},(0,i.kt)("inlineCode",{parentName:"h2"},"is_eulerian(ctx)")),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," if and only if ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is Eulerian."),(0,i.kt)("p",null,"A graph is ",(0,i.kt)("em",{parentName:"p"},"Eulerian")," if it has an Eulerian circuit. An ",(0,i.kt)("em",{parentName:"p"},"Eulerian\ncircuit")," is a closed walk that includes each edge of a graph exactly\nonce."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is Eulerian."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(is_eulerian=bool)"),(0,i.kt)("h2",{id:"is_forestctx"},(0,i.kt)("inlineCode",{parentName:"h2"},"is_forest(ctx)")),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is a forest."),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"forest")," is a graph with no undirected cycles."),(0,i.kt)("p",null,"For directed graphs, ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is a forest if the underlying graph is a forest.\nThe underlying graph is obtained by treating each directed edge as a single\nundirected edge in a multigraph."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"A boolean that is ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is a forest."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(is_forest=bool)"),(0,i.kt)("h2",{id:"is_isolatectx-n"},(0,i.kt)("inlineCode",{parentName:"h2"},"is_isolate(ctx, n)")),(0,i.kt)("p",null,"Determines whether a node is an isolate."),(0,i.kt)("p",null,"An ",(0,i.kt)("em",{parentName:"p"},"isolate")," is a node with no neighbors (that is, with degree\nzero). For directed graphs, this means no in-neighbors and no\nout-neighbors."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"n")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Vertex"),") \u2013 A node in ",(0,i.kt)("inlineCode",{parentName:"li"},"G"),".")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"True")," if and only if ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," has no neighbors."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(is_isolate=bool)"),(0,i.kt)("h2",{id:"is_isomorphicctx-nodes1-edges1-nodes2-edges2"},(0,i.kt)("inlineCode",{parentName:"h2"},"is_isomorphic(ctx, nodes1, edges1, nodes2, edges2)")),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," if the graphs ",(0,i.kt)("inlineCode",{parentName:"p"},"G1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"G2")," are isomorphic\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"False")," otherwise."),(0,i.kt)("p",null,"The two graphs ",(0,i.kt)("inlineCode",{parentName:"p"},"G1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"G2")," must be the same type."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"nodes1")," (",(0,i.kt)("em",{parentName:"li"},"mgp.List","[mgp.Vertex]"),") \u2013 Nodes in ",(0,i.kt)("inlineCode",{parentName:"li"},"G1"),".")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"edges1")," (",(0,i.kt)("em",{parentName:"li"},"mgp.List","[mgp.Edge]"),") \u2013 Edges in ",(0,i.kt)("inlineCode",{parentName:"li"},"G1"),".")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"nodes2")," (",(0,i.kt)("em",{parentName:"li"},"mgp.List","[mgp.Vertex]"),") \u2013 Nodes in ",(0,i.kt)("inlineCode",{parentName:"li"},"G2"),".")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"edges2")," (",(0,i.kt)("em",{parentName:"li"},"mgp.List","[mgp.Edge]"),") \u2013 Edges in ",(0,i.kt)("inlineCode",{parentName:"li"},"G2"),".")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"True")," if the graphs ",(0,i.kt)("inlineCode",{parentName:"p"},"G1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"G2")," are isomorphic\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"False")," otherwise."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(is_isomorphic=bool)"),(0,i.kt)("h2",{id:"is_semieulerianctx"},(0,i.kt)("inlineCode",{parentName:"h2"},"is_semieulerian(ctx)")),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is semi-Eulerian."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"G")," is semi-Eulerian if it has an Eulerian path but no Eulerian circuit."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is semi-Eulerian."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(is_semieulerian=bool)"),(0,i.kt)("h2",{id:"is_simple_pathctx-nodes"},(0,i.kt)("inlineCode",{parentName:"h2"},"is_simple_path(ctx, nodes)")),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," if and only if the given nodes form a simple path in\n",(0,i.kt)("inlineCode",{parentName:"p"},"G"),"."),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"simple path")," in a graph is a nonempty sequence of nodes in which\nno node appears more than once in the sequence and each adjacent\npair of nodes in the sequence is adjacent in the graph."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"nodes")," (",(0,i.kt)("em",{parentName:"li"},"mgp.List","[mgp.Vertex]"),") \u2013 A list of one or more nodes in the graph ",(0,i.kt)("inlineCode",{parentName:"li"},"G"),".")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"Whether the given list of nodes represents a simple path in ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(is_simple_path=bool)"),(0,i.kt)("h2",{id:"is_strongly_regularctx"},(0,i.kt)("inlineCode",{parentName:"h2"},"is_strongly_regular(ctx)")),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," if and only if the given graph is strongly\nregular."),(0,i.kt)("p",null,"An undirected graph is ",(0,i.kt)("em",{parentName:"p"},"strongly regular")," if"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"it is regular,")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"each pair of adjacent vertices has the same number of neighbors in\ncommon,")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"each pair of nonadjacent vertices has the same number of neighbors\nin common.")),(0,i.kt)("p",null,"Each strongly regular graph is a distance-regular graph.\nConversely, if a distance-regular graph has a diameter of two,\nthen it is a strongly regular graph."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"Whether ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is strongly regular."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(is_strongly_regular=bool)"),(0,i.kt)("h2",{id:"is_tournamentctx"},(0,i.kt)("inlineCode",{parentName:"h2"},"is_tournament(ctx)")),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," if and only if ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is a tournament."),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"tournament")," is a directed graph, with neither self-loops nor\nmulti-edges, in which there is exactly one directed edge joining\neach pair of distinct nodes."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"Whether the given graph is a tournament graph."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(is_tournament=bool)"),(0,i.kt)("h2",{id:"is_treectx"},(0,i.kt)("inlineCode",{parentName:"h2"},"is_tree(ctx)")),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is a tree."),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"tree")," is a connected graph with no undirected cycles."),(0,i.kt)("p",null,"For directed graphs, ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is a tree if the underlying graph is a tree. The\nunderlying graph is obtained by treating each directed edge as a single\nundirected edge in a multigraph."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"A boolean that is ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is a tree."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(is_tree=bool)"),(0,i.kt)("h2",{id:"isolatesctx"},(0,i.kt)("inlineCode",{parentName:"h2"},"isolates(ctx)")),(0,i.kt)("p",null,"Returns a list of isolates in the graph."),(0,i.kt)("p",null,"An ",(0,i.kt)("em",{parentName:"p"},"isolate")," is a node with no neighbors (that is, with degree\nzero). For directed graphs, this means no in-neighbors and no\nout-neighbors."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"A list of isolates in ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(isolates=mgp.List","[mgp.Vertex]",")"),(0,i.kt)("h2",{id:"jaccard_coefficientctx-ebunch"},(0,i.kt)("inlineCode",{parentName:"h2"},"jaccard_coefficient(ctx, ebunch)")),(0,i.kt)("p",null,"Compute the Jaccard coefficient of all node pairs in ",(0,i.kt)("inlineCode",{parentName:"p"},"ebunch"),"."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Jaccard coefficient")," compares members of two sets to see\nwhich members are shared and which are distinct."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ebunch")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable",(0,i.kt)("strong",{parentName:"em"},"["),"mgp.List",(0,i.kt)("strong",{parentName:"em"},"["),"mgp.List","[mgp.Vertex]",(0,i.kt)("strong",{parentName:"em"},"]"),"]"),") \u2013 (default=None)\nJaccard coefficient will be computed for each pair of nodes\ngiven in the iterable. The pairs must be given as 2-tuples\n",(0,i.kt)("inlineCode",{parentName:"li"},"(u, v)")," where ",(0,i.kt)("inlineCode",{parentName:"li"},"u")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"v")," are nodes in the graph.\nIf ",(0,i.kt)("inlineCode",{parentName:"li"},"ebunch")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"None")," then all non-existent edges in the\ngraph will be used.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"An iterator of 3-tuples in the form ",(0,i.kt)("inlineCode",{parentName:"p"},"(u, v, p)")," where ",(0,i.kt)("inlineCode",{parentName:"p"},"(u, v)")," is a\npair of nodes and ",(0,i.kt)("inlineCode",{parentName:"p"},"p")," is their Jaccard coefficient."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(u=mgp.Vertex, v=mgp.Vertex, coef=float)"),(0,i.kt)("h2",{id:"k_clique_communitiesctx-k-cliques"},(0,i.kt)("inlineCode",{parentName:"h2"},"k_clique_communities(ctx, k, cliques)")),(0,i.kt)("p",null,"Find k-clique communities in a graph using the percolation method."),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"k-clique community")," is the union of all cliques of size ",(0,i.kt)("inlineCode",{parentName:"p"},"k")," that\ncan be reached through adjacent (sharing ",(0,i.kt)("inlineCode",{parentName:"p"},"k-1")," nodes) k-cliques."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"k")," (",(0,i.kt)("em",{parentName:"li"},"int"),") \u2013 Size of the smallest clique.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"cliques")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable",(0,i.kt)("strong",{parentName:"em"},"["),"mgp.List",(0,i.kt)("strong",{parentName:"em"},"["),"mgp.List","[mgp.Vertex]",(0,i.kt)("strong",{parentName:"em"},"]"),"]"),") \u2013 (default=None)\nPrecomputed cliques (use networkx.find_cliques(G)).")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"Sets of nodes, one for each k-clique community."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(communities=mgp.List[mgp.List","[mgp.Vertex]","])"),(0,i.kt)("h2",{id:"k_componentsctx-density"},(0,i.kt)("inlineCode",{parentName:"h2"},"k_components(ctx, density)")),(0,i.kt)("p",null,"Returns the approximate k-component structure of a graph ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),"."),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"k-component")," is a maximal subgraph of a graph ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," that has, at least,\nnode connectivity ",(0,i.kt)("inlineCode",{parentName:"p"},"k"),": we need to remove at least ",(0,i.kt)("inlineCode",{parentName:"p"},"k")," nodes to break it\ninto more components. k-components have an inherent hierarchical\nstructure because they are nested in terms of connectivity: a connected\ngraph can contain several 2-components, each of which can contain\none or more 3-components, and so forth."),(0,i.kt)("p",null,"This implementation is based on the fast heuristics to approximate\nthe k-component structure of a graph. This, in turn, is based on\na fast approximation algorithm for finding good lower bounds of the number\nof node independent paths between two nodes."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"min_density")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Number"),") \u2013 (default=0.95)\nDensity relaxation threshold.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"Dictionary with connectivity level ",(0,i.kt)("inlineCode",{parentName:"p"},"k")," as key and a list of\nsets of nodes that form a k-component of level ",(0,i.kt)("inlineCode",{parentName:"p"},"k")," as values."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(k=int, components=mgp.List[mgp.List","[mgp.Vertex]","])"),(0,i.kt)("h2",{id:"k_edge_componentsctx-k"},(0,i.kt)("inlineCode",{parentName:"h2"},"k_edge_components(ctx, k)")),(0,i.kt)("p",null,"Returns nodes in each maximal k-edge-connected component in ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),"."),(0,i.kt)("p",null,"A connected graph is ",(0,i.kt)("em",{parentName:"p"},"k-edge-connected")," if it remains connected\nwhenever fewer than k edges are removed. The edge-connectivity of\na graph is the largest k for which the graph is k-edge-connected."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"k")," (",(0,i.kt)("em",{parentName:"li"},"int"),") \u2013 Desired edge connectivity.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"A list of k-edge-ccs. Each set of returned nodes\nwill have k-edge-connectivity in the graph ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(components=mgp.List[mgp.List","[mgp.Vertex]","])"),(0,i.kt)("h2",{id:"local_efficiencyctx"},(0,i.kt)("inlineCode",{parentName:"h2"},"local_efficiency(ctx)")),(0,i.kt)("p",null,"Returns the average local efficiency of the graph."),(0,i.kt)("p",null,"The ",(0,i.kt)("em",{parentName:"p"},"efficiency")," of a pair of nodes in a graph is the multiplicative\ninverse of the shortest path distance between the nodes. The ",(0,i.kt)("em",{parentName:"p"},"local\nefficiency")," of a node in the graph is the average global efficiency of the\nsubgraph induced by the neighbors of the node. The ",(0,i.kt)("em",{parentName:"p"},"average local\nefficiency")," is the average of the local efficiencies of each node."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"The average local efficiency of the graph."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(local_efficiency=float)"),(0,i.kt)("h2",{id:"lowest_common_ancestorctx-node1-node2"},(0,i.kt)("inlineCode",{parentName:"h2"},"lowest_common_ancestor(ctx, node1, node2)")),(0,i.kt)("p",null,"Compute the lowest common ancestor of the given pair of nodes."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"node1")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Vertex"),") \u2013 A node in the graph.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"node2")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Vertex"),") \u2013 A node in the graph.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"The lowest common ancestor of ",(0,i.kt)("inlineCode",{parentName:"p"},"node1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"node2"),",\nor default if they have no common ancestors."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(ancestor=mgp.Nullable","[mgp.Vertex]",")"),(0,i.kt)("h2",{id:"maximal_matchingctx"},(0,i.kt)("inlineCode",{parentName:"h2"},"maximal_matching(ctx)")),(0,i.kt)("p",null,"Find a maximal matching in the graph."),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"matching")," is a subset of edges in which no node occurs more than once.\nA ",(0,i.kt)("em",{parentName:"p"},"maximal matching")," cannot add more edges and still be a matching."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"A maximal matching of the graph."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(edges=mgp.List","[mgp.Edge]",")"),(0,i.kt)("h2",{id:"minimum_spanning_treectx-weight-algorithm-ignore_nan"},(0,i.kt)("inlineCode",{parentName:"h2"},"minimum_spanning_tree(ctx, weight, algorithm, ignore_nan)")),(0,i.kt)("p",null,"Returns a minimum spanning tree or forest on an undirected graph ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),"."),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"minimum spanning tree")," is a subset of the edges of a\nconnected, undirected graph that connects all of the\nvertices together without any cycles."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"weight")," (",(0,i.kt)("em",{parentName:"li"},"str"),") \u2013 (default=\u2019weight\u2019)\nData key to use for edge weights.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"algorithm")," (",(0,i.kt)("em",{parentName:"li"},"str"),") \u2013 (default=\u2019kruskal\u2019)\nThe algorithm to use when finding a minimum spanning tree.\nValid choices are \u2018kruskal\u2019, \u2018prim\u2019, or \u2018boruvka\u2019.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ignore_nan")," (",(0,i.kt)("em",{parentName:"li"},"bool"),") \u2013 (default=False)\nIf ",(0,i.kt)("inlineCode",{parentName:"li"},"NaN")," is found as an edge weight normally an exception is raised.\nIf ",(0,i.kt)("inlineCode",{parentName:"li"},"ignore_nan")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"True")," then that edge is ignored.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"A minimum spanning tree or forest."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(nodes=mgp.List","[mgp.Vertex]",", edges=mgp.List","[mgp.Edge]",")"),(0,i.kt)("h2",{id:"multi_source_dijkstra_pathctx-ources-cutoff-weight"},(0,i.kt)("inlineCode",{parentName:"h2"},"multi_source_dijkstra_path(ctx, ources, cutoff, weight)")),(0,i.kt)("p",null,"Find shortest weighted paths in ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," from a given set of source\nnodes."),(0,i.kt)("p",null,"Compute shortest path between any of the source nodes and all other\nreachable nodes for a weighted graph."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"sources")," (",(0,i.kt)("em",{parentName:"li"},"mgp.List","[mgp.Vertex]"),") \u2013 Starting nodes for paths. If this is a set containing a\nsingle node, then all paths computed by this function will start\nfrom that node. If there are two or more nodes in the set, the\ncomputed paths may begin from any one of the start nodes.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"cutoff")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[int]"),") \u2013 (default=None)\nDepth to stop the search. Only return paths with ",(0,i.kt)("inlineCode",{parentName:"li"},"length <= cutoff"),".")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"weight")," (",(0,i.kt)("em",{parentName:"li"},"string function"),") \u2013 If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoining ",(0,i.kt)("inlineCode",{parentName:"li"},"u")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"v")," will be ",(0,i.kt)("inlineCode",{parentName:"li"},"G.edges[u, v][weight]"),"). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one. If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"A dictionary of shortest paths keyed by target."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(target=mgp.Vertex, path=mgp.List","[mgp.Vertex]",")"),(0,i.kt)("h2",{id:"multi_source_dijkstra_path_lengthctx-sources-cutoff-weight"},(0,i.kt)("inlineCode",{parentName:"h2"},"multi_source_dijkstra_path_length(ctx, sources, cutoff, weight)")),(0,i.kt)("p",null,"Find shortest weighted path lengths in ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," from a given set of\nsource nodes."),(0,i.kt)("p",null,"Compute the shortest path length between any of the source nodes and\nall other reachable nodes for a weighted graph."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"sources")," (",(0,i.kt)("em",{parentName:"li"},"mgp.List","[mgp.Vertex]"),") \u2013 Starting nodes for paths. If this is a set containing a\nsingle node, then all paths computed by this function will start\nfrom that node. If there are two or more nodes in the set, the\ncomputed paths may begin from any one of the start nodes.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"cutoff")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[int]"),") \u2013 (default=None)\nDepth to stop the search. Only return paths with ",(0,i.kt)("inlineCode",{parentName:"li"},"length <= cutoff"),".")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"weight")," (",(0,i.kt)("em",{parentName:"li"},"str"),") \u2013 If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoining ",(0,i.kt)("inlineCode",{parentName:"li"},"u")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"v")," will be ",(0,i.kt)("inlineCode",{parentName:"li"},"G.edges[u, v][weight]"),"). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one. If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"Dict keyed by node to shortest path length to nearest source."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(target=mgp.Vertex, length=mgp.Number)"),(0,i.kt)("h2",{id:"node_boundaryctx-nbunch1-bunch2"},(0,i.kt)("inlineCode",{parentName:"h2"},"node_boundary(ctx, nbunch1, bunch2)")),(0,i.kt)("p",null,"Returns the node boundary of ",(0,i.kt)("inlineCode",{parentName:"p"},"nbunch1"),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("em",{parentName:"p"},"node boundary")," of a set ",(0,i.kt)("inlineCode",{parentName:"p"},"S")," with respect to a set ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," is the\nset of nodes ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," such that for some ",(0,i.kt)("inlineCode",{parentName:"p"},"u")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"S"),", there is an\nedge joining ",(0,i.kt)("inlineCode",{parentName:"p"},"u")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"v"),". If ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," is not specified, it is assumed to\nbe the set of all nodes not in ",(0,i.kt)("inlineCode",{parentName:"p"},"S"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"nbunch1")," (",(0,i.kt)("em",{parentName:"li"},"mgp.List","[mgp.Vertex]"),") \u2013 List of nodes in the graph representing the set of nodes\nwhose node boundary will be returned. (This is the set ",(0,i.kt)("inlineCode",{parentName:"li"},"S")," from\nthe definition above.)")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"nbunch2")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable[mgp.List","[mgp.Vertex]","]"),") \u2013 List of nodes representing the target (or \u201cexterior\u201d) set of\nnodes. (This is the set ",(0,i.kt)("inlineCode",{parentName:"li"},"T")," from the definition above.) If not\nspecified, this is assumed to be the set of all nodes in ",(0,i.kt)("inlineCode",{parentName:"li"},"G"),"\nnot in ",(0,i.kt)("inlineCode",{parentName:"li"},"nbunch1"),".")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"The node boundary of ",(0,i.kt)("inlineCode",{parentName:"p"},"nbunch1")," with respect to ",(0,i.kt)("inlineCode",{parentName:"p"},"nbunch2"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(boundary=mgp.List","[mgp.Vertex]",")"),(0,i.kt)("h2",{id:"node_connectivityctx-source-target"},(0,i.kt)("inlineCode",{parentName:"h2"},"node_connectivity(ctx, source, target)")),(0,i.kt)("p",null,"Returns an approximation for node connectivity for a graph or digraph ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),"."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Node connectivity")," is equal to the minimum number of nodes that\nmust be removed to disconnect ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," or render it trivial. By Menger\u2019s theorem,\nthis is equal to the number of node independent paths (paths that\nshare no nodes other than ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"target"),")."),(0,i.kt)("p",null,"If ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"target")," nodes are provided, this function returns the\nlocal node connectivity: the minimum number of nodes that must be\nremoved to break all paths from source to ",(0,i.kt)("inlineCode",{parentName:"p"},"target")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),"."),(0,i.kt)("p",null,"This algorithm is based on a fast approximation that gives a strict lower\nbound on the actual number of node independent paths between two nodes.\nIt works for both directed and undirected graphs."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"source")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[mgp.Vertex]"),") \u2013 (default=None)\nSource node.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"target")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[mgp.Vertex]"),") \u2013 (default=None)\nTarget node.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"Node connectivity of ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),", or local node connectivity if ",(0,i.kt)("inlineCode",{parentName:"p"},"source"),"\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"target")," are provided."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(connectivity=int)"),(0,i.kt)("h2",{id:"node_expansionctx-s"},(0,i.kt)("inlineCode",{parentName:"h2"},"node_expansion(ctx, s)")),(0,i.kt)("p",null,"Returns the node expansion of the set ",(0,i.kt)("inlineCode",{parentName:"p"},"S"),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("em",{parentName:"p"},"node expansion")," is the quotient of the size of the node\nboundary of ",(0,i.kt)("inlineCode",{parentName:"p"},"S")," and the cardinality of ",(0,i.kt)("inlineCode",{parentName:"p"},"S"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"s")," (",(0,i.kt)("em",{parentName:"li"},"mgp.List","[mgp.Vertex]"),") \u2013 A sequence of nodes in ",(0,i.kt)("inlineCode",{parentName:"li"},"G"),".")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"The node expansion of the set ",(0,i.kt)("inlineCode",{parentName:"p"},"S"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(node_expansion=mgp.Number)"),(0,i.kt)("h2",{id:"non_randomnessctx-k"},(0,i.kt)("inlineCode",{parentName:"h2"},"non_randomness(ctx, k)")),(0,i.kt)("p",null,"Compute the non-randomness of graph ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),"."),(0,i.kt)("p",null,"The first returned value ",(0,i.kt)("inlineCode",{parentName:"p"},"non_randomness")," is the sum of non-randomness\nvalues of all edges within the graph (where the non-randomness of an edge\ntends to be small when the two nodes linked by that edge are from two different\ncommunities)."),(0,i.kt)("p",null,"The second computed value ",(0,i.kt)("inlineCode",{parentName:"p"},"relative_non_randomness")," is a relative measure\nthat indicates to what extent graph ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," is different from random graphs in terms\nof probability. When it is close to 0, the graph tends to be more\nlikely generated by an Erdos Renyi model."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"k")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[int]"),") \u2013 (default=None)\nThe number of communities in ",(0,i.kt)("inlineCode",{parentName:"li"},"G"),".\nIf ",(0,i.kt)("inlineCode",{parentName:"li"},"k")," is not set, the function will use a default community\ndetection algorithm to set it.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"Non-randomness and Relative non-randomness of the graph."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(non_randomness=float, relative_non_randomness=float)"),(0,i.kt)("h2",{id:"pagerankctx-alpha-personalization-max_iter-tol-nstart-weight-dangling"},(0,i.kt)("inlineCode",{parentName:"h2"},"pagerank(ctx, alpha, personalization, max_iter, tol, nstart, weight, dangling)")),(0,i.kt)("p",null,"Returns the PageRank of the nodes in the graph."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"PageRank")," computes a ranking of the nodes in the graph ",(0,i.kt)("inlineCode",{parentName:"p"},"G")," based on\nthe structure of the incoming links. It was originally designed as\nan algorithm to rank web pages."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"alpha")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Number"),") \u2013 (default=0.85)\nDamping parameter for PageRank.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"personalization")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[str]"),") \u2013 (default=None)\nThe \u201cpersonalization vector\u201d consisting of a dictionary with a\nsubset of graph nodes as a key and maps personalization value\nfor each subset. At least one personalization value must be non-zero.\nIf not specified, a nodes personalization value will be zero.\nBy default, a uniform distribution is used.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"max_iter")," (",(0,i.kt)("em",{parentName:"li"},"int"),") \u2013 (default=100)\nMaximum number of iterations in power method eigenvalue solver.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"tol")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Number"),") \u2013 (default=1e-06)\nError tolerance used to check convergence in power method solver.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"nstart")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[str]"),") \u2013 (default=None)\nStarting value of PageRank iteration for each node.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"weight")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[str]"),") \u2013 (default=\u2019weight\u2019)\nEdge data key to use as weight. If ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", weights are set to 1.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"dangling")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[str]"),") \u2013 (default=None)\nThe outedges to be assigned to any \u201cdangling\u201d nodes, i.e., nodes without\nany outedges. The dict key is the node the outedge points to and the dict\nvalue is the weight of that outedge. By default, dangling nodes are given\noutedges according to the personalization vector (uniform if not\nspecified). This must be selected to result in an irreducible transition\nmatrix. It may be common to have the dangling dict to be the same as\nthe personalization dict.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"Dictionary of nodes with PageRank as value."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(node=mgp.Vertex, rank=float)"),(0,i.kt)("h2",{id:"reciprocityctx-nodes"},(0,i.kt)("inlineCode",{parentName:"h2"},"reciprocity(ctx, nodes)")),(0,i.kt)("p",null,"Compute the reciprocity in a directed graph."),(0,i.kt)("p",null,"The ",(0,i.kt)("em",{parentName:"p"},"reciprocity")," of a directed graph is defined as the ratio\nof the number of edges pointing in both directions to the total\nnumber of edges in the graph."),(0,i.kt)("p",null,"The reciprocity of a single node ",(0,i.kt)("inlineCode",{parentName:"p"},"u")," is defined similarly,\nit is the ratio of the number of edges in both directions to\nthe total number of edges attached to node ",(0,i.kt)("inlineCode",{parentName:"p"},"u"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"nodes")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable[mgp.List","[mgp.Vertex]","]"),") \u2013 (default=None)\nCompute reciprocity for nodes in this container.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"Reciprocity keyed by node label."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(node=mgp.Nullable","[mgp.Vertex]",", reciprocity=mgp.Nullable","[float]",")"),(0,i.kt)("h2",{id:"shortest_pathctx-source-target-weight-method"},(0,i.kt)("inlineCode",{parentName:"h2"},"shortest_path(ctx, source, target, weight, method)")),(0,i.kt)("p",null,"Compute shortest paths in the graph."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"source")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[mgp.Vertex]"),") \u2013 (default=None)\nStarting node for the path. If not specified, compute shortest\npaths for each possible starting node.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"target")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[mgp.Vertex]"),") \u2013 (default=None)\nEnding node for the path. If not specified, compute shortest\npaths to all possible nodes.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"weight")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[str]"),") \u2013 (default=None)\nIf ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", every edge has weight/distance/cost 1.\nIf a string, use this edge attribute as the edge weight.\nAny edge attribute not present defaults to 1.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"method")," (",(0,i.kt)("em",{parentName:"li"},"str"),") \u2013 (default=\u2019dijkstra\u2019)\nThe algorithm used to compute the path.\nSupported options: \u2018dijkstra\u2019, \u2018bellman-ford\u2019.\nOther inputs produce a ValueError.\nIf ",(0,i.kt)("inlineCode",{parentName:"li"},"weight")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", unweighted graph methods are used\nand this suggestion is ignored.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"All returned paths include both the ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"target")," in the path.\nIf the ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"target")," are both specified, return a single list\nof nodes in a shortest path from the ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," to the ",(0,i.kt)("inlineCode",{parentName:"p"},"target"),".\nIf only the ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," is specified, return a dictionary keyed by\ntargets with a list of nodes in a shortest path from the ",(0,i.kt)("inlineCode",{parentName:"p"},"source"),"\nto one of the targets.\nIf only the ",(0,i.kt)("inlineCode",{parentName:"p"},"target")," is specified, return a dictionary keyed by\nsources with a list of nodes in a shortest path from one of the\nsources to the ",(0,i.kt)("inlineCode",{parentName:"p"},"target"),".\nIf neither the ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," nor ",(0,i.kt)("inlineCode",{parentName:"p"},"target")," are specified return a dictionary\nof dictionaries with ",(0,i.kt)("inlineCode",{parentName:"p"},"path[source][target]=[list of nodes in path]"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(source=mgp.Vertex, target=mgp.Vertex, path=mgp.List","[mgp.Vertex]",")"),(0,i.kt)("h2",{id:"shortest_path_lengthctx-source-target-weight-method"},(0,i.kt)("inlineCode",{parentName:"h2"},"shortest_path_length(ctx, source, target, weight, method)")),(0,i.kt)("p",null,"Compute shortest path lengths in the graph."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"source")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[mgp.Vertex]"),") \u2013 (default=None)\nStarting node for the path.\nIf not specified, compute shortest path lengths using all nodes as\nsource nodes.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"target")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[mgp.Vertex]"),") \u2013 (default=None)\nEnding node for the path.\nIf not specified, compute shortest path lengths using all nodes as\ntarget nodes.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"weight")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[str]"),") \u2013 (default=None)\nIf ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", every edge has weight/distance/cost 1.\nIf a string, use this edge attribute as the edge weight.\nAny edge attribute not present defaults to 1.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"method")," (",(0,i.kt)("em",{parentName:"li"},"str"),") \u2013 (default=\u2019dijkstra\u2019)\nThe algorithm to use to compute the path length.\nSupported options: \u2018dijkstra\u2019, \u2018bellman-ford\u2019.\nOther inputs produce a ValueError.\nIf ",(0,i.kt)("inlineCode",{parentName:"li"},"weight")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", unweighted graph methods are used\nand this suggestion is ignored.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"If the ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"target")," are both specified, return the length of\nthe shortest path from the ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," to the ",(0,i.kt)("inlineCode",{parentName:"p"},"target"),".\nIf only the ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," is specified, return a dict keyed by ",(0,i.kt)("inlineCode",{parentName:"p"},"target"),"\nto the shortest path length from the ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," to that ",(0,i.kt)("inlineCode",{parentName:"p"},"target"),".\nIf only the ",(0,i.kt)("inlineCode",{parentName:"p"},"target")," is specified, return a dict keyed by ",(0,i.kt)("inlineCode",{parentName:"p"},"source"),"\nto the shortest path length from that ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," to the ",(0,i.kt)("inlineCode",{parentName:"p"},"target"),".\nIf neither the ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," nor ",(0,i.kt)("inlineCode",{parentName:"p"},"target")," are specified, return an iterator\nover (source, dictionary) where dictionary is keyed by ",(0,i.kt)("inlineCode",{parentName:"p"},"target")," to\nshortest path length from ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," to that ",(0,i.kt)("inlineCode",{parentName:"p"},"target"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(source=mgp.Vertex, target=mgp.Vertex, length=mgp.Number)"),(0,i.kt)("h2",{id:"simple_cyclesctx"},(0,i.kt)("inlineCode",{parentName:"h2"},"simple_cycles(ctx)")),(0,i.kt)("p",null,"Find simple cycles (elementary circuits) of a directed graph."),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"simple cycle"),", or ",(0,i.kt)("em",{parentName:"p"},"elementary circuit"),", is a closed path where\nno node appears twice. Two elementary circuits are distinct if they\nare not cyclic permutations of each other."),(0,i.kt)("p",null,"This is a nonrecursive, iterator/generator version of Johnson\u2019s\nalgorithm. There may be better algorithms for some cases."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"A list of elementary cycles in the graph.\nEach cycle is represented by a list of nodes in the cycle."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(cycles=mgp.List[mgp.List","[mgp.Vertex]","])"),(0,i.kt)("h2",{id:"strongly_connected_componentsctx"},(0,i.kt)("inlineCode",{parentName:"h2"},"strongly_connected_components(ctx)")),(0,i.kt)("p",null,"Returns nodes in strongly connected components of a graph."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"A list of lists of nodes, one for each strongly connected\ncomponent of ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(components=mgp.List[mgp.List","[mgp.Vertex]","])"),(0,i.kt)("h2",{id:"topological_sortctx"},(0,i.kt)("inlineCode",{parentName:"h2"},"topological_sort(ctx)")),(0,i.kt)("p",null,"Returns nodes in topologically sorted order."),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"topological sort")," is a non unique permutation of the nodes such that an\nedge from ",(0,i.kt)("inlineCode",{parentName:"p"},"u")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," implies that ",(0,i.kt)("inlineCode",{parentName:"p"},"u")," appears before ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," in the\ntopological sort order."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"A list of nodes in topological sorted order."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(nodes=mgp.Nullable[mgp.List","[mgp.Vertex]","])"),(0,i.kt)("h2",{id:"triadic_censusctx"},(0,i.kt)("inlineCode",{parentName:"h2"},"triadic_census(ctx)")),(0,i.kt)("p",null,"Determines the triadic census of a directed graph."),(0,i.kt)("p",null,"The ",(0,i.kt)("em",{parentName:"p"},"triadic census")," is a count of how many of the 16 possible types of\ntriads are present in a directed graph."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"Dictionary with triad names as keys and number of occurrences as values."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(triad=str, count=int)"),(0,i.kt)("h2",{id:"voronoi_cellsctx-center_nodes-weight"},(0,i.kt)("inlineCode",{parentName:"h2"},"voronoi_cells(ctx, center_nodes, weight)")),(0,i.kt)("p",null,"Returns the Voronoi cells centered at center_nodes with respect\nto the shortest-path distance metric."),(0,i.kt)("p",null,"If ",(0,i.kt)("inlineCode",{parentName:"p"},"C")," is a set of nodes in the graph and ",(0,i.kt)("inlineCode",{parentName:"p"},"c")," is an element of ",(0,i.kt)("inlineCode",{parentName:"p"},"C"),",\nthe ",(0,i.kt)("em",{parentName:"p"},"Voronoi cell")," centered at a node ",(0,i.kt)("inlineCode",{parentName:"p"},"c")," is the set of all nodes\n",(0,i.kt)("inlineCode",{parentName:"p"},"v")," that are closer to ",(0,i.kt)("inlineCode",{parentName:"p"},"c")," than to any other center node in ",(0,i.kt)("inlineCode",{parentName:"p"},"C")," with\nrespect to the shortest-path distance metric."),(0,i.kt)("p",null,"For directed graphs, this will compute the \u201coutward\u201d Voronoi cells\nin which distance is measured from the center nodes to the target node."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"center_nodes")," (",(0,i.kt)("em",{parentName:"li"},"mgp.List","[mgp.Vertex]"),") \u2013 A nonempty set of nodes in the graph ",(0,i.kt)("inlineCode",{parentName:"li"},"G")," that represent the\ncenter of the Voronoi cells.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"weight")," (",(0,i.kt)("em",{parentName:"li"},"str"),") \u2013 (default=\u2019weight\u2019)\nThe edge attribute (or an arbitrary function) representing the\nweight of an edge. This keyword argument is as described in the\ndocumentation for ",(0,i.kt)("inlineCode",{parentName:"li"},"networkx.multi_source_dijkstra_path"),",\nfor example.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"A mapping from center node to set of all nodes in the graph\ncloser to that center node than to any other center node. The\nkeys of the dictionary are the element of ",(0,i.kt)("inlineCode",{parentName:"p"},"center_nodes"),", and\nthe values of the dictionary form a partition of the nodes of\n",(0,i.kt)("inlineCode",{parentName:"p"},"G"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(center=mgp.Vertex, cell=mgp.List","[mgp.Vertex]",")"),(0,i.kt)("h2",{id:"wiener_indexctx-weight"},(0,i.kt)("inlineCode",{parentName:"h2"},"wiener_index(ctx, weight)")),(0,i.kt)("p",null,"Returns the Wiener index of the given graph."),(0,i.kt)("p",null,"The ",(0,i.kt)("em",{parentName:"p"},"Wiener index")," of a graph is the sum of the shortest-path\ndistances between each pair of reachable nodes. For pairs of nodes\nin undirected graphs, only one orientation of the pair is counted."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ctx")," (",(0,i.kt)("em",{parentName:"li"},"mgp.ProcCtx"),") \u2013 The context of the procedure being executed.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"weight")," (",(0,i.kt)("em",{parentName:"li"},"mgp.Nullable","[str]"),") \u2013 (default=None)\nThe edge attribute to use as distance when computing\nshortest-path distances. This is passed directly to the\n",(0,i.kt)("inlineCode",{parentName:"li"},"networkx.shortest_path_length")," function.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",null,"The Wiener index of the graph ",(0,i.kt)("inlineCode",{parentName:"p"},"G"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",null,"mgp.Record(wiener_index=mgp.Number)"))}u.isMDXComponent=!0}}]);