"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[10248],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>c});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function m(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var i=r.createContext({}),l=function(e){var t=r.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=l(e.components);return r.createElement(i.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,p=m(e,["components","mdxType","originalType","parentName"]),d=l(n),c=a,g=d["".concat(i,".").concat(c)]||d[c]||u[c]||o;return n?r.createElement(g,s(s({ref:t},p),{},{components:n})):r.createElement(g,s({ref:t},p))}));function c(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=d;var m={};for(var i in t)hasOwnProperty.call(t,i)&&(m[i]=t[i]);m.originalType=e,m.mdxType="string"==typeof e?e:a,s[1]=m;for(var l=2;l<o;l++)s[l]=n[l];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},66581:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>m,toc:()=>l});var r=n(87462),a=(n(67294),n(3905));const o={id:"implement-transformation-module",title:"How to implement transformation modules",sidebar_label:"Implement transformation modules"},s=void 0,m={unversionedId:"how-to-guides/streams/kafka/implement-transformation-module",id:"version-2.3.0/how-to-guides/streams/kafka/implement-transformation-module",title:"How to implement transformation modules",description:"Related - Reference Guide",source:"@site/memgraph_versioned_docs/version-2.3.0/how-to-guides/streams/kafka/implement-transformation-module.md",sourceDirName:"how-to-guides/streams/kafka",slug:"/how-to-guides/streams/kafka/implement-transformation-module",permalink:"/docs/memgraph/2.3.0/how-to-guides/streams/kafka/implement-transformation-module",draft:!1,editUrl:"https://github.com/memgraph/docs/tree/master/memgraph_versioned_docs/version-2.3.0/how-to-guides/streams/kafka/implement-transformation-module.md",tags:[],version:"2.3.0",frontMatter:{id:"implement-transformation-module",title:"How to implement transformation modules",sidebar_label:"Implement transformation modules"},sidebar:"memgraph",previous:{title:"Manage Kafka streams",permalink:"/docs/memgraph/2.3.0/how-to-guides/streams/kafka/kafka-streams"},next:{title:"Manage Pulsar streams",permalink:"/docs/memgraph/2.3.0/how-to-guides/streams/pulsar/pulsar-streams"}},i={},l=[{value:"Using Docker with transformation modules",id:"using-docker-with-transformation-modules",level:2},{value:"Python API",id:"python-api",level:2},{value:"C API",id:"c-api",level:2}],p={toc:l};function u(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/memgraph/2.3.0/reference-guide/streams/transformation-modules"},(0,a.kt)("img",{parentName:"a",src:"https://img.shields.io/static/v1?label=Related&message=Reference%20Guide&color=yellow&style=for-the-badge",alt:"Related - Reference Guide"}))),(0,a.kt)("p",null,"The prerequisite of connecting Memgraph to a Kafka stream is to have a\ntransformation module that can produce Cypher queries based on the received\nmessages. We are going to implement a simple transformation that stores the\nproperties of each message in a vertex."),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"For detailed technical information on transformation modules, check out the ",(0,a.kt)("a",{parentName:"p",href:"/docs/memgraph/2.3.0/reference-guide/streams/transformation-modules"},"reference guide"),".")),(0,a.kt)("h2",{id:"using-docker-with-transformation-modules"},"Using Docker with transformation modules"),(0,a.kt)("p",null,"If you are using Docker to run Memgraph, you will have to create a volume\nand mount it to access the ",(0,a.kt)("inlineCode",{parentName:"p"},"query_modules")," directory. Yes, ",(0,a.kt)("inlineCode",{parentName:"p"},"query_modules"),",\nbecause Memgraph can load transformations and query procedures from the same\ndirectory, even from the same module. Mounting a volume can be done by\ncreating an empty directory ",(0,a.kt)("inlineCode",{parentName:"p"},"modules")," and executing the following command:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"docker volume create --driver local --opt type=none --opt device=modules --opt o=bind modules\n")),(0,a.kt)("p",null,"Now, you can start Memgraph and mount the created volume:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"docker run -it --rm -p 7687:7687 -p 7444:7444 -p 3000:3000 -v modules:/usr/lib/memgraph/query_modules memgraph/memgraph-platform\n")),(0,a.kt)("p",null,"Everything from the directory ",(0,a.kt)("inlineCode",{parentName:"p"},"/usr/lib/memgraph/query_modules")," will be\nvisible/editable in your mounted ",(0,a.kt)("inlineCode",{parentName:"p"},"modules")," volume and vice versa."),(0,a.kt)("p",null,"Through the rest of this page, ",(0,a.kt)("inlineCode",{parentName:"p"},"/usr/lib/memgraph/query_modules")," will be used to\nrefer to this directory. If you are using Docker, then please do the same but\nwith the recently created ",(0,a.kt)("inlineCode",{parentName:"p"},"modules")," directory."),(0,a.kt)("h2",{id:"python-api"},"Python API"),(0,a.kt)("p",null,"Transformations can be implemented using the Python API provided by Memgraph.\nIf you wish to write your own transformation using the Python API, you need to\nhave Python version 3.5.0 or above installed."),(0,a.kt)("p",null,"Let's create a file called ",(0,a.kt)("inlineCode",{parentName:"p"},"transformation.py")," in the\n",(0,a.kt)("inlineCode",{parentName:"p"},"/usr/lib/memgraph/query_modules")," directory. First and foremost, import the\n",(0,a.kt)("inlineCode",{parentName:"p"},"mgp")," module, which contains definitions of the public Python API provided\nby Memgraph."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"import mgp\n")),(0,a.kt)("p",null,"Next, we have to implement the function that does the transformation. For\ntransformations, the return type is fixed, while the parameters of the\ntransformation can vary. The whole signature of a transformation is the\nfollowing:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"import mgp\n\n@mgp.transformation\ndef my_transformation(context: mgp.TransCtx,\n                      messages: mgp.Messages\n                      ) -> mgp.Record(query=str, parameters=mgp.Nullable[mgp.Map]):\n    ...\n")),(0,a.kt)("p",null,"We also marked our function as a transformation so it will be recognized by\nMemgraph when the module is loaded. This was done by adding the\n",(0,a.kt)("inlineCode",{parentName:"p"},"@mgp.transformation")," decorator."),(0,a.kt)("p",null,"The transformations can slightly deviate from this by not receiving the\n",(0,a.kt)("inlineCode",{parentName:"p"},"context"),", just the ",(0,a.kt)("inlineCode",{parentName:"p"},"messages"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"import mgp\n\n@mgp.transformation\ndef my_transformation(messages: mgp.Messages\n                      ) -> mgp.Record(query=str, parameters=mgp.Nullable[mgp.Map]):\n    ...\n")),(0,a.kt)("p",null,"As this simple transformation won't access the vertices and edges in the\ndatabase, the ",(0,a.kt)("inlineCode",{parentName:"p"},"context")," parameter is not necessary, so we are going to use the\nsimpler version."),(0,a.kt)("p",null,"The most important part is the actual implementation of the transformation\nfunction. Before showing how it can be done, let's clarify what it is\nsupposed to do: it receives a list of messages and returns some queries and\ntheir parameters that will be executed in Memgraph as any regular query. Right,\nlet's see how we can do that!"),(0,a.kt)("p",null,"We have to iterate over the messages and construct a query for each of them:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"import mgp\n\n@mgp.transformation\ndef my_transformation(messages: mgp.Messages\n                      ) -> mgp.Record(query=str, parameters=mgp.Nullable[mgp.Map]):\n    result_queries = []\n\n    for i in range(messages.total_messages()):\n        message = messages.message_at(i)\n        payload_as_str = message.payload().decode(\"utf-8\")\n        result_queries.append(mgp.Record(\n            query=\"CREATE (n:MESSAGE {{timestamp: '{timestamp}', payload: '{payload}', topic: '{topic}'}})\".format(\n                timestamp=message.timestamp(), payload=payload_as_str, topic=message.topic_name()),\n            parameters=None))\n\n    return result_queries\n")),(0,a.kt)("p",null,"As you can see, the query is almost the same for every message, except the\nthree properties of the messages. This is exactly the case when the\n",(0,a.kt)("inlineCode",{parentName:"p"},"parameters")," field of the result is handy. Instead of formatting the string\nwith the properties, we can pass the properties as query parameters:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'import mgp\n\n@mgp.transformation\ndef my_transformation(messages: mgp.Messages\n                      ) -> mgp.Record(query=str, parameters=mgp.Nullable[mgp.Map]):\n    result_queries = []\n\n    for i in range(messages.total_messages()):\n        message = messages.message_at(i)\n        payload_as_str = message.payload().decode("utf-8")\n        result_queries.append(mgp.Record(\n            query="CREATE (n:MESSAGE {timestamp: $timestamp, payload: $payload, topic: $topic})",\n            parameters={"timestamp": message.timestamp(),\n                        "payload": payload_as_str,\n                        "topic": message.topic_name()}))\n\n    return result_queries\n')),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"$timestamp"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"$payload")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"$topic")," are the placeholders for parameters\nwith the same name."),(0,a.kt)("p",null,"Congratulations, you just created your first transformation procedure! To\nensure that Memgraph can find the transformation, let's reload the modules:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL mg.load_all();\n")),(0,a.kt)("p",null,"And list all the available transformations:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL mg.transformations() YIELD *;\n")),(0,a.kt)("p",null,"You should see something like the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-plaintext"},'+-------------------------------------------+-----------------------------------------------------+-------------+\n| name                                      | path                                                | is_editable |\n+-------------------------------------------+-----------------------------------------------------+-------------+\n| "transformation.my_transformation"        | "/usr/lib/memgraph/query_modules/transformation.py" | true        |\n+-------------------------------------------+-----------------------------------------------------+-------------+\n')),(0,a.kt)("h2",{id:"c-api"},"C API"),(0,a.kt)("p",null,"Transformations can also be implemented in C/C++ using the C API provided by\nMemgraph. Such modules need to be compiled to a shared library so that they can\nbe loaded when Memgraph starts. This means that you can write the\ntransformations in any programming language which can work with C and can be\ncompiled to the ELF shared library format."),(0,a.kt)("p",null,"In this chapter, we assume that Memgraph is installed on a standard Debian or\nUbuntu machine where the necessary header file can be found under\n",(0,a.kt)("inlineCode",{parentName:"p"},"/usr/include/memgraph"),". For other installations, the header file can be found\nunder the ",(0,a.kt)("inlineCode",{parentName:"p"},"include/memgraph")," folder in the Memgraph installation directory."),(0,a.kt)("p",null,"As we already discussed how transformations work in the Python example, we\nwon't go over the transformation itself in detail. Also, to keep the\ncomplexity of this example low, this transformation doesn't use the query\nparameters. Apart from that, this transformation does the same as the Python\nexample, but written in C++17."),(0,a.kt)("p",null,"So let's create ",(0,a.kt)("inlineCode",{parentName:"p"},"c_transformation.cpp")," and start to populate it!"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <exception>\n#include <string>\n\n#include "mg_procedure.h"\n\nconst std::string query_part_1{"CREATE (n:MESSAGE {timestamp: \'"};\nconst std::string query_part_2{"\', payload: \'"};\nconst std::string query_part_3{"\', topic: \'"};\nconst std::string query_part_4{"\'})"};\n\nstd::string create_query(mgp_message &message, struct mgp_result *result) {\n  int64_t timestamp{0};\n  if (mgp_error::MGP_ERROR_NO_ERROR !=\n      mgp_message_timestamp(&message, &timestamp)) {\n    throw "Internal error!";\n  }\n\n  const char *payload{nullptr};\n  if (mgp_error::MGP_ERROR_NO_ERROR !=\n      mgp_message_payload(&message, &payload)) {\n    throw "Internal error!";\n  }\n\n  size_t payload_size{0};\n  if (mgp_error::MGP_ERROR_NO_ERROR !=\n      mgp_message_payload_size(&message, &payload_size)) {\n    throw "Internal error!";\n  }\n\n  const char *topic_name{nullptr};\n  if (mgp_error::MGP_ERROR_NO_ERROR !=\n      mgp_message_topic_name(&message, &topic_name)) {\n    throw "Internal error!";\n  }\n\n  return query_part_1 + std::to_string(timestamp) + query_part_2 +\n         std::string{payload, payload_size} + query_part_3 + topic_name +\n         query_part_4;\n}\n\nvoid my_c_transformation(struct mgp_messages *messages, mgp_graph *,\n                         mgp_result *result, mgp_memory *memory) {\n\n  mgp_value *null_value{nullptr};\n\n  try {\n    size_t messages_size{0};\n    if (mgp_error::MGP_ERROR_NO_ERROR !=\n        mgp_messages_size(messages, &messages_size)) {\n      return;\n    }\n\n    if (mgp_error::MGP_ERROR_NO_ERROR !=\n        mgp_value_make_null(memory, &null_value)) {\n      return;\n    }\n\n    for (auto i = 0; i < messages_size; ++i) {\n\n      mgp_message *message{nullptr};\n      if (mgp_error::MGP_ERROR_NO_ERROR !=\n          mgp_messages_at(messages, i, &message)) {\n        break;\n      }\n\n      const auto query = create_query(*message, result);\n\n      mgp_result_record *record{nullptr};\n      if (mgp_error::MGP_ERROR_NO_ERROR !=\n          mgp_result_new_record(result, &record)) {\n        break;\n      }\n\n      mgp_value *query_value{nullptr};\n      if (mgp_error::MGP_ERROR_NO_ERROR !=\n          mgp_value_make_string(query.c_str(), memory, &query_value)) {\n        break;\n      }\n\n      auto mgp_result = mgp_result_record_insert(record, "query", query_value);\n      mgp_value_destroy(query_value);\n\n      if (mgp_error::MGP_ERROR_NO_ERROR != mgp_result) {\n        static_cast<void>(\n            mgp_result_set_error_msg(result, "Couldn\'t insert field"));\n        break;\n      }\n\n      mgp_result = mgp_result_record_insert(record, "parameters", null_value);\n      if (mgp_error::MGP_ERROR_NO_ERROR != mgp_result) {\n        static_cast<void>(\n            mgp_result_set_error_msg(result, "Couldn\'t insert field"));\n        break;\n      }\n    }\n    mgp_value_destroy(null_value);\n  } catch (const std::exception &e) {\n    mgp_value_destroy(null_value);\n    static_cast<void>(mgp_result_set_error_msg(result, e.what()));\n    return;\n  }\n}\n')),(0,a.kt)("p",null,"Now we have to register the transformation in the ",(0,a.kt)("inlineCode",{parentName:"p"},"mgp_init_module")," function:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'extern "C" int mgp_init_module(mgp_module *module, mgp_memory *memory) {\n\n  return mgp_error::MGP_ERROR_NO_ERROR !=\n         mgp_module_add_transformation(module, "my_c_transformation",\n                                       my_c_transformation);\n}\n')),(0,a.kt)("p",null,"Now let's compile it:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"clang++ --std=c++17 -Wall -shared -fPIC -I /usr/include/memgraph c_transformation.cpp -o c_transformation.so\n")),(0,a.kt)("p",null,"After copying the resulting ",(0,a.kt)("inlineCode",{parentName:"p"},"c_transformation.so")," to the\n",(0,a.kt)("inlineCode",{parentName:"p"},"/usr/lib/memgraph/query_modules")," directory, we can reload the modules and check\nif Memgraph found our newly created transformation:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL mg.load_all();\n")),(0,a.kt)("p",null,"Then the transformation should show up in the list of transformations:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL mg.transformations() YIELD *;\n")),(0,a.kt)("p",null,"You should see something like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-plaintext"},'+-------------------------------------------+-------------------------------------------------------+-------------+\n| name                                      | path                                                  | is_editable |\n+-------------------------------------------+-------------------------------------------------------+-------------+\n| "c_transformation.my_c_transformation"    | "/usr/lib/memgraph/query_modules/c_transformation.so" | false       |\n| "transformation.my_transformation"        | "/usr/lib/memgraph/query_modules/transformation.py"   | true        |\n+-------------------------------------------+-------------------------------------------------------+-------------+\n')),(0,a.kt)("p",null,"For a more detailed overview, check out the ",(0,a.kt)("a",{parentName:"p",href:"/docs/memgraph/2.3.0/reference-guide/streams/transformation-modules"},"Reference\nguide"),"."))}u.isMDXComponent=!0}}]);