"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[21311],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return d}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var m=a.createContext({}),l=function(e){var t=a.useContext(m),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=l(e.components);return a.createElement(m.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,m=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),u=l(n),d=r,h=u["".concat(m,".").concat(d)]||u[d]||p[d]||s;return n?a.createElement(h,i(i({ref:t},c),{},{components:n})):a.createElement(h,i({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,i=new Array(s);i[0]=u;var o={};for(var m in t)hasOwnProperty.call(t,m)&&(o[m]=t[m]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var l=2;l<s;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},74675:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return m},metadata:function(){return l},toc:function(){return c},default:function(){return u}});var a=n(87462),r=n(63366),s=(n(67294),n(3905)),i=["components"],o={id:"overview",title:"Streams",sidebar_label:"Overview",slug:"/reference-guide/streams"},m=void 0,l={unversionedId:"reference-guide/streams/overview",id:"version-1.6.0/reference-guide/streams/overview",isDocsHomePage:!1,title:"Streams",description:"Memgraph can connect to existing Kafka streams. To use streams, a user",source:"@site/memgraph_versioned_docs/version-1.6.0/reference-guide/streams/overview.md",sourceDirName:"reference-guide/streams",slug:"/reference-guide/streams",permalink:"/memgraph/1.6.0/reference-guide/streams",editUrl:"https://github.com/memgraph/docs/tree/master/memgraph_versioned_docs/version-1.6.0/reference-guide/streams/overview.md",version:"1.6.0",frontMatter:{id:"overview",title:"Streams",sidebar_label:"Overview",slug:"/reference-guide/streams"},sidebar:"version-1.6.0/memgraph",previous:{title:"Replication",permalink:"/memgraph/1.6.0/reference-guide/replication"},next:{title:"Overview",permalink:"/memgraph/1.6.0/reference-guide/streams/transformation-modules"}},c=[{value:"Creating a stream",id:"creating-a-stream",children:[]},{value:"Deleting a stream",id:"deleting-a-stream",children:[]},{value:"Start a stream",id:"start-a-stream",children:[{value:"At least once semantics",id:"at-least-once-semantics",children:[]}]},{value:"Stop a stream",id:"stop-a-stream",children:[]},{value:"Show",id:"show",children:[]},{value:"Check stream",id:"check-stream",children:[]}],p={toc:c};function u(e){var t=e.components,n=(0,r.Z)(e,i);return(0,s.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Memgraph can connect to existing Kafka streams. To use streams, a user\nmust"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Manage a stream via a query"),(0,s.kt)("li",{parentName:"ul"},"Provide a user-defined transformation module")),(0,s.kt)("p",null,"More information about transformation modules can be found\n",(0,s.kt)("strong",{parentName:"p"},(0,s.kt)("a",{parentName:"strong",href:"/memgraph/1.6.0/reference-guide/streams/transformation-modules"},"here")),".\nThe rest of this section describes how to manage streams with Memgraph."),(0,s.kt)("h2",{id:"creating-a-stream"},"Creating a stream"),(0,s.kt)("p",null,"The general syntax for creating a stream is:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cypher"},"CREATE STREAM <stream name>\n  TOPICS <topic1> [, <topic2>, ...]\n  TRANSFORM <transform procedure>\n  [CONSUMER_GROUP <consumer group name>]\n  [BATCH_INTERVAL <milliseconds>]\n  [BATCH_SIZE <size>];\n")),(0,s.kt)("p",null,"Create a ",(0,s.kt)("inlineCode",{parentName:"p"},"STREAM")," with name ",(0,s.kt)("inlineCode",{parentName:"p"},"<stream name>")," that consumes messages from\n",(0,s.kt)("inlineCode",{parentName:"p"},"TOPICS")," with name ",(0,s.kt)("inlineCode",{parentName:"p"},"<topic1>")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"<topic2>"),". ",(0,s.kt)("inlineCode",{parentName:"p"},"TRANSFORM")," denotes the user-defined\ntransformation with name ",(0,s.kt)("inlineCode",{parentName:"p"},"<transform procedure>"),"."),(0,s.kt)("p",null,"Additionally, the user can provide the following optional parameters:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"CONSUMER_GROUP")," with name ",(0,s.kt)("inlineCode",{parentName:"li"},"<consumer group name>"),". If not specified, then\n",(0,s.kt)("inlineCode",{parentName:"li"},"mg_consumer")," will be used as a consumer group name."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"BATCH_INTERVAL")," denotes the maximum wait time interval for consuming message(s)\nbefore calling the transformation procedure with the already received message(s).\nThis value must be greater than zero and is defaulted to 100."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"BATCH_SIZE")," denotes the total number of messages to wait before calling\nthe transformation procedure with the already received message(s).\nIt must be greater than zero and is defaulted to 1000.")),(0,s.kt)("p",null,"The transformation procedure is called if either the ",(0,s.kt)("inlineCode",{parentName:"p"},"BATCH_INTERVAL")," or the\n",(0,s.kt)("inlineCode",{parentName:"p"},"BATCH_SIZE")," is reached and there is at least one received message.\nThe ",(0,s.kt)("inlineCode",{parentName:"p"},"BATCH_INTERVAL")," starts when the:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"the stream is started"),(0,s.kt)("li",{parentName:"ul"},"the processing of the previous batch is completed"),(0,s.kt)("li",{parentName:"ul"},"the previous batch interval ended without receiving any messages")),(0,s.kt)("h2",{id:"deleting-a-stream"},"Deleting a stream"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cypher"},"DROP STREAM <stream name>;\n")),(0,s.kt)("p",null,"Drops a stream with name ",(0,s.kt)("inlineCode",{parentName:"p"},"<stream name>"),"."),(0,s.kt)("h2",{id:"start-a-stream"},"Start a stream"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cypher"},"START STREAM <stream name>;\nSTART ALL STREAMS;\n")),(0,s.kt)("p",null,"Starts a stream (or all streams) with name ",(0,s.kt)("inlineCode",{parentName:"p"},"<stream name>"),"."),(0,s.kt)("p",null,"When a stream is started, it should resume from the last committed offset. If\nthere is no committed offset for the consumer group, then the largest offset\nwill be used, therefore only the new messages will be consumed."),(0,s.kt)("h3",{id:"at-least-once-semantics"},"At least once semantics"),(0,s.kt)("p",null,"In stream processing, it is important to have some guarantees about how failures\nare handled. When connecting an external application such as Memgraph to a\nKafka stream, there are two possible ways to handle failures during message\nprocessing:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"Every message is processed ",(0,s.kt)("strong",{parentName:"li"},"at least once"),": the message offsets are\ncommitted to the Kafka cluster after the processing is done. This means if the\ncommitting fails, then the messages can get processed multiple times."),(0,s.kt)("li",{parentName:"ol"},"Every message is processed ",(0,s.kt)("strong",{parentName:"li"},"at most once"),": the message offsets are\ncommitted to the Kafka cluster right after they are received before the\nprocessing is started. This means if the processing fails, then the same\nmessages won't be processed again.")),(0,s.kt)("p",null,"Missing a message can result in missing an edge that would connect two\nindependent components of the graph. Therefore, we think that missing\nsome information is a bigger problem for graphs than having some information\nduplicated, so we implemented our streams using the ",(0,s.kt)("strong",{parentName:"p"},"at least once"),"\nsemantics, i.e. for every batch of messages the queries returned by the\ntransformations are executed and committed to the database before committing\nthe message offset to the Kafka cluster. However, even though we cannot guarantee ",(0,s.kt)("strong",{parentName:"p"},"exactly\nonce")," semantics, we tried to minimize the possibility of processing messages\nmultiple times. This means committing the message offsets to the Kafka cluster\nhappens right after the transaction is committed to the database."),(0,s.kt)("h2",{id:"stop-a-stream"},"Stop a stream"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cypher"},"STOP STREAM <stream name>;\nSTOP ALL STREAMS;\n")),(0,s.kt)("p",null,"Stops a stream (or all streams) with name ",(0,s.kt)("inlineCode",{parentName:"p"},"<stream name>"),"."),(0,s.kt)("h2",{id:"show"},"Show"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cypher"},"SHOW STREAMS;\n")),(0,s.kt)("p",null,"Shows a list of existing streams with the following information:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"stream name"),(0,s.kt)("li",{parentName:"ul"},"list of topics"),(0,s.kt)("li",{parentName:"ul"},"consumer group id"),(0,s.kt)("li",{parentName:"ul"},"batch interval"),(0,s.kt)("li",{parentName:"ul"},"batch size"),(0,s.kt)("li",{parentName:"ul"},"transformation procedure name"),(0,s.kt)("li",{parentName:"ul"},"whether the stream is running")),(0,s.kt)("h2",{id:"check-stream"},"Check stream"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cypher"},"CHECK STREAM <stream name> [BATCH_LIMIT <count>] [TIMEOUT <milliseconds>] ;\n")),(0,s.kt)("p",null,"Does a dry-run on stream with name ",(0,s.kt)("inlineCode",{parentName:"p"},"<stream name>")," with ",(0,s.kt)("inlineCode",{parentName:"p"},"<count>")," number of\nbatches and returns the result of the transformation: the queries and their\nparameters that would be executed in a normal run.\nIf ",(0,s.kt)("inlineCode",{parentName:"p"},"<count>")," is unspecified, its default value is 1.\nAfter ",(0,s.kt)("inlineCode",{parentName:"p"},"<count>")," batches are processed, the transformation result is returned.\nIf ",(0,s.kt)("inlineCode",{parentName:"p"},"<count>")," number of batches are not processed within the specified timeout,\nthen an exception is thrown. This might be caused by not receiving enough\nmessages.\n",(0,s.kt)("inlineCode",{parentName:"p"},"TIMEOUT")," is measured in milliseconds, and it's defaulted to 30000."),(0,s.kt)("p",null,"Checking a stream won't commit any offsets."))}u.isMDXComponent=!0}}]);