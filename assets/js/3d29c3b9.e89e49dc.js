"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[44334],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),c=u(n),m=r,h=c["".concat(s,".").concat(m)]||c[m]||p[m]||l;return n?a.createElement(h,i(i({ref:t},d),{},{components:n})):a.createElement(h,i({ref:t},d))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var u=2;u<l;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},40987:(e,t,n)=>{n.r(t),n.d(t,{Highlight:()=>m,assets:()=>p,contentTitle:()=>u,default:()=>g,frontMatter:()=>s,metadata:()=>d,toc:()=>c});var a=n(87462),r=(n(67294),n(3905)),l=n(74866),i=n(85162),o=n(83523);const s={id:"betweenness-centrality-online",title:"betweenness_centrality_online",sidebar_label:"betweenness_centrality_online"},u=void 0,d={unversionedId:"query-modules/cpp/betweenness-centrality-online",id:"query-modules/cpp/betweenness-centrality-online",title:"betweenness_centrality_online",description:"Betweenness centrality is among the most common metrics in graph analytics owing",source:"@site/mage/query-modules/cpp/betweenness_centrality_online.md",sourceDirName:"query-modules/cpp",slug:"/query-modules/cpp/betweenness-centrality-online",permalink:"/docs/mage/query-modules/cpp/betweenness-centrality-online",draft:!1,editUrl:"https://github.com/memgraph/docs/tree/master/mage/query-modules/cpp/betweenness_centrality_online.md",tags:[],version:"current",frontMatter:{id:"betweenness-centrality-online",title:"betweenness_centrality_online",sidebar_label:"betweenness_centrality_online"},sidebar:"mage",previous:{title:"betweenness_centrality",permalink:"/docs/mage/query-modules/cpp/betweenness-centrality"},next:{title:"biconnected_components",permalink:"/docs/mage/query-modules/cpp/biconnected-components"}},p={},c=[{value:"Procedures",id:"procedures",level:2},{value:"<code>set(normalize, threads)</code>",id:"setnormalize-threads",level:3},{value:"Input:",id:"input",level:4},{value:"Output:",id:"output",level:4},{value:"Usage:",id:"usage",level:4},{value:"<code>get(normalize)</code>",id:"getnormalize",level:3},{value:"Input:",id:"input-1",level:4},{value:"Output:",id:"output-1",level:4},{value:"Usage:",id:"usage-1",level:4},{value:"<code>update(created_vertices, created_edges, deleted_vertices, deleted_edges, normalize, threads)</code>",id:"updatecreated_vertices-created_edges-deleted_vertices-deleted_edges-normalize-threads",level:3},{value:"Output:",id:"output-2",level:4},{value:"Usage:",id:"usage-2",level:4},{value:"Example",id:"example",level:2}],m=e=>{let{children:t,color:n}=e;return(0,r.kt)("span",{style:{backgroundColor:n,borderRadius:"2px",color:"#fff",padding:"0.2rem"}},t)},h={toc:c,Highlight:m};function g(e){let{components:t,...s}=e;return(0,r.kt)("wrapper",(0,a.Z)({},h,s,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Betweenness centrality is among the most common metrics in graph analytics owing\nto its utility in identifying critical vertices of graphs. It is one of the\ntools in ",(0,r.kt)("em",{parentName:"p"},"centrality analysis"),", a set of techniques for measuring the importance\nof nodes in networks."),(0,r.kt)("p",null,"The notion of ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Betweenness_centrality"},"Betweenness\ncentrality")," is based on\nshortest paths: the shortest path between two nodes is the one consisting of the\nfewest edges, or in case of weighted graphs, the one with the smallest total\nedge weight. A node\u2019s betweenness centrality is defined as the share of all\nshortest paths in the graph that run through it."),(0,r.kt)("p",null,"This query module delivers a ",(0,r.kt)("em",{parentName:"p"},"fully dynamic")," betweenness centrality computation\ntool using the\n",(0,r.kt)("a",{parentName:"p",href:"https://repository.kaust.edu.sa/bitstream/handle/10754/625935/08070346.pdf"},"iCentral"),"\n",(0,r.kt)("sup",{parentName:"p",id:"fnref-1"},(0,r.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1"))," algorithm by Jamour, Skiadopoulos and Kalnis. iCentral saves up on\ncomputation in two ways: it singles out the nodes whose centrality scores could\nhave changed and then incrementally updates their scores, making use of\npreviously calculated data structures where applicable."),(0,r.kt)("p",null,"This drives down the algorithm\u2019s time complexity to ",(0,r.kt)("em",{parentName:"p"},"O"),"(",(0,r.kt)("em",{parentName:"p"},"m\u2032n\u2032"),") and space\ncomplexity to ",(0,r.kt)("em",{parentName:"p"},"O"),"(",(0,r.kt)("em",{parentName:"p"},"m")," + ",(0,r.kt)("em",{parentName:"p"},"n"),"), where ",(0,r.kt)("em",{parentName:"p"},"m")," and ",(0,r.kt)("em",{parentName:"p"},"n")," are the counts of edges and\nvertices in the graph, ",(0,r.kt)("em",{parentName:"p"},"m\u2032")," is the number of edges in the biconnected component\naffected by the graph update, and ",(0,r.kt)("em",{parentName:"p"},"n\u2032")," is the size of a subset of the nodes in\nthe biconnected component. Consequently, the algorithm is suitable for mid-scale\ngraphs."),(0,r.kt)("p",null,"Dynamic algorithms such as iCentral are especially suited for graph streaming\nsolutions such as Memgraph. As updates arrive in a stream, the algorithm avoids\nredundant work by processing only the portion of the graph affected by the\nupdate."),(0,r.kt)("p",null,(0,r.kt)("sup",{parentName:"p",id:"fnref-1"},(0,r.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1"))," ",(0,r.kt)("a",{parentName:"p",href:"https://repository.kaust.edu.sa/bitstream/handle/10754/625935/08070346.pdf"},"Parallel Algorithm for Incremental Betweenness Centrality on Large\nGraphs"),"\n(Jamour et al., 2017)"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/memgraph/mage/blob/main/cpp/betweenness_centrality_module/betweenness_centrality_online_module.cpp"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/badge/source-betweenness_centrality_online-FB6E00?logo=github&style=for-the-badge",alt:"docs-source"}))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Trait"),(0,r.kt)("th",{parentName:"tr",align:null},"Value"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Module type")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)(m,{color:"#FB6E00",mdxType:"Highlight"},(0,r.kt)("strong",{parentName:"td"},"algorithm")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Implementation")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)(m,{color:"#FB6E00",mdxType:"Highlight"},(0,r.kt)("strong",{parentName:"td"},"C++")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Graph direction")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)(m,{color:"#FB6E00",mdxType:"Highlight"},(0,r.kt)("strong",{parentName:"td"},"undirected")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Edge weights")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)(m,{color:"#FB6E00",mdxType:"Highlight"},(0,r.kt)("strong",{parentName:"td"},"unweighted")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Parallelism")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)(m,{color:"#FB6E00",mdxType:"Highlight"},(0,r.kt)("strong",{parentName:"td"},"parallel")))))),(0,r.kt)("h2",{id:"procedures"},"Procedures"),(0,r.kt)(o.ZP,{mdxType:"RunOnSubgraph"}),(0,r.kt)("h3",{id:"setnormalize-threads"},(0,r.kt)("inlineCode",{parentName:"h3"},"set(normalize, threads)")),(0,r.kt)("h4",{id:"input"},"Input:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"normalize: boolean (default=True)")," \u27a1 If ",(0,r.kt)("inlineCode",{parentName:"li"},"True"),", the betweenness values are normalized by\n",(0,r.kt)("inlineCode",{parentName:"li"},"2/((n-1)(n-2))"),", where ",(0,r.kt)("inlineCode",{parentName:"li"},"n")," is the number of nodes in the graph."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"threads: integer (default=N\xba of concurrent threads supported by the implementation)")," \u27a1 The\nnumber of threads used in calculating betweenness centrality.")),(0,r.kt)("h4",{id:"output"},"Output:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"node: Vertex")," \u27a1 Graph vertex."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"betweenness_centrality: float")," \u27a1 Betweenness centrality score of the above\nvertex.")),(0,r.kt)("h4",{id:"usage"},"Usage:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL betweenness_centrality_online.set()\nYIELD node, betweenness_centrality;\n")),(0,r.kt)("h3",{id:"getnormalize"},(0,r.kt)("inlineCode",{parentName:"h3"},"get(normalize)")),(0,r.kt)("h4",{id:"input-1"},"Input:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"normalize: boolean (default=True)")," \u27a1 If ",(0,r.kt)("inlineCode",{parentName:"li"},"True"),", the betweenness values are normalized by\n",(0,r.kt)("inlineCode",{parentName:"li"},"2/((n-1)(n-2))"),", where ",(0,r.kt)("inlineCode",{parentName:"li"},"n")," is the number of nodes in the graph.")),(0,r.kt)("h4",{id:"output-1"},"Output:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"node: Vertex")," \u27a1 Graph vertex."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"betweenness_centrality: float")," \u27a1 Betweenness centrality score of the above\nvertex.")),(0,r.kt)("h4",{id:"usage-1"},"Usage:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL betweenness_centrality_online.get()\nYIELD node, betweenness_centrality;\n")),(0,r.kt)("h3",{id:"updatecreated_vertices-created_edges-deleted_vertices-deleted_edges-normalize-threads"},(0,r.kt)("inlineCode",{parentName:"h3"},"update(created_vertices, created_edges, deleted_vertices, deleted_edges, normalize, threads)")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"created_vertices: List[Vertex]")," \u27a1 Vertices created in the latest graph\nupdate."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"created_edges: List[Edge]")," \u27a1 Edges created in the latest graph update."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"updated_vertices: List[Vertex]")," \u27a1 Vertices updated in the latest graph\nupdate."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"updated_edges: List[Edge]")," \u27a1 Edges updated in the latest graph update."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"deleted_vertices: List[Vertex]")," \u27a1 Vertices deleted in the latest graph\nupdate."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"deleted_edges: List[Edge]")," \u27a1 Edges deleted in the latest graph update."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"normalize: boolean (default=True)")," \u27a1 If ",(0,r.kt)("inlineCode",{parentName:"li"},"True"),", the betweenness values are normalized by\n",(0,r.kt)("inlineCode",{parentName:"li"},"2/((n-1)(n-2))"),", where ",(0,r.kt)("inlineCode",{parentName:"li"},"n")," is the number of nodes in the graph."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"threads: integer (default=N\xba of concurrent threads supported by the implementation)")," \u27a1 The\nnumber of threads used in updating betweenness centrality.")),(0,r.kt)("h4",{id:"output-2"},"Output:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"node: Vertex")," \u27a1 Graph vertex."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"betweenness_centrality: float")," \u27a1 Betweenness centrality score of the above\nvertex.")),(0,r.kt)("h4",{id:"usage-2"},"Usage:"),(0,r.kt)("p",null,"As there is a total of four complex obligatory parameters, setting the\nparameters by hand might be cumbersome. The recommended use of this method is to\ncall it within a ",(0,r.kt)("a",{parentName:"p",href:"/memgraph/reference-guide/triggers"},"trigger"),", making sure\nbeforehand that all ",(0,r.kt)("a",{parentName:"p",href:"/memgraph/reference-guide/triggers/#predefined-variables"},"predefined\nvariables")," are\navailable:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"CREATE TRIGGER sample_trigger BEFORE COMMIT\nEXECUTE CALL betweenness_centrality_online.update(createdVertices, createdEdges, deletedVertices, deletedEdges, normalize, threads) YIELD *;\n")),(0,r.kt)("p",null,"Communities calculated by ",(0,r.kt)("inlineCode",{parentName:"p"},"update()")," are accessible by subsequently calling\n",(0,r.kt)("inlineCode",{parentName:"p"},"get()"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL betweenness_centrality_online.get()\nYIELD node, betweenness_centrality;\n")),(0,r.kt)("h2",{id:"example"},"Example"),(0,r.kt)(l.Z,{groupId:"example",defaultValue:"visualization",values:[{label:"Step 1: Input graph",value:"visualization"},{label:"Step 2: Set trigger",value:"cypher-trigger"},{label:"Step 3: Cypher load commands",value:"cypher-load"},{label:"Step 4: Running command",value:"run"},{label:"Step 5: Results",value:"result"}],mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"visualization",mdxType:"TabItem"},(0,r.kt)("img",{src:n(18931).Z})),(0,r.kt)(i.Z,{value:"cypher-trigger",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"CREATE TRIGGER update_bc_trigger\nBEFORE COMMIT EXECUTE\n  CALL betweenness_centrality_online.update(createdVertices, createdEdges, deletedVertices, deletedEdges)\n  YIELD *;\n"))),(0,r.kt)(i.Z,{value:"cypher-load",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"MERGE (a: Node {id: 0}) MERGE (b: Node {id: 1}) CREATE (a)-[:RELATION]->(b);\nMERGE (a: Node {id: 0}) MERGE (b: Node {id: 2}) CREATE (a)-[:RELATION]->(b);\nMERGE (a: Node {id: 1}) MERGE (b: Node {id: 2}) CREATE (a)-[:RELATION]->(b);\nMERGE (a: Node {id: 2}) MERGE (b: Node {id: 3}) CREATE (a)-[:RELATION]->(b);\nMERGE (a: Node {id: 3}) MERGE (b: Node {id: 4}) CREATE (a)-[:RELATION]->(b);\nMERGE (a: Node {id: 3}) MERGE (b: Node {id: 5}) CREATE (a)-[:RELATION]->(b);\nMERGE (a: Node {id: 4}) MERGE (b: Node {id: 5}) CREATE (a)-[:RELATION]->(b);\n"))),(0,r.kt)(i.Z,{value:"run",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL betweenness_centrality_online.get(True)\nYIELD node, betweenness_centrality\nRETURN node.id AS node_id, betweenness_centrality\nORDER BY node_id;\n"))),(0,r.kt)(i.Z,{value:"result",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-plaintext"},"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 node_id                 \u2502 betweenness_centrality  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 0                       \u2502 0                       \u2502\n\u2502 1                       \u2502 0                       \u2502\n\u2502 2                       \u2502 0.6                     \u2502\n\u2502 3                       \u2502 0.6                     \u2502\n\u2502 4                       \u2502 0                       \u2502\n\u2502 5                       \u2502 0                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")))))}g.isMDXComponent=!0},83523:(e,t,n)=>{n.d(t,{ZP:()=>i});var a=n(87462),r=(n(67294),n(3905));const l={toc:[]};function i(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"If you want to execute this algorithm on graph projections, subgraphs or portions\nof the graph, be sure to check out the guide on\n",(0,r.kt)("a",{parentName:"p",href:"/mage/how-to-guides/run-a-subgraph-module"},"How to run a MAGE module on subgraphs"),".")))}i.isMDXComponent=!0},85162:(e,t,n)=>{n.d(t,{Z:()=>i});var a=n(67294),r=n(86010);const l="tabItem_Ymn6";function i(e){let{children:t,hidden:n,className:i}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(l,i),hidden:n},t)}},74866:(e,t,n)=>{n.d(t,{Z:()=>E});var a=n(87462),r=n(67294),l=n(86010),i=n(12466),o=n(16550),s=n(91980),u=n(67392),d=n(50012);function p(e){return function(e){return r.Children.map(e,(e=>{if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:r}}=e;return{value:t,label:n,attributes:a,default:r}}))}function c(e){const{values:t,children:n}=e;return(0,r.useMemo)((()=>{const e=t??p(n);return function(e){const t=(0,u.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function m(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function h(e){let{queryString:t=!1,groupId:n}=e;const a=(0,o.k6)(),l=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,s._X)(l),(0,r.useCallback)((e=>{if(!l)return;const t=new URLSearchParams(a.location.search);t.set(l,e),a.replace({...a.location,search:t.toString()})}),[l,a])]}function g(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,l=c(e),[i,o]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:l}))),[s,u]=h({queryString:n,groupId:a}),[p,g]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,l]=(0,d.Nk)(n);return[a,(0,r.useCallback)((e=>{n&&l.set(e)}),[n,l])]}({groupId:a}),b=(()=>{const e=s??p;return m({value:e,tabValues:l})?e:null})();(0,r.useEffect)((()=>{b&&o(b)}),[b]);return{selectedValue:i,selectValue:(0,r.useCallback)((e=>{if(!m({value:e,tabValues:l}))throw new Error(`Can't select invalid tab value=${e}`);o(e),u(e),g(e)}),[u,g,l]),tabValues:l}}var b=n(72389);const k="tabList__CuJ",f="tabItem_LNqP";function y(e){let{className:t,block:n,selectedValue:o,selectValue:s,tabValues:u}=e;const d=[],{blockElementScrollPositionUntilNextRender:p}=(0,i.o5)(),c=e=>{const t=e.currentTarget,n=d.indexOf(t),a=u[n].value;a!==o&&(p(t),s(a))},m=e=>{var t;let n=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const t=d.indexOf(e.currentTarget)+1;n=d[t]??d[0];break}case"ArrowLeft":{const t=d.indexOf(e.currentTarget)-1;n=d[t]??d[d.length-1];break}}null==(t=n)||t.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.Z)("tabs",{"tabs--block":n},t)},u.map((e=>{let{value:t,label:n,attributes:i}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:o===t?0:-1,"aria-selected":o===t,key:t,ref:e=>d.push(e),onKeyDown:m,onClick:c},i,{className:(0,l.Z)("tabs__item",f,null==i?void 0:i.className,{"tabs__item--active":o===t})}),n??t)})))}function N(e){let{lazy:t,children:n,selectedValue:a}=e;if(t){const e=n.find((e=>e.props.value===a));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},n.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function v(e){const t=g(e);return r.createElement("div",{className:(0,l.Z)("tabs-container",k)},r.createElement(y,(0,a.Z)({},e,t)),r.createElement(N,(0,a.Z)({},e,t)))}function E(e){const t=(0,b.Z)();return r.createElement(v,(0,a.Z)({key:String(t)},e))}},18931:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/betweenness-centrality-online-1-8bc46fdca771aa123098386c57150e41.png"}}]);