"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[27561],{3905:(e,t,a)=>{a.d(t,{Zo:()=>h,kt:()=>g});var r=a(67294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},o=Object.keys(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var s=r.createContext({}),p=function(e){var t=r.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},h=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,s=e.parentName,h=l(e,["components","mdxType","originalType","parentName"]),m=p(a),g=n,c=m["".concat(s,".").concat(g)]||m[g]||d[g]||o;return a?r.createElement(c,i(i({ref:t},h),{},{components:a})):r.createElement(c,i({ref:t},h))}));function g(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,i=new Array(o);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:n,i[1]=l;for(var p=2;p<o;p++)i[p]=a[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,a)}m.displayName="MDXCreateElement"},71259:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var r=a(87462),n=(a(67294),a(3905));const o={id:"python-graph-translators",title:"Python graph translators",sidebar_label:"Python graph translators"},i=void 0,l={unversionedId:"under-the-hood/python-graph-translators",id:"under-the-hood/python-graph-translators",title:"Python graph translators",description:"In this under the hood content you can learn more about GQLAlchemy Python graph translators.",source:"@site/gqlalchemy/under-the-hood/python-graph-translators.md",sourceDirName:"under-the-hood",slug:"/under-the-hood/python-graph-translators",permalink:"/docs/gqlalchemy/under-the-hood/python-graph-translators",draft:!1,editUrl:"https://github.com/memgraph/docs/tree/master/gqlalchemy/under-the-hood/python-graph-translators.md",tags:[],version:"current",frontMatter:{id:"python-graph-translators",title:"Python graph translators",sidebar_label:"Python graph translators"},sidebar:"gqlalchemy",previous:{title:"Under the hood",permalink:"/docs/gqlalchemy/under-the-hood"},next:{title:"Changelog",permalink:"/docs/gqlalchemy/changelog"}},s={},p=[{value:"NetworkX graph translator",id:"networkx-graph-translator",level:2},{value:"<code>to_cypher_queries()</code> method",id:"to_cypher_queries-method",level:3},{value:"<code>nx_graph_to_memgraph_parallel()</code> method",id:"nx_graph_to_memgraph_parallel-method",level:3},{value:"<code>get_instance()</code> method",id:"get_instance-method",level:3},{value:"PyG graph translator",id:"pyg-graph-translator",level:2},{value:"<code>to_cypher_queries()</code> method",id:"to_cypher_queries-method-1",level:3},{value:"<code>get_instance()</code> method",id:"get_instance-method-1",level:3},{value:"DGL graph translator",id:"dgl-graph-translator",level:2},{value:"<code>to_cypher_queries()</code> method",id:"to_cypher_queries-method-2",level:3},{value:"<code>get_instance()</code> method",id:"get_instance-method-2",level:3},{value:"Where to next?",id:"where-to-next",level:2}],h={toc:p};function d(e){let{components:t,...a}=e;return(0,n.kt)("wrapper",(0,r.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("p",null,"In this under the hood content you can learn more about GQLAlchemy ",(0,n.kt)("strong",{parentName:"p"},"Python graph translators"),". "),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"/docs/gqlalchemy/how-to-guides/import-python-graphs"},(0,n.kt)("img",{parentName:"a",src:"https://img.shields.io/static/v1?label=Related&message=How%20to%20import&color=blue&style=for-the-badge",alt:"Related -\nHow-to"})),"\n",(0,n.kt)("a",{parentName:"p",href:"/docs/gqlalchemy/how-to-guides/export-python-graphs"},(0,n.kt)("img",{parentName:"a",src:"https://img.shields.io/static/v1?label=Related&message=How%20to%20export&color=blue&style=for-the-badge",alt:"Related -\nHow-to"})),"\n",(0,n.kt)("a",{parentName:"p",href:"https://github.com/memgraph/gqlalchemy/tree/main/tests/transformations/translators"},(0,n.kt)("img",{parentName:"a",src:"https://img.shields.io/badge/source-examples-FB6E00?logo=github&style=for-the-badge",alt:"docs-source"})),"\n",(0,n.kt)("a",{parentName:"p",href:"https://github.com/memgraph/gqlalchemy/tree/main/gqlalchemy/transformations/translators"},(0,n.kt)("img",{parentName:"a",src:"https://img.shields.io/badge/source-translators-FB6E00?logo=github&style=for-the-badge",alt:"docs-source"}))),(0,n.kt)("p",null,"Within the code, translators are divided into the following parts, depending on the Python graph type you want to translate:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#networkx-graph-translator"},(0,n.kt)("strong",{parentName:"a"},"NetworkX graph translator"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#pyg-graph-translator"},(0,n.kt)("strong",{parentName:"a"},"PyG graph translator"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#dgl-graph-translator"},(0,n.kt)("strong",{parentName:"a"},"DGL graph translator")))),(0,n.kt)("h2",{id:"networkx-graph-translator"},"NetworkX graph translator"),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"NxTranslator")," class implements the NetworkX graph translator and inherits from the ",(0,n.kt)("inlineCode",{parentName:"p"},"Translator")," class. The ",(0,n.kt)("inlineCode",{parentName:"p"},"NxTranslator")," class can be imported from the ",(0,n.kt)("inlineCode",{parentName:"p"},"gqlalchemy.transformations.translators.nx_translator")," module. "),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/memgraph/gqlalchemy/blob/main/gqlalchemy/transformations/translators/nx_translator.py"},(0,n.kt)("img",{parentName:"a",src:"https://img.shields.io/badge/source-NetworkX%20Translator-FB6E00?logo=github&style=for-the-badge",alt:"docs-source"}))),(0,n.kt)("p",null,"Translating the graph means that you can ",(0,n.kt)("strong",{parentName:"p"},"import")," NetworkX graph into Memgraph as well as ",(0,n.kt)("strong",{parentName:"p"},"export")," data from Memgraph into NetworkX graph in your Python code. The ",(0,n.kt)("inlineCode",{parentName:"p"},"NxTranslator")," defines three important methods:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#to_cypher_queries-method"},(0,n.kt)("inlineCode",{parentName:"a"},"to_cypher_queries()"))," - The method which generates Cypher queries to create a graph in Memgraph."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#nx_graph_to_memgraph_parallel-method"},(0,n.kt)("inlineCode",{parentName:"a"},"nx_graph_to_memgraph_parallel()"))," - The method which generates Cypher queries to insert data into Memgraph in parallel."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#get_instance-method"},(0,n.kt)("inlineCode",{parentName:"a"},"get_instance()"))," - The method which creates NetworkX instance from the graph stored in Memgraph. ")),(0,n.kt)("h3",{id:"to_cypher_queries-method"},(0,n.kt)("inlineCode",{parentName:"h3"},"to_cypher_queries()")," method"),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"to_cypher_queries()")," method yields queries from the ",(0,n.kt)("inlineCode",{parentName:"p"},"NetworkXCypherBuilder")," object. These queries are creating nodes (with indexes) and relationships. To create nodes with indexes, ",(0,n.kt)("inlineCode",{parentName:"p"},"create_index")," in ",(0,n.kt)("inlineCode",{parentName:"p"},"config")," must be set to ",(0,n.kt)("inlineCode",{parentName:"p"},"True"),". In that case, label-property indexes will be created on ",(0,n.kt)("inlineCode",{parentName:"p"},"id")," property of each node. With or without indexes, node creation follows the same set or rules. The value of the ",(0,n.kt)("inlineCode",{parentName:"p"},"labels")," key in NetworkX node will be translated into Memgraph node labels. Other properties will be translated into the same key-value pairs in Memgraph. Every node will have ",(0,n.kt)("inlineCode",{parentName:"p"},"id")," property matching its NetworkX identification number. After Cypher queries for the node creation are generated, then Cypher queries for relationship creation are being generated. Those Cypher queries will match nodes by their label and property ",(0,n.kt)("inlineCode",{parentName:"p"},"id")," and create a relationship between them. The value of the ",(0,n.kt)("inlineCode",{parentName:"p"},"TYPE")," key in NetworkX edge will be translated into relationship type in Memgraph. Any other property in NetworkX edge will be translated into the same key-value pair in Memgraph. To run the generated queries, following code can be used:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"for query in NxTranslator().to_cypher_queries(nx_graph):\n    memgraph.execute(query)\n")),(0,n.kt)("h3",{id:"nx_graph_to_memgraph_parallel-method"},(0,n.kt)("inlineCode",{parentName:"h3"},"nx_graph_to_memgraph_parallel()")," method"),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"nx_graph_to_memgraph_parallel()")," method is similar to the ",(0,n.kt)("a",{parentName:"p",href:"#to_cypher_queries-method"},(0,n.kt)("inlineCode",{parentName:"a"},"to_cypher_queries()"))," method. It creates a graph inside Memgraph following the same set of rules, but it writes in parallel. To do that, it splits generated queries into query groups and opens up a new connection to Memgraph in order to run queries. It will warn you if you did not set ",(0,n.kt)("inlineCode",{parentName:"p"},"create_index")," in ",(0,n.kt)("inlineCode",{parentName:"p"},"config")," to ",(0,n.kt)("inlineCode",{parentName:"p"},"True"),", because otherwise, the write process might take longer than expected. To run the generated queries, the following code can be used:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"for query in NxTranslator().nx_graph_to_memgraph_parallel(nx_graph):\n    memgraph.execute(query)\n")),(0,n.kt)("h3",{id:"get_instance-method"},(0,n.kt)("inlineCode",{parentName:"h3"},"get_instance()")," method"),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"get_instance()")," method translates data stored inside Memgraph into NetworkX graph. It traverses the graph and it stores node and relationship objects along with their properties in a NetworkX DiGraph object. Since NetworkX doesn't support node labels and relationship type in a way Memgraph does, they are encoded as node and edge properties, as values of ",(0,n.kt)("inlineCode",{parentName:"p"},"label")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"type")," key. To create NetworkX graph from data stored in Memgraph, following code can be run:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"graph =  NxTranslator().get_instance()\n")),(0,n.kt)("h2",{id:"pyg-graph-translator"},"PyG graph translator"),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"PyGTranslator")," class implements the PyG graph translator and inherits from the ",(0,n.kt)("inlineCode",{parentName:"p"},"Translator")," class. The ",(0,n.kt)("inlineCode",{parentName:"p"},"PyGTranslator")," class can be imported from the ",(0,n.kt)("inlineCode",{parentName:"p"},"gqlalchemy.transformations.translators.pyg_translator")," module. "),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/memgraph/gqlalchemy/blob/main/gqlalchemy/transformations/translators/pyg_translator.py"},(0,n.kt)("img",{parentName:"a",src:"https://img.shields.io/badge/source-PyG%20Translator-FB6E00?logo=github&style=for-the-badge",alt:"docs-source"}))),(0,n.kt)("p",null,"Translating the graph means that you can ",(0,n.kt)("strong",{parentName:"p"},"import")," PyG graph into Memgraph as well as ",(0,n.kt)("strong",{parentName:"p"},"export")," data from Memgraph into PyG graph in your Python code. The ",(0,n.kt)("inlineCode",{parentName:"p"},"PyGTranslator")," defines two important methods:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#to_cypher_queries-method-1"},(0,n.kt)("inlineCode",{parentName:"a"},"to_cypher_queries()"))," - The method which generates Cypher queries to create a graph in Memgraph."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#get_instance-method-1"},(0,n.kt)("inlineCode",{parentName:"a"},"get_instance()"))," - The method which creates PyG instance from the graph stored in Memgraph. ")),(0,n.kt)("h3",{id:"to_cypher_queries-method-1"},(0,n.kt)("inlineCode",{parentName:"h3"},"to_cypher_queries()")," method"),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"to_cypher_queries()")," method produces Cypher queries to create graph objects in Memgraph for both homogeneous and heterogeneous graph. This method can translate one-dimensional as well as multidimensional features to Memgraph properties. Isolated nodes in the graph won't get translated into Memgraph. Nodes and relationships will have property ",(0,n.kt)("inlineCode",{parentName:"p"},"pyg_id")," set to the id they have as part of the PyG graph for the consistency reasons. To run the generated queries, following code can be used:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"for query in PyGTranslator().to_cypher_queries(pyg_graph):\n    memgraph.execute(query)\n")),(0,n.kt)("h3",{id:"get_instance-method-1"},(0,n.kt)("inlineCode",{parentName:"h3"},"get_instance()")," method"),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"get_instance()")," method returns an instance of PyG heterograph from all relationships stored in Memgraph. Isolated nodes are ignored because they don't contribute to message passing neural networks. Only numerical properties that are set on all nodes and relationships are translated to the PyG instance since that is PyG requirement. Hence, any string properties, as well as numerical properties that aren't set on all nodes or relationships, won't be translated to the PyG instance. However, properties of type list will be translated to the PyG instance as a feature. Regardless of how data is connected in Memgraph, the returned PyG graph will be a heterograph instance. To create PyG graph from data stored in Memgraph, the following code can be run:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"graph =  PyGTranslator().get_instance()\n")),(0,n.kt)("h2",{id:"dgl-graph-translator"},"DGL graph translator"),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"DGLTranslator")," class implements the DGL graph translator and inherits from the ",(0,n.kt)("inlineCode",{parentName:"p"},"Translator")," class. The ",(0,n.kt)("inlineCode",{parentName:"p"},"DGLTranslator")," class can be imported from the ",(0,n.kt)("inlineCode",{parentName:"p"},"gqlalchemy.transformations.translators.dgl_translator")," module. "),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/memgraph/gqlalchemy/blob/main/gqlalchemy/transformations/translators/dgl_translator.py"},(0,n.kt)("img",{parentName:"a",src:"https://img.shields.io/badge/source-DGL%20Translator-FB6E00?logo=github&style=for-the-badge",alt:"docs-source"}))),(0,n.kt)("p",null,"Translating the graph means that you can ",(0,n.kt)("strong",{parentName:"p"},"import")," DGL graph into Memgraph as well as ",(0,n.kt)("strong",{parentName:"p"},"export")," data from Memgraph into DGL graph in your Python code. The ",(0,n.kt)("inlineCode",{parentName:"p"},"DGLTranslator")," defines two important methods:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#to_cypher_queries-method-2"},(0,n.kt)("inlineCode",{parentName:"a"},"to_cypher_queries()"))," - The method which generates Cypher queries to create a graph in Memgraph."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#get_instance-method-2"},(0,n.kt)("inlineCode",{parentName:"a"},"get_instance()"))," - The method which creates PyG instance from the graph stored in Memgraph. ")),(0,n.kt)("h3",{id:"to_cypher_queries-method-2"},(0,n.kt)("inlineCode",{parentName:"h3"},"to_cypher_queries()")," method"),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"to_cypher_queries()")," method produces Cypher queries to create graph objects in Memgraph for both homogeneous and heterogeneous graph. If the graph is homogeneous, the default ",(0,n.kt)("inlineCode",{parentName:"p"},"_N")," as a node label and ",(0,n.kt)("inlineCode",{parentName:"p"},"_E")," as a relationship label will be used. This method can translate one-dimensional as well as multidimensional features to Memgraph properties. Isolated nodes in the graph won't get translated into Memgraph. Nodes and relationships will have property ",(0,n.kt)("inlineCode",{parentName:"p"},"dgl_id")," set to the ID they have as part of the DGL graph for the consistency reasons. To run the generated queries, the following code can be used:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"for query in DGLTranslator().to_cypher_queries(dgl_graph):\n    memgraph.execute(query)\n")),(0,n.kt)("h3",{id:"get_instance-method-2"},(0,n.kt)("inlineCode",{parentName:"h3"},"get_instance()")," method"),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"get_instance()")," method returns instance of DGL heterograph from all relationships stored in Memgraph. Isolated nodes are ignored because they don't contribute in message passing neural networks. Only numerical properties that are set on all nodes and relationships are translated to the DGL instance since that is DGL requirement. Hence, any string properties, as well as numerical properties, that aren't set on all nodes or relationships, won't be translated to the DGL instance. However, properties of type list will be translated to the PyG instance as a feature. Regardless of how data is connected in Memgraph, the returned DGL graph will be a heterograph instance. To create DGL graph from data stored in Memgraph, following code can be run:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"graph =  DGLTranslator().get_instance()\n")),(0,n.kt)("h2",{id:"where-to-next"},"Where to next?"),(0,n.kt)("p",null,"If you want to learn more about using NetworkX with Memgraph with interesting resources and courses, head over to the ",(0,n.kt)("a",{parentName:"p",href:"https://memgraph.com/memgraph-for-networkx?utm_source=docs&utm_medium=referral&utm_campaign=networkx_ppp&utm_term=docsgqla%2Bhowto&utm_content=textlink"},(0,n.kt)("strong",{parentName:"a"},"Memgraph for NetworkX developers"))," website. If you have any questions or want to connect with the Memgraph community, ",(0,n.kt)("a",{parentName:"p",href:"https://www.discord.gg/memgraph"},(0,n.kt)("strong",{parentName:"a"},"join our Discord server")),"."))}d.isMDXComponent=!0}}]);