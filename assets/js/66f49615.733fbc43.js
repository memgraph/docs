"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[57827],{3905:function(e,n,t){t.d(n,{Zo:function(){return d},kt:function(){return h}});var r=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var p=r.createContext({}),s=function(e){var n=r.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},d=function(e){var n=s(e.components);return r.createElement(p.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},c=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,a=e.originalType,p=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=s(t),h=i,m=c["".concat(p,".").concat(h)]||c[h]||u[h]||a;return t?r.createElement(m,o(o({ref:n},d),{},{components:t})):r.createElement(m,o({ref:n},d))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=t.length,o=new Array(a);o[0]=c;var l={};for(var p in n)hasOwnProperty.call(n,p)&&(l[p]=n[p]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var s=2;s<a;s++)o[s]=t[s];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}c.displayName="MDXCreateElement"},12205:function(e,n,t){t.r(n),t.d(n,{assets:function(){return d},contentTitle:function(){return p},default:function(){return h},frontMatter:function(){return l},metadata:function(){return s},toc:function(){return u}});var r=t(87462),i=t(63366),a=(t(67294),t(3905)),o=["components"],l={id:"reference-guide",title:"Graph Style Script reference guide",sidebar_label:"GSS reference guide"},p=void 0,s={unversionedId:"style-script/reference-guide",id:"style-script/reference-guide",title:"Graph Style Script reference guide",description:"The main building blocks of Graph Style Script (GSS) are expressions and",source:"@site/lab/style-script/reference-guide.md",sourceDirName:"style-script",slug:"/style-script/reference-guide",permalink:"/docs/memgraph-lab/style-script/reference-guide",editUrl:"https://github.com/memgraph/docs/tree/master/lab/style-script/reference-guide.md",tags:[],version:"current",frontMatter:{id:"reference-guide",title:"Graph Style Script reference guide",sidebar_label:"GSS reference guide"},sidebar:"lab",previous:{title:"Graph Style Script language",permalink:"/docs/memgraph-lab/graph-style-script-language"},next:{title:"GSS functions",permalink:"/docs/memgraph-lab/style-script/gss-functions"}},d={},u=[{value:"Expressions",id:"expressions",level:2},{value:"Directives",id:"directives",level:2},{value:"<code>@NodeStyle</code>",id:"nodestyle",level:3},{value:"<code>@EdgeStyle</code>",id:"edgestyle",level:3},{value:"File Structure",id:"file-structure",level:2}],c={toc:u};function h(e){var n=e.components,t=(0,i.Z)(e,o);return(0,a.kt)("wrapper",(0,r.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The main building blocks of Graph Style Script (GSS) are expressions and\ndirectives. GSS files are a sequence of expressions and directives."),(0,a.kt)("h2",{id:"expressions"},"Expressions"),(0,a.kt)("p",null,"Expressions are used to combine values to create new values using functions. For\nexample, the expression:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Add(2, 5)\n  -> 7\n")),(0,a.kt)("p",null,"creates a new value 7 from values 2 and 5. There are a lot of functions built\ninto Style script so there are even more ways to combine values. There is even a\nfunction to create new functions."),(0,a.kt)("p",null,"When expressions are evaluated, values are created. There are several types of\nStyle script values: ",(0,a.kt)("inlineCode",{parentName:"p"},"Boolean"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"Color"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"Number"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"String"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"Array"),",\n",(0,a.kt)("inlineCode",{parentName:"p"},"Dictionary"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"Function"),"and ",(0,a.kt)("inlineCode",{parentName:"p"},"Null"),"."),(0,a.kt)("p",null,"An expression can be either literal expressions, name expressions or function\napplications. Literal expressions exist for ",(0,a.kt)("inlineCode",{parentName:"p"},"Color"),"s, ",(0,a.kt)("inlineCode",{parentName:"p"},"Number"),"s and ",(0,a.kt)("inlineCode",{parentName:"p"},"String"),"s."),(0,a.kt)("p",null,"This is a literal expression for ",(0,a.kt)("inlineCode",{parentName:"p"},"String"),"s."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'"Hello"\n  -> Hello\n')),(0,a.kt)("p",null,"It evaluates to the value ",(0,a.kt)("inlineCode",{parentName:"p"},'"Hello"')," of the type ",(0,a.kt)("inlineCode",{parentName:"p"},"String"),". The newline character\nand double quotes can be escaped in strings using ","\\"," (backslash)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'"In the end he said: \\"I am Iron Man!\\""\n  -> In the end he said: "I am Iron Man!"\n')),(0,a.kt)("p",null,"These are literal expressions for ",(0,a.kt)("inlineCode",{parentName:"p"},"Number"),"s."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"123\n  -> 123\n3.14159\n  -> 3.14159\n")),(0,a.kt)("p",null,"Literal expressions for colors are hex strings starting with '#'. This is a\nliteral expression for the color red."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"#ff0000\n  -> #ff0000\n")),(0,a.kt)("p",null,"Name expressions are names that can be evaluated if there are values bound to\nthem in the environment (lexical scope). Names can start with any of the lower\ncase or upper case letters of the English alphabet and apart from those can\ncontain digits and the following characters: ?, !, $, -, ","_",", ., ","*",". Names can be\ndefined using the ",(0,a.kt)("inlineCode",{parentName:"p"},"Define")," function."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'Define(superhero, "Iron Man")\nsuperhero\n  -> Iron Man\n')),(0,a.kt)("p",null,"In the previous example the value ",(0,a.kt)("inlineCode",{parentName:"p"},'"Iron Man"')," was bound to the name\n",(0,a.kt)("inlineCode",{parentName:"p"},"superhero"),". After that name expression ",(0,a.kt)("inlineCode",{parentName:"p"},"superhero")," evaluates the value ",(0,a.kt)("inlineCode",{parentName:"p"},'"Iron\nMan"')," to type ",(0,a.kt)("inlineCode",{parentName:"p"},"String"),"."),(0,a.kt)("p",null,"There are many built-in names that are bound to useful values. Most used are\nboolean values which are bound to ",(0,a.kt)("inlineCode",{parentName:"p"},"True")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"False")," and null value which is\nbound to ",(0,a.kt)("inlineCode",{parentName:"p"},"Null"),". Also, all the CSS web colors are bound to their names."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"dodgerblue\n  -> #1e90ff\nforestgreen\n  -> #228b22\n")),(0,a.kt)("p",null,"The third type of expressions are function application expressions. A function\ncan be applied to the list of expressions (arguments) in the following way."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'Concat("Agents", " ", "of", " ", "S.H.I.E.L.D.")\n  -> Agents of S.H.I.E.L.D.\n')),(0,a.kt)("p",null,"Here the function ",(0,a.kt)("inlineCode",{parentName:"p"},"Concat")," was applied to the list of string literal expressions\nto produce their concatenation. Any expression can be an argument."),(0,a.kt)("p",null,"Not all expressions have to be evaluated. For example, when calling ",(0,a.kt)("inlineCode",{parentName:"p"},"If"),"\nfunction one argument will not be evaluated."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'Define(mood, "happy")\nDefine(name, "Happy Hogan")\nIf(Equals?(mood, "happy"),\n   Format("{} is happy today.", name),\n   Format("{} is not happy today.", name))\n  -> Happy Hogan is happy today.\n')),(0,a.kt)("p",null,"In the previous example expression ",(0,a.kt)("inlineCode",{parentName:"p"},'Format("{} is not happy today", name)')," will\nnot be evaluated because its value is not needed."),(0,a.kt)("p",null,"Some other function will not evaluate their arguments because they are\ninterested in their names and not values. For example, when creating a new\nfunction argument names aren't evaluated, but are remembered to be later bound\nto the function arguments when the function is called."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Define(square, Function(x, Mul(x, x)))\nsquare(2)\n  -> 4\n")),(0,a.kt)("p",null,"In the previous example the name ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," isn't evaluated in the first line, and\nneither is the expression ",(0,a.kt)("inlineCode",{parentName:"p"},"Mul(x, x)"),". In the second line when the function\n",(0,a.kt)("inlineCode",{parentName:"p"},"square")," is called number 2 will be bound to the name ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," and only then will\n",(0,a.kt)("inlineCode",{parentName:"p"},"Mul(x, x)")," be evaluated."),(0,a.kt)("h2",{id:"directives"},"Directives"),(0,a.kt)("p",null,"Directives are the second building block of style script. Directive names start\nwith '@'. The name is followed by the optional expression (filter) which is\nfollowed by an opening curly brace, directive body and a closing curly brace.\nThe directive body is a list of pairs of property names and expressions.\nProperty names and expressions are separated by a colon and after every\nexpression, a new line must follow. The directive structure is the following."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"@<DirectiveName> <expression>? {\n  <property-name-1>: <expression-1>\n  ...\n  ...\n  <property-name-n>: <expression-n>\n}\n")),(0,a.kt)("p",null,"Like in CSS, directives defined later override properties of the previous\ndirectives."),(0,a.kt)("p",null,"Style script currently has two directives: ",(0,a.kt)("inlineCode",{parentName:"p"},"@NodeStyle"),", for defining the visual\nstyle of graph nodes, and ",(0,a.kt)("inlineCode",{parentName:"p"},"@EdgeStyle")," for defining the visual style of graph\nrelationships."),(0,a.kt)("p",null,"An example of a directive is ",(0,a.kt)("inlineCode",{parentName:"p"},"@NodeStyle")," directive which can be used to specify\nstyle properties of a graph node."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'@NodeStyle {\n  border-width: 2\n  color: #abcdef\n  label: "Hello, World!"\n}\n')),(0,a.kt)("h3",{id:"nodestyle"},(0,a.kt)("inlineCode",{parentName:"h3"},"@NodeStyle")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"@NodeStyle")," directive is used for defining style properties of a graph\nnode. It is possible to filter the nodes to which the directive applies by\nproviding an optional predicate after the directive name and before the opening\ncurly brace."),(0,a.kt)("p",null,"Before any expressions are evaluated (including the predicate) the name ",(0,a.kt)("inlineCode",{parentName:"p"},"node"),"\nis bound to the graph node for which the directive is being evaluated. Graph\nnode is of type ",(0,a.kt)("inlineCode",{parentName:"p"},"Dictionary")," and has all information about the node (properties,\nlabels)."),(0,a.kt)("p",null,"Here is an example of a ",(0,a.kt)("inlineCode",{parentName:"p"},"@NodeStyle")," directive that is applied to all graph\nnodes with the label superhero:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'@NodeStyle HasLabel?(node, vehicle) {\n  label: Format("{}, horsepower: {}",\n                Property(node, "model"),\n                Property(node, "horsepower"))\n}\n')),(0,a.kt)("p",null,"The predicate can be any expression that returns a value of type ",(0,a.kt)("inlineCode",{parentName:"p"},"Boolean"),". It\nshould depend on ",(0,a.kt)("inlineCode",{parentName:"p"},"node"),", because if it doesn't, it will either be applied to all\nnodes or to no nodes."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'@NodeStyle And(HasProperty(node, "name"),\n               Equals?(Property(node, "name"), "Tony Stark")) {\n  color: gold\n  shadow-color: red\n  label: "You know who I am"\n}\n')),(0,a.kt)("p",null,"Take a look at the ",(0,a.kt)("a",{parentName:"p",href:"/docs/memgraph-lab/style-script/gss-nodestyle-directive"},"GSS @NodeStyle directive\nproperties")," page to see\nall node styling possibilities."),(0,a.kt)("h3",{id:"edgestyle"},(0,a.kt)("inlineCode",{parentName:"h3"},"@EdgeStyle")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"@EdgeStyle")," directive is used for defining the style properties of a graph\nrelationship. Most things work like the ",(0,a.kt)("inlineCode",{parentName:"p"},"@NodeStyle")," directive with one\nexception: the directive will bind the name ",(0,a.kt)("inlineCode",{parentName:"p"},"edge")," to the relationship for which\nthe directive is being evaluated (",(0,a.kt)("inlineCode",{parentName:"p"},"@NodeStyle")," binds the name ",(0,a.kt)("inlineCode",{parentName:"p"},"node"),")."),(0,a.kt)("p",null,"Take a look at the ",(0,a.kt)("a",{parentName:"p",href:"/docs/memgraph-lab/style-script/gss-edgestyle-directive"},"GSS @EdgeStyle directive\nproperties")," page to see\nall relationship styling possibilities."),(0,a.kt)("h1",{id:"built-in-functions"},"Built-in functions"),(0,a.kt)("p",null,"Graph Style Script has a large number of built-in functions that can help you\nwith achieving the right style for your graph. Take a look at the ",(0,a.kt)("a",{parentName:"p",href:"/docs/memgraph-lab/style-script/gss-functions"},"list of GSS\nbuilt-in functions"),"."),(0,a.kt)("h2",{id:"file-structure"},"File Structure"),(0,a.kt)("p",null,"Style script files are composed of expressions and directives. All expressions\noutside directives are evaluated first in the global environment. This is useful\nfor defining names using function ",(0,a.kt)("inlineCode",{parentName:"p"},"Define"),". After that ",(0,a.kt)("inlineCode",{parentName:"p"},"@NodeStyle")," and\n",(0,a.kt)("inlineCode",{parentName:"p"},"@EdgeStyle")," directives are evaluated for each node and relationship,\nrespectively. All the names in the global environment are visible while applying\nthe directives so they can be used for defining property values inside\ndirectives."),(0,a.kt)("p",null,"For example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'Define(square, Function(x, Mul(x, x)))\nDefine(maxAllowedDebt, 10000)\n\n@NodeStyle HasLabel?(node, "BankUser") {\n  size: square(Property(node, "debt"))\n  color: If(Greater?(Property(node, "debt"), maxAllowedDebt),\n            red,\n            lightblue)\n}\n')),(0,a.kt)("p",null,"Names ",(0,a.kt)("inlineCode",{parentName:"p"},"square")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"maxAllowedDebt")," are visible inside ",(0,a.kt)("inlineCode",{parentName:"p"},"@NodeStyle")," directive."))}h.isMDXComponent=!0}}]);