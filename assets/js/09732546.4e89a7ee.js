"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[31525],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return c}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var d=a.createContext({}),s=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=s(e.components);return a.createElement(d.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,d=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=s(n),c=r,h=u["".concat(d,".").concat(c)]||u[c]||m[c]||o;return n?a.createElement(h,l(l({ref:t},p),{},{components:n})):a.createElement(h,l({ref:t},p))}));function c(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,l=new Array(o);l[0]=u;var i={};for(var d in t)hasOwnProperty.call(t,d)&&(i[d]=t[d]);i.originalType=e,i.mdxType="string"==typeof e?e:r,l[1]=i;for(var s=2;s<o;s++)l[s]=n[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},80365:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return p},metadata:function(){return m},toc:function(){return u},Highlight:function(){return c},default:function(){return g}});var a=n(87462),r=n(63366),o=(n(67294),n(3905)),l=n(55064),i=n(58215),d=["components"],s={id:"node2vec-online",title:"node2vec_online",sidebar_label:"node2vec_online"},p=void 0,m={unversionedId:"query-modules/python/node2vec-online",id:"query-modules/python/node2vec-online",isDocsHomePage:!1,title:"node2vec_online",description:"<span",source:"@site/mage/query-modules/python/node2vec-online.md",sourceDirName:"query-modules/python",slug:"/query-modules/python/node2vec-online",permalink:"/docs/mage/query-modules/python/node2vec-online",editUrl:"https://github.com/memgraph/docs/tree/master/mage/query-modules/python/node2vec-online.md",tags:[],version:"current",frontMatter:{id:"node2vec-online",title:"node2vec_online",sidebar_label:"node2vec_online"},sidebar:"mage",previous:{title:"graph_coloring",permalink:"/docs/mage/query-modules/python/graph-coloring"},next:{title:"node_similarity",permalink:"/docs/mage/query-modules/python/node-similarity"}},u=[{value:"Abstract",id:"abstract",children:[]},{value:"Procedures",id:"procedures",children:[{value:"<code>set_streamwalk_updater(half_life, max_length, beta, cutoff, sampled_walks, full_walks)</code>",id:"set_streamwalk_updaterhalf_life-max_length-beta-cutoff-sampled_walks-full_walks",children:[]},{value:"<code>set_word2vec_learner(embedding_dimension, learning_rate, skip_gram )</code>",id:"set_word2vec_learnerembedding_dimension-learning_rate-skip_gram-",children:[]},{value:"<code>get()</code>",id:"get",children:[]},{value:"<code>update(edges)</code>",id:"updateedges",children:[]},{value:"Input:",id:"input-2",children:[]},{value:"<code>reset()</code>",id:"reset",children:[]},{value:"<code>help()</code>",id:"help",children:[]}]},{value:"Example",id:"example",children:[]}],c=function(e){var t=e.children,n=e.color;return(0,o.kt)("span",{style:{backgroundColor:n,borderRadius:"2px",color:"#fff",padding:"0.2rem"}},t)},h={toc:u,Highlight:c};function g(e){var t=e.components,s=(0,r.Z)(e,d);return(0,o.kt)("wrapper",(0,a.Z)({},h,s,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/memgraph/mage/blob/main/python/node2vec_online.py"},(0,o.kt)("img",{parentName:"a",src:"https://img.shields.io/badge/source-node2vec_online-FB6E00?logo=github&style=for-the-badge",alt:"docs-source"}))),(0,o.kt)("h2",{id:"abstract"},"Abstract"),(0,o.kt)("p",null,"The ",(0,o.kt)("strong",{parentName:"p"},"node2vec_online")," algorithm learns and updates temporal node embeddings on\nthe fly for tracking and measuring node similarity over time in graph streams.\nThe algorithm creates similar embeddings for two nodes (e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},"v")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"u"),") if there\nis an option to reach one node from the other across edges that appeared\nrecently. In other words, the embedding of a node ",(0,o.kt)("inlineCode",{parentName:"p"},"v")," should be more similar to\nthe embedding of node ",(0,o.kt)("inlineCode",{parentName:"p"},"u")," if we can reach ",(0,o.kt)("inlineCode",{parentName:"p"},"u")," by taking steps backward to node\n",(0,o.kt)("inlineCode",{parentName:"p"},"v")," across edges that appeared before the previous one. These steps backward\nfrom one node to the other form a temporal walk. It is temporal since it depends\non when the edge appeared in the graph."),(0,o.kt)("p",null,"To make two nodes more similar and to create these temporal walks, the ",(0,o.kt)("inlineCode",{parentName:"p"},"Node2Vec\nOnline")," algorithm uses the ",(0,o.kt)("inlineCode",{parentName:"p"},"StreamWalk updater")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Word2Vec learner"),"."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"StreamWalk updater")," is a machine for sampling temporal walks. A sampling of the\nwalk is done in a backward fashion because we look only at the incoming edges of\nthe node. Since one node can have multiple incoming edges, when sampling a walk,\n",(0,o.kt)("inlineCode",{parentName:"p"},"StreamWalk updater")," uses probabilities to determine which incoming edge of the\nnode it will take next, and that way leading to a new node. These probabilities\nare computed after the edge arrives and before temporal walk sampling.\nProbability represents a sum over all temporal walks ",(0,o.kt)("inlineCode",{parentName:"p"},"z")," ending in node ",(0,o.kt)("inlineCode",{parentName:"p"},"v"),"\nusing edges arriving no later than the latest one of already sampled ones in the\ntemporal walk. When the algorithm decides which edge to take next for temporal\nwalk creation, it uses these computed weights (probabilities). Every time a new\nedge appears in the graph, these probabilities are updated just for two nodes of\na new edge."),(0,o.kt)("p",null,"After walks sampling, ",(0,o.kt)("inlineCode",{parentName:"p"},"Word2Vec learner")," uses these prepared temporal walks to\nmake node embeddings more similar using the ",(0,o.kt)("inlineCode",{parentName:"p"},"gensim Word2Vec")," module. These\nsampled walks are given as sentences to the ",(0,o.kt)("inlineCode",{parentName:"p"},"gensim Word2Vec")," module, which then\noptimizes for the similarity of the node embeddings in the walk with stochastic\ngradient descent using a skip-gram model or continuous-bag-of-words (CBOW)."),(0,o.kt)("p",null,"Embeddings capture the graph topology, relationships between nodes, and further\nrelevant information. How the embeddings capture this inherent information of\nthe graph is not fixed."),(0,o.kt)("p",null,"Capturing information in networks often shuttles between two kinds of\nsimilarities: ",(0,o.kt)("strong",{parentName:"p"},"homophily")," and ",(0,o.kt)("strong",{parentName:"p"},"structural equivalence"),". Under the\n",(0,o.kt)("strong",{parentName:"p"},"homophily")," hypothesis, nodes that are highly interconnected and belong to\nsimilar network clusters or communities should be embedded closely together. In\ncontrast, under the ",(0,o.kt)("strong",{parentName:"p"},"structural equivalence")," hypothesis, nodes that have\nsimilar structural roles in networks should be embedded closely together (e.g.,\nnodes that act as hubs of their corresponding communities)."),(0,o.kt)("p",null,"Currently, our implementation captures for ",(0,o.kt)("strong",{parentName:"p"},"homophily")," - nodes that are highly\ninterconnected and belong to similar network clusters or communities."),(0,o.kt)("p",null,(0,o.kt)("sup",{parentName:"p",id:"fnref-1"},(0,o.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1"))," ",(0,o.kt)("a",{parentName:"p",href:"https://appliednetsci.springeropen.com/track/pdf/10.1007/s41109-019-0169-5.pdf"},"Node embeddings in dynamic\ngraphs"),",\nFerenc B\xe9res, R\xf3bert P\xe1lovics, Domokos Mikl\xf3s Kelen and Andr\xe1s A. Bencz\xfar"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Trait"),(0,o.kt)("th",{parentName:"tr",align:null},"Value"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},"Module type")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)(c,{color:"#FB6E00",mdxType:"Highlight"},(0,o.kt)("strong",{parentName:"td"},"module")))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},"Implementation")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)(c,{color:"#FB6E00",mdxType:"Highlight"},(0,o.kt)("strong",{parentName:"td"},"Python")))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},"Graph direction")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)(c,{color:"#FB6E00",mdxType:"Highlight"},(0,o.kt)("strong",{parentName:"td"},"directed")))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},"Edge weights")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)(c,{color:"#FB6E00",mdxType:"Highlight"},(0,o.kt)("strong",{parentName:"td"},"unweighted")))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},"Parallelism")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)(c,{color:"#FB6E00",mdxType:"Highlight"},(0,o.kt)("strong",{parentName:"td"},"sequential")))))),(0,o.kt)("h2",{id:"procedures"},"Procedures"),(0,o.kt)("h3",{id:"set_streamwalk_updaterhalf_life-max_length-beta-cutoff-sampled_walks-full_walks"},(0,o.kt)("inlineCode",{parentName:"h3"},"set_streamwalk_updater(half_life, max_length, beta, cutoff, sampled_walks, full_walks)")),(0,o.kt)("h4",{id:"input"},"Input:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"half_life: int")," \u27a1 half-life ","[seconds]",", used in the temporal walk probability\ncalculation"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"max_length: int")," \u27a1 Maximum length of the sampled temporal random walks"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"beta: float")," \u27a1 Damping factor for long paths"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"cutoff: int")," \u27a1 Temporal cutoff in seconds to exclude very distant past"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"sampled_walks: int")," \u27a1 Number of sampled walks for each edge update"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"full_walks: bool")," \u27a1  Return every node of the sampled walk for representation\nlearning (full_walks=True) or only the endpoints of the walk\n(full_walks=False)")),(0,o.kt)("h4",{id:"output"},"Output:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"message: str")," \u27a1 Whether parameters are set or they need to be reset")),(0,o.kt)("h4",{id:"usage"},"Usage:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL node2vec_online.set_streamwalk_updater(7200, 3, 0.9, 604800, 4, False);\n")),(0,o.kt)("h3",{id:"set_word2vec_learnerembedding_dimension-learning_rate-skip_gram-"},(0,o.kt)("inlineCode",{parentName:"h3"},"set_word2vec_learner(embedding_dimension, learning_rate, skip_gram )")),(0,o.kt)("h4",{id:"input-1"},"Input:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"embedding_dimension: int")," \u27a1 Number of dimensions in the representation of the\nembedding vector"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"learning_rate: float")," \u27a1 Learning rate"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"skip_gram: bool")," \u27a1 Whether to use skip-gram model (True) or\ncontinuous-bag-of-words (CBOW)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"negative_rate: int")," \u27a1 Negative rate for Gensim Word2Vec model"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"threads: int")," \u27a1 Maximum number of threads for parallelization")),(0,o.kt)("h4",{id:"output-1"},"Output:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"message: str")," \u27a1 Whether parameters are set or they need to be reset")),(0,o.kt)("h4",{id:"usage-1"},"Usage:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL node2vec_online.set_word2vec_learner(128, 0.01, True, 10, 1);\n")),(0,o.kt)("h3",{id:"get"},(0,o.kt)("inlineCode",{parentName:"h3"},"get()")),(0,o.kt)("h4",{id:"output-2"},"Output:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"node: mgp.Vertex")," \u27a1 Node in the graph for which embedding exists"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"embedding: mgp.List[mgp.Number]")," \u27a1 Embedding for the given node")),(0,o.kt)("h4",{id:"usage-2"},"Usage:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL node2vec_online.get();\n")),(0,o.kt)("h3",{id:"updateedges"},(0,o.kt)("inlineCode",{parentName:"h3"},"update(edges)")),(0,o.kt)("h3",{id:"input-2"},"Input:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"edges: mgp.List[mgp.Edge]")," \u27a1  List of edges added to the graph. For those\nnodes only ",(0,o.kt)("inlineCode",{parentName:"li"},"node2vec_online")," calculates embeddings.")),(0,o.kt)("h4",{id:"usage-3"},"Usage:"),(0,o.kt)("p",null,"There are a few options here. The first one is to create a trigger, so every\ntime an edge is added to graph, the trigger calls a procedure and makes an\nupdate."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cypher"},"CREATE TRIGGER trigger ON --\x3e CREATE BEFORE COMMIT\nEXECUTE CALL node2vec_online.update(createdEdges) YIELD *;\n")),(0,o.kt)("p",null,"The second option is to add all the edges and then call the algorithm with those\nedges:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cypher"},"MATCH (n)-[e]->(m)\nWITH COLLECT(e) as edges\nCALL node2vec_online.update(edges) YIELD *\nWITH 1 as x\nRETURN x;\n")),(0,o.kt)("h3",{id:"reset"},(0,o.kt)("inlineCode",{parentName:"h3"},"reset()")),(0,o.kt)("h4",{id:"output-3"},"Output:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"message: str")," \u27a1 Message that parameters are ready to be set again")),(0,o.kt)("h4",{id:"usage-4"},"Usage:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL node2vec_online.reset();\n")),(0,o.kt)("h3",{id:"help"},(0,o.kt)("inlineCode",{parentName:"h3"},"help()")),(0,o.kt)("h4",{id:"output-4"},"Output:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"name: str")," \u27a1 Name of available functions"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"value: str")," \u27a1 Documentation for every function")),(0,o.kt)("h4",{id:"usage-5"},"Usage:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL node2vec_online.help();\n")),(0,o.kt)("h2",{id:"example"},"Example"),(0,o.kt)(l.Z,{groupId:"example",defaultValue:"visualization",values:[{label:"Step 1: Input graph",value:"visualization"},{label:"Step 2: Set parameters and trigger",value:"cypher-preset"},{label:"Step 3: Load commands",value:"cypher-load"},{label:"Step 4: Running command",value:"run"},{label:"Step 5: Results",value:"result"}],mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"visualization",mdxType:"TabItem"},(0,o.kt)("img",{src:n(3224).Z})),(0,o.kt)(i.Z,{value:"cypher-preset",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL node2vec_online.set_streamwalk_updater(7200, 2, 0.9, 604800, 2, True) YIELD *;\nCALL node2vec_online.set_word2vec_learner(2, 0.01, True, 1, 1) YIELD *;\n\nCREATE TRIGGER trigger ON --\x3e CREATE BEFORE COMMIT\nEXECUTE CALL node2vec_online.update(createdEdges) YIELD *;\n"))),(0,o.kt)(i.Z,{value:"cypher-load",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cypher"},"MERGE (n:Node {id: 1}) MERGE (m:Node {id: 6}) CREATE (n)-[:RELATION]->(m);\nMERGE (n:Node {id: 2}) MERGE (m:Node {id: 6}) CREATE (n)-[:RELATION]->(m);\nMERGE (n:Node {id: 10}) MERGE (m:Node {id: 5}) CREATE (n)-[:RELATION]->(m);\nMERGE (n:Node {id: 5}) MERGE (m:Node {id: 2}) CREATE (n)-[:RELATION]->(m);\n\nMERGE (n:Node {id: 9}) MERGE (m:Node {id: 7}) CREATE (n)-[:RELATION]->(m);\nMERGE (n:Node {id: 7}) MERGE (m:Node {id: 3}) CREATE (n)-[:RELATION]->(m);\nMERGE (n:Node {id: 3}) MERGE (m:Node {id: 6}) CREATE (n)-[:RELATION]->(m);\n\nMERGE (n:Node {id: 9}) MERGE (m:Node {id: 8}) CREATE (n)-[:RELATION]->(m);\nMERGE (n:Node {id: 8}) MERGE (m:Node {id: 4}) CREATE (n)-[:RELATION]->(m);\nMERGE (n:Node {id: 4}) MERGE (m:Node {id: 6}) CREATE (n)-[:RELATION]->(m);\n"))),(0,o.kt)(i.Z,{value:"run",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL node2vec_online.get() YIELD node, embedding\nRETURN node, embedding\nORDER BY node.id;\n"))),(0,o.kt)(i.Z,{value:"result",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-plaintext"},"+-------------------------+-------------------------+\n| node                    | embedding               |\n+-------------------------+-------------------------+\n| (:Node {id: 1})         | [0.255167, 0.450464]    |\n| (:Node {id: 2})         | [-0.465147, -0.35584]   |\n| (:Node {id: 3})         | [-0.243008, -0.0908009] |\n| (:Node {id: 4})         | [-0.414261, -0.472441]  |\n| (:Node {id: 5})         | [-0.250771, -0.188169]  |\n| (:Node {id: 6})         | [-0.0268114, 0.0118215] |\n| (:Node {id: 7})         | [-0.226831, 0.327703]   |\n| (:Node {id: 8})         | [0.143829, 0.0495937]   |\n| (:Node {id: 9})         | [0.369025, -0.0766736]  |\n| (:Node {id: 10})        | [0.322944, 0.448649]    |\n+-------------------------+-------------------------+\n\n")))))}g.isMDXComponent=!0},58215:function(e,t,n){var a=n(67294);t.Z=function(e){var t=e.children,n=e.hidden,r=e.className;return a.createElement("div",{role:"tabpanel",hidden:n,className:r},t)}},55064:function(e,t,n){n.d(t,{Z:function(){return s}});var a=n(67294),r=n(79443);var o=function(){var e=(0,a.useContext)(r.Z);if(null==e)throw new Error('"useUserPreferencesContext" is used outside of "Layout" component.');return e},l=n(86010),i="tabItem_1uMI",d="tabItemActive_2DSg";var s=function(e){var t,n=e.lazy,r=e.block,s=e.defaultValue,p=e.values,m=e.groupId,u=e.className,c=a.Children.toArray(e.children),h=null!=p?p:c.map((function(e){return{value:e.props.value,label:e.props.label}})),g=null!=s?s:null==(t=c.find((function(e){return e.props.default})))?void 0:t.props.value,k=o(),f=k.tabGroupChoices,N=k.setTabGroupChoices,b=(0,a.useState)(g),v=b[0],y=b[1],E=[];if(null!=m){var w=f[m];null!=w&&w!==v&&h.some((function(e){return e.value===w}))&&y(w)}var C=function(e){var t=e.currentTarget,n=E.indexOf(t),a=h[n].value;y(a),null!=m&&(N(m,a),setTimeout((function(){var e,n,a,r,o,l,i,s;(e=t.getBoundingClientRect(),n=e.top,a=e.left,r=e.bottom,o=e.right,l=window,i=l.innerHeight,s=l.innerWidth,n>=0&&o<=s&&r<=i&&a>=0)||(t.scrollIntoView({block:"center",behavior:"smooth"}),t.classList.add(d),setTimeout((function(){return t.classList.remove(d)}),2e3))}),150))},_=function(e){var t,n=null;switch(e.key){case"ArrowRight":var a=E.indexOf(e.target)+1;n=E[a]||E[0];break;case"ArrowLeft":var r=E.indexOf(e.target)-1;n=E[r]||E[E.length-1]}null==(t=n)||t.focus()};return a.createElement("div",{className:"tabs-container"},a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.Z)("tabs",{"tabs--block":r},u)},h.map((function(e){var t=e.value,n=e.label;return a.createElement("li",{role:"tab",tabIndex:v===t?0:-1,"aria-selected":v===t,className:(0,l.Z)("tabs__item",i,{"tabs__item--active":v===t}),key:t,ref:function(e){return E.push(e)},onKeyDown:_,onFocus:C,onClick:C},null!=n?n:t)}))),n?(0,a.cloneElement)(c.filter((function(e){return e.props.value===v}))[0],{className:"margin-vert--md"}):a.createElement("div",{className:"margin-vert--md"},c.map((function(e,t){return(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==v})}))))}},79443:function(e,t,n){var a=(0,n(67294).createContext)(void 0);t.Z=a},86010:function(e,t,n){function a(e){var t,n,r="";if("string"==typeof e||"number"==typeof e)r+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(n=a(e[t]))&&(r&&(r+=" "),r+=n);else for(t in e)e[t]&&(r&&(r+=" "),r+=t);return r}function r(){for(var e,t,n=0,r="";n<arguments.length;)(e=arguments[n++])&&(t=a(e))&&(r&&(r+=" "),r+=t);return r}n.d(t,{Z:function(){return r}})},3224:function(e,t,n){t.Z=n.p+"assets/images/node2vec-online-2638f0e20136a1f858affb1be4013687.png"}}]);