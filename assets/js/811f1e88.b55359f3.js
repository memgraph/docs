"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[33158],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>k});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function p(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),s=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):p(p({},t),e)),n},u=function(e){var t=s(e.components);return a.createElement(o.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,o=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),m=s(n),k=r,c=m["".concat(o,".").concat(k)]||m[k]||d[k]||l;return n?a.createElement(c,p(p({ref:t},u),{},{components:n})):a.createElement(c,p({ref:t},u))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,p=new Array(l);p[0]=m;var i={};for(var o in t)hasOwnProperty.call(t,o)&&(i[o]=t[o]);i.originalType=e,i.mdxType="string"==typeof e?e:r,p[1]=i;for(var s=2;s<l;s++)p[s]=n[s];return a.createElement.apply(null,p)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},14372:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>p,default:()=>d,frontMatter:()=>l,metadata:()=>i,toc:()=>s});var a=n(87462),r=(n(67294),n(3905));const l={id:"python-api",title:"Query modules Python API",sidebar_label:"Python API",slug:"/reference-guide/query-modules/api/python-api"},p=void 0,i={unversionedId:"reference-guide/query-modules/implement-custom-query-modules/api/python-api",id:"version-2.10.0/reference-guide/query-modules/implement-custom-query-modules/api/python-api",title:"Query modules Python API",description:"This is the API documentation for mgp.py that contains definitions of the",source:"@site/memgraph_versioned_docs/version-2.10.0/reference-guide/query-modules/implement-custom-query-modules/api/python-api.md",sourceDirName:"reference-guide/query-modules/implement-custom-query-modules/api",slug:"/reference-guide/query-modules/api/python-api",permalink:"/docs/memgraph/2.10.0/reference-guide/query-modules/api/python-api",draft:!1,editUrl:"https://github.com/memgraph/docs/tree/master/memgraph_versioned_docs/version-2.10.0/reference-guide/query-modules/implement-custom-query-modules/api/python-api.md",tags:[],version:"2.10.0",frontMatter:{id:"python-api",title:"Query modules Python API",sidebar_label:"Python API",slug:"/reference-guide/query-modules/api/python-api"},sidebar:"memgraph",previous:{title:"Implement custom query modules",permalink:"/docs/memgraph/2.10.0/reference-guide/query-modules/implement-custom-query-modules/overview"},next:{title:"Mock Python API",permalink:"/docs/memgraph/2.10.0/reference-guide/query-modules/api/mock-python-api"}},o={},s=[{value:"mgp.read_proc(func: Callable\u2026, mgp.Record)",id:"mgpread_procfunc-callable-mgprecord",level:2},{value:"mgp.write_proc(func: Callable\u2026, mgp.Record)",id:"mgpwrite_procfunc-callable-mgprecord",level:2},{value:"mgp.add_batch_read_proc(func: Callable\u2026, mgp.Record, initializer: typing.Callable, cleanup: typing.Callable)",id:"mgpadd_batch_read_procfunc-callable-mgprecord-initializer-typingcallable-cleanup-typingcallable",level:2},{value:"mgp.add_batch_write_proc(func: Callable\u2026, mgp.Record, initializer: typing.Callable, cleanup: typing.Callable)",id:"mgpadd_batch_write_procfunc-callable-mgprecord-initializer-typingcallable-cleanup-typingcallable",level:2},{value:"mgp.function(func: Callable[\u2026])",id:"mgpfunctionfunc-callable",level:2},{value:"Label Objects",id:"label-objects",level:2},{value:"name",id:"name",level:3},{value:"Properties Objects",id:"properties-objects",level:2},{value:"get()",id:"get",level:3},{value:"set()",id:"set",level:3},{value:"items()",id:"items",level:3},{value:"keys()",id:"keys",level:3},{value:"values()",id:"values",level:3},{value:"__len__",id:"__len__",level:3},{value:"__iter__",id:"__iter__",level:3},{value:"__getitem__",id:"__getitem__",level:3},{value:"__setitem__",id:"__setitem__",level:3},{value:"__contains__",id:"__contains__",level:3},{value:"EdgeType Objects",id:"edgetype-objects",level:2},{value:"name",id:"name-1",level:3},{value:"Edge Objects",id:"edge-objects",level:2},{value:"is_valid()",id:"is_valid",level:3},{value:"underlying_graph_is_mutable()",id:"underlying_graph_is_mutable",level:3},{value:"id",id:"id",level:3},{value:"type",id:"type",level:3},{value:"from_vertex()",id:"from_vertex",level:3},{value:"to_vertex()",id:"to_vertex",level:3},{value:"properties",id:"properties",level:3},{value:"__eq__",id:"__eq__",level:3},{value:"Vertex Objects",id:"vertex-objects",level:2},{value:"is_valid()",id:"is_valid-1",level:3},{value:"underlying_graph_is_mutable()",id:"underlying_graph_is_mutable-1",level:3},{value:"id",id:"id-1",level:3},{value:"labels",id:"labels",level:3},{value:"add_label()",id:"add_label",level:3},{value:"remove_label()",id:"remove_label",level:3},{value:"properties",id:"properties-1",level:3},{value:"in_edges",id:"in_edges",level:3},{value:"out_edges",id:"out_edges",level:3},{value:"__eq__",id:"__eq__-1",level:3},{value:"Path Objects",id:"path-objects",level:2},{value:"__init__",id:"__init__",level:3},{value:"is_valid()",id:"is_valid-2",level:3},{value:"expand()",id:"expand",level:3},{value:"vertices",id:"vertices",level:3},{value:"edges",id:"edges",level:3},{value:"Record Objects",id:"record-objects",level:2},{value:"__init__",id:"__init__-1",level:3},{value:"Vertices Objects",id:"vertices-objects",level:2},{value:"is_valid()",id:"is_valid-3",level:3},{value:"__iter__",id:"__iter__-1",level:3},{value:"__contains__",id:"__contains__-1",level:3},{value:"__len__",id:"__len__-1",level:3},{value:"Graph Objects",id:"graph-objects",level:2},{value:"is_valid()",id:"is_valid-4",level:3},{value:"get_vertex_by_id()",id:"get_vertex_by_id",level:3},{value:"vertices",id:"vertices-1",level:3},{value:"is_mutable()",id:"is_mutable",level:3},{value:"create_vertex()",id:"create_vertex",level:3},{value:"delete_vertex()",id:"delete_vertex",level:3},{value:"detach_delete_vertex()",id:"detach_delete_vertex",level:3},{value:"create_edge()",id:"create_edge",level:3},{value:"delete_edge()",id:"delete_edge",level:3},{value:"AbortError Objects",id:"aborterror-objects",level:2},{value:"ProcCtx Objects",id:"procctx-objects",level:2},{value:"graph",id:"graph",level:3},{value:"Logger Objects",id:"logger-objects",level:2},{value:"info()",id:"info",level:3},{value:"debug()",id:"debug",level:3},{value:"error()",id:"error",level:3},{value:"trace()",id:"trace",level:3},{value:"warning()",id:"warning",level:3},{value:"critical()",id:"critical",level:3},{value:"UnsupportedTypingError Objects",id:"unsupportedtypingerror-objects",level:2},{value:"Deprecated Objects",id:"deprecated-objects",level:2},{value:"read_proc()",id:"read_proc",level:3},{value:"write_proc()",id:"write_proc",level:3},{value:"InvalidMessageError Objects",id:"invalidmessageerror-objects",level:2},{value:"Message Objects",id:"message-objects",level:2},{value:"is_valid()",id:"is_valid-5",level:3},{value:"source_type()",id:"source_type",level:3},{value:"payload()",id:"payload",level:3},{value:"topic_name()",id:"topic_name",level:3},{value:"key()",id:"key",level:3},{value:"timestamp()",id:"timestamp",level:3},{value:"offset()",id:"offset",level:3},{value:"InvalidMessagesError Objects",id:"invalidmessageserror-objects",level:2},{value:"Messages Objects",id:"messages-objects",level:2},{value:"is_valid()",id:"is_valid-6",level:3},{value:"message_at()",id:"message_at",level:3},{value:"total_messages()",id:"total_messages",level:3},{value:"TransCtx Objects",id:"transctx-objects",level:2},{value:"graph",id:"graph-1",level:3},{value:"FuncCtx Objects",id:"funcctx-objects",level:2},{value:"function()",id:"function",level:3},{value:"InvalidContextError Objects",id:"invalidcontexterror-objects",level:2},{value:"UnknownError Objects",id:"unknownerror-objects",level:2},{value:"UnableToAllocateError Objects",id:"unabletoallocateerror-objects",level:2},{value:"InsufficientBufferError Objects",id:"insufficientbuffererror-objects",level:2},{value:"OutOfRangeError Objects",id:"outofrangeerror-objects",level:2},{value:"LogicErrorError Objects",id:"logicerrorerror-objects",level:2},{value:"DeletedObjectError Objects",id:"deletedobjecterror-objects",level:2},{value:"InvalidArgumentError Objects",id:"invalidargumenterror-objects",level:2},{value:"KeyAlreadyExistsError Objects",id:"keyalreadyexistserror-objects",level:2},{value:"ImmutableObjectError Objects",id:"immutableobjecterror-objects",level:2},{value:"ValueConversionError Objects",id:"valueconversionerror-objects",level:2},{value:"SerializationError Objects",id:"serializationerror-objects",level:2},{value:"AuthorizationError Objects",id:"authorizationerror-objects",level:2}],u={toc:s};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This is the API documentation for ",(0,r.kt)("inlineCode",{parentName:"p"},"mgp.py")," that contains definitions of the\npublic Python API provided by Memgraph. In essence, this is a wrapper around the\n",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"./c-api"},"C API")),". This source file can be found in the Memgraph\ninstallation directory, under ",(0,r.kt)("inlineCode",{parentName:"p"},"/usr/lib/memgraph/python_support"),"."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"For an example of how to implement\xa0query modules in Python, take a look at ",(0,r.kt)("a",{parentName:"p",href:"/docs/memgraph/2.10.0/reference-guide/query-modules/implement-custom-query-modules/custom-query-module-example#python-api"},"the\nexample we\nprovided"),". ")),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"If you install any Python modules after running Memgraph, you'll have to ",(0,r.kt)("a",{parentName:"p",href:"../load-call-query-modules#loading-query-modules"},"load\nthem into Memgraph")," or restart\nMemgraph in order to use them."),(0,r.kt)("p",{parentName:"admonition"},"You can also develop query modules in Python from Memgraph Lab (v2.0 and newer). Just\nnavigate to ",(0,r.kt)("strong",{parentName:"p"},"Query Modules")," and click on ",(0,r.kt)("strong",{parentName:"p"},"New Module")," to start.")),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"If you need an additional Python library not included with Memgraph, check out\n",(0,r.kt)("a",{parentName:"p",href:"/memgraph/how-to-guides/query-modules#how-to-install-external-python-libraries"},"the guide on how to install\nit"),".")),(0,r.kt)("h2",{id:"mgpread_procfunc-callable-mgprecord"},"mgp.read_proc(func: Callable","[\u2026, mgp.Record]",")"),(0,r.kt)("p",null,"Register func as a read-only procedure of the current module."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"read_proc")," is meant to be used as a decorator function to register module\nprocedures. The registered func needs to be a callable which optionally takes\n",(0,r.kt)("inlineCode",{parentName:"p"},"ProcCtx")," as the first argument. Other arguments of func will be bound to values\npassed in the Cypher query. The full signature of func needs to be annotated with\ntypes. The return type must be ",(0,r.kt)("inlineCode",{parentName:"p"},"Record(field_name=type, \u2026)")," and the procedure must\nproduce either a complete ",(0,r.kt)("inlineCode",{parentName:"p"},"Record")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"None"),". To mark a field as deprecated, use\n",(0,r.kt)("inlineCode",{parentName:"p"},"Record(field_name=Deprecated(type), \u2026)"),". Multiple records can be produced by\nreturning an iterable of them. Registering generator functions is currently not\nsupported."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example usage")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"    import mgp\n\n    @mgp.read_proc\n    def procedure(context: mgp.ProcCtx,\n                required_arg: mgp.Nullable[mgp.Any],\n                optional_arg: mgp.Nullable[mgp.Any] = None\n                ) -> mgp.Record(result=str, args=list):\n        args = [required_arg, optional_arg]\n        # Multiple rows can be produced by returning an iterable of mgp.Record\n        return mgp.Record(args=args, result='Hello World!')\n")),(0,r.kt)("p",null,"The example procedure above returns 2 fields: ",(0,r.kt)("inlineCode",{parentName:"p"},"args")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"result"),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"args")," is a copy of arguments passed to the procedure."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"result")," is the result of this procedure, a \u201cHello World!\u201d string.")),(0,r.kt)("p",null,"Any errors can be reported by raising an ",(0,r.kt)("inlineCode",{parentName:"p"},"Exception"),"."),(0,r.kt)("p",null,"The procedure can be invoked in Cypher using the following calls:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL example.procedure(1, 2) YIELD args, result;\nCALL example.procedure(1) YIELD args, result;\n")),(0,r.kt)("p",null,"Naturally, you may pass in different arguments or yield less fields."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Install the ",(0,r.kt)("inlineCode",{parentName:"p"},"mgp")," Python module so your editor can use typing annotations\nproperly and suggest methods and classes it contains. You can install the module\nby running ",(0,r.kt)("inlineCode",{parentName:"p"},"pip install mgp"),".")),(0,r.kt)("h2",{id:"mgpwrite_procfunc-callable-mgprecord"},"mgp.write_proc(func: Callable","[\u2026, mgp.Record]",")"),(0,r.kt)("p",null,"Register func as a writeable procedure of the current module."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"write_proc")," is meant to be used as a decorator function to register module\nprocedures. The registered func needs to be a callable which optionally takes\n",(0,r.kt)("inlineCode",{parentName:"p"},"ProcCtx")," as the first argument. Other arguments of func will be bound to values\npassed in the Cypher query. The full signature of func needs to be annotated with\ntypes. The return type must be ",(0,r.kt)("inlineCode",{parentName:"p"},"Record(field_name=type, \u2026)")," and the procedure must\nproduce either a complete ",(0,r.kt)("inlineCode",{parentName:"p"},"Record")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"None"),". To mark a field as deprecated, use\n",(0,r.kt)("inlineCode",{parentName:"p"},"Record(field_name=Deprecated(type), \u2026)"),". Multiple records can be produced by\nreturning an iterable of them. Registering generator functions is currently not\nsupported."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example usage")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"import mgp\n\n@mgp.write_proc\ndef procedure(context: mgp.ProcCtx,\n    required_arg: str,\n    optional_arg: mgp.Nullable[str] = None\n    ) -> mgp.Record(result=mgp.Vertex):\n\n    vertex = context.graph.create_vertex()\n    vertex_properties = vertex.properties\n    vertex_properties[\u201crequired_arg\u201d] = required_arg\n\n    if optional_arg is not None:\n        vertex_properties[\u201coptional_arg\u201d] = optional_arg\n\n    return mgp.Record(result=vertex)\n")),(0,r.kt)("p",null,"The example procedure above returns  a newly created vertex which has at most 2\nproperties:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"required_arg")," is always present and its value is the first argument of the\nprocedure."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"optional_arg")," is present if the second argument of the procedure is not null.")),(0,r.kt)("p",null,"Any errors can be reported by raising an ",(0,r.kt)("inlineCode",{parentName:"p"},"Exception"),"."),(0,r.kt)("p",null,"The procedure can be invoked in Cypher using the following calls:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},"CALL example.procedure(\u201cproperty value\u201d, \u201canother one\u201d) YIELD result;\nCALL example.procedure(\u201csingle argument\u201d) YIELD result;\n")),(0,r.kt)("p",null,"Naturally, you may pass in different arguments."),(0,r.kt)("h2",{id:"mgpadd_batch_read_procfunc-callable-mgprecord-initializer-typingcallable-cleanup-typingcallable"},"mgp.add_batch_read_proc(func: Callable","[\u2026, mgp.Record]",", initializer: typing.Callable, cleanup: typing.Callable)"),(0,r.kt)("p",null,"Register ",(0,r.kt)("inlineCode",{parentName:"p"},"func")," as a read-only batch procedure of the current module."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"func")," represents a function that is invoked through OpenCypher. Through OpenCypher user invokes ",(0,r.kt)("inlineCode",{parentName:"p"},"func"),". Memgraph invokes first the ",(0,r.kt)("inlineCode",{parentName:"p"},"initializer")," function. After the ",(0,r.kt)("inlineCode",{parentName:"p"},"initializer")," function, ",(0,r.kt)("inlineCode",{parentName:"p"},"func")," is called until it returns an empty result. Afterward, the ",(0,r.kt)("inlineCode",{parentName:"p"},"cleanup")," function is called, which can be used to clean up global resources. Only at that point is garbage collection invoked, so any dangling references to Python objects will be cleaned."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"initializer")," must define the same parameters as the main ",(0,r.kt)("inlineCode",{parentName:"p"},"func")," function, and will receive the same parameters as ",(0,r.kt)("inlineCode",{parentName:"p"},"func"),". The position of arguments and the type of arguments must be the same. "),(0,r.kt)("p",null,"Otherwise, the same rules apply as in ",(0,r.kt)("inlineCode",{parentName:"p"},"read_proc"),". It's important to keep in mind that no Memgraph resources can be stored in ",(0,r.kt)("inlineCode",{parentName:"p"},"init")," and during batching. After ",(0,r.kt)("inlineCode",{parentName:"p"},"initializer")," and each ",(0,r.kt)("inlineCode",{parentName:"p"},"func")," call, every Memgraph-related object is invalidated and can't be used later on."),(0,r.kt)("h2",{id:"mgpadd_batch_write_procfunc-callable-mgprecord-initializer-typingcallable-cleanup-typingcallable"},"mgp.add_batch_write_proc(func: Callable","[\u2026, mgp.Record]",", initializer: typing.Callable, cleanup: typing.Callable)"),(0,r.kt)("p",null,"Register ",(0,r.kt)("inlineCode",{parentName:"p"},"func")," as a writeable batch procedure of the current module."),(0,r.kt)("p",null,"The same rules for parameters and order of calls to functions apply for a writeable procedure as for the read-only batched procedure. "),(0,r.kt)("h2",{id:"mgpfunctionfunc-callable"},"mgp.function(func: Callable[","[\u2026]","])"),(0,r.kt)("p",null,"Register func as a Memgraph function in the current module."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"function")," is meant to be used as a decorator function to register module\nfunctions. The registered func needs to be a callable which optionally takes\n",(0,r.kt)("inlineCode",{parentName:"p"},"FuncCtx")," as the first argument. Other arguments of func will be bound to values\npassed in the Cypher query. Only the funcion arguments need to be annotated with\ntypes. The return type doesn't need to be specified, but it has to be supported\nby ",(0,r.kt)("inlineCode",{parentName:"p"},"mgp.Any"),". Registering generator functions is currently not supported."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example usage")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"import mgp\n\n@mgp.function\ndef func_example(context: mgp.FuncCtx,\n    required_arg: str,\n    optional_arg: mgp.Nullable[str] = None\n    ):\n\n    return_args = [required_arg]\n\n    if optional_arg is not None:\n        return_args.append(optional_arg)\n\n    # Return any kind of result supported by mgp.Any\n    return return_args\n")),(0,r.kt)("p",null,"The example function above returns a list of provided arguments:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"required_arg")," is always present and its value is the first argument of the\nfunction."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"optional_arg")," is present if the second argument of the function is not\n",(0,r.kt)("inlineCode",{parentName:"li"},"null"),".")),(0,r.kt)("p",null,"Any errors can be reported by raising an ",(0,r.kt)("inlineCode",{parentName:"p"},"Exception"),"."),(0,r.kt)("p",null,"The function can be invoked in Cypher using the following calls:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cypher"},'RETURN example.func_example("first argument", "second_argument");\nRETURN example.func_example("first argument");\n')),(0,r.kt)("p",null,"Naturally, you may pass in different arguments."),(0,r.kt)("p",null,"This module provides the API for usage in custom openCypher procedures."),(0,r.kt)("h2",{id:"label-objects"},"Label Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class Label()\n")),(0,r.kt)("p",null,"Label of a ",(0,r.kt)("inlineCode",{parentName:"p"},"Vertex"),"."),(0,r.kt)("h3",{id:"name"},"name"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"@property\ndef name() -> str\n")),(0,r.kt)("p",null,"Get the name of the label."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  A string that represents the name of the label."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"label.name")),(0,r.kt)("h2",{id:"properties-objects"},"Properties Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class Properties()\n")),(0,r.kt)("p",null,"A collection of properties either on a ",(0,r.kt)("inlineCode",{parentName:"p"},"Vertex")," or an ",(0,r.kt)("inlineCode",{parentName:"p"},"Edge"),"."),(0,r.kt)("h3",{id:"get"},"get()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def get(property_name: str, default=None) -> object\n")),(0,r.kt)("p",null,"Get the value of a property with the given name or return default value."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"property_name")," - String that represents property name."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"default")," - Default value return if there is no property.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  Any object value that property under ",(0,r.kt)("inlineCode",{parentName:"p"},"property_name")," has or default value otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"InvalidContextError")," - If ",(0,r.kt)("inlineCode",{parentName:"li"},"edge")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"vertex")," is out of context."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"UnableToAllocateError")," - If unable to allocate a ",(0,r.kt)("inlineCode",{parentName:"li"},"mgp.Value"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"DeletedObjectError")," - If the ",(0,r.kt)("inlineCode",{parentName:"li"},"object")," has been deleted.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"vertex.properties.get(property_name)\nedge.properties.get(property_name)\n")),(0,r.kt)("h3",{id:"set"},"set()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def set(property_name: str, value: object) -> None\n")),(0,r.kt)("p",null,"Set the value of the property. When the value is ",(0,r.kt)("inlineCode",{parentName:"p"},"None"),", then the\nproperty is removed."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"property_name")," - String that represents property name."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"value")," - Object that represents value to be set.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"UnableToAllocateError")," - If unable to allocate memory for storing the property."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ImmutableObjectError")," - If the object is immutable."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"DeletedObjectError")," - If the object has been deleted."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"SerializationError")," - If the object has been modified by another transaction."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ValueConversionError")," - If ",(0,r.kt)("inlineCode",{parentName:"li"},"value")," is vertex, edge or path.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"vertex.properties.set(property_name, value)\nedge.properties.set(property_name, value)\n")),(0,r.kt)("h3",{id:"items"},"items()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def items() -> typing.Iterable[Property]\n")),(0,r.kt)("p",null,"Iterate over the properties. Doesn\u2019t return a dynamic view of the properties but copies the\ncurrent properties."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  Iterable ",(0,r.kt)("inlineCode",{parentName:"p"},"Property")," of names and values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"InvalidContextError")," - If edge or vertex is out of context."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"UnableToAllocateError")," - If unable to allocate an iterator."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"DeletedObjectError")," - If the object has been deleted.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"items = vertex.properties.items()\nfor it in items:\n  name = it.name\n  value = it.value\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"items = edge.properties.items()\nfor it in items:\n  name = it.name\n  value = it.value\n")),(0,r.kt)("h3",{id:"keys"},"keys()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def keys() -> typing.Iterable[str]\n")),(0,r.kt)("p",null,"Iterate over property names. Doesn\u2019t return a dynamic view of the property names but copies the\nname of the current properties."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  Iterable list of strings that represent names/keys of properties."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"InvalidContextError")," - If edge or vertex is out of context."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"UnableToAllocateError")," - If unable to allocate an iterator."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"DeletedObjectError")," - If the object has been deleted.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"graph.vertex.properties.keys()\ngraph.edge.properties.keys()\n")),(0,r.kt)("h3",{id:"values"},"values()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def values() -> typing.Iterable[object]\n")),(0,r.kt)("p",null,"Iterate over property values. Doesn\u2019t return a dynamic view of the property values but copies the\nvalue of the current properties."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  Iterable list of property values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"InvalidContextError")," - If edge or vertex is out of context."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"UnableToAllocateError")," - If unable to allocate an iterator."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"DeletedObjectError")," - If the object has been deleted.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"vertex.properties.values()\nedge.properties.values()\n")),(0,r.kt)("h3",{id:"__len__"},"_","_","len","_","_"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def __len__() -> int\n")),(0,r.kt)("p",null,"Get the number of properties."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  A number of properties on vertex or edge."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"InvalidContextError")," - If edge or vertex is out of context."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"UnableToAllocateError")," - If unable to allocate an iterator."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"DeletedObjectError")," - If the object has been deleted.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"len(vertex.properties)\nlen(edge.properties)\n")),(0,r.kt)("h3",{id:"__iter__"},"_","_","iter","_","_"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def __iter__() -> typing.Iterable[str]\n")),(0,r.kt)("p",null,"Iterate over property names."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  Iterable list of strings that represent names of properties."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"InvalidContextError")," - If edge or vertex is out of context."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"UnableToAllocateError")," - If unable to allocate an iterator."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"DeletedObjectError")," - If the object has been deleted.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"iter(vertex.properties)\niter(edge.properties)\n")),(0,r.kt)("h3",{id:"__getitem__"},"_","_","getitem","_","_"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def __getitem__(property_name: str) -> object\n")),(0,r.kt)("p",null,"Get the value of a property with the given name or raise KeyError."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"property_name")," - String that represents property name.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  Any value that property under property_name have."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"InvalidContextError")," - If edge or vertex is out of context."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"UnableToAllocateError")," - If unable to allocate a mgp.Value."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"DeletedObjectError")," - If the object has been deleted.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"vertex.properties[property_name]\nedge.properties[property_name]\n")),(0,r.kt)("h3",{id:"__setitem__"},"_","_","setitem","_","_"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def __setitem__(property_name: str, value: object) -> None\n")),(0,r.kt)("p",null,"Set the value of the property. When the value is ",(0,r.kt)("inlineCode",{parentName:"p"},"None"),", then the\nproperty is removed."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"property_name")," - String that represents property name."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"value")," - Object that represents value to be set.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"UnableToAllocateError")," - If unable to allocate memory for storing the property."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ImmutableObjectError")," - If the object is immutable."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"DeletedObjectError")," - If the object has been deleted."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"SerializationError")," - If the object has been modified by another transaction."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ValueConversionError")," - If ",(0,r.kt)("inlineCode",{parentName:"li"},"value")," is vertex, edge or path.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"vertex.properties[property_name] = value\nedge.properties[property_name] = value\n")),(0,r.kt)("h3",{id:"__contains__"},"_","_","contains","_","_"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def __contains__(property_name: str) -> bool\n")),(0,r.kt)("p",null,"Check if there is a property with the given name."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"property_name")," - String that represents property name")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  Bool value that depends if there is with a given name."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"InvalidContextError")," - If edge or vertex is out of context."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"UnableToAllocateError")," - If unable to allocate a mgp.Value."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"DeletedObjectError")," - If the object has been deleted.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"if property_name in vertex.properties:\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"if property_name in edge.properties:\n")),(0,r.kt)("h2",{id:"edgetype-objects"},"EdgeType Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class EdgeType()\n")),(0,r.kt)("p",null,"Type of an Edge."),(0,r.kt)("h3",{id:"name-1"},"name"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"@property\ndef name() -> str\n")),(0,r.kt)("p",null,"Get the name of EdgeType."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  A string that represents the name of EdgeType."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"edge.type.name")),(0,r.kt)("h2",{id:"edge-objects"},"Edge Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class Edge()\n")),(0,r.kt)("p",null,"Edge in the graph database."),(0,r.kt)("p",null,"Access to an Edge is only valid during a single execution of a procedure in\na query. You should not globally store an instance of an Edge. Using an\ninvalid Edge instance will raise InvalidContextError."),(0,r.kt)("h3",{id:"is_valid"},"is","_","valid()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def is_valid() -> bool\n")),(0,r.kt)("p",null,"Check if ",(0,r.kt)("inlineCode",{parentName:"p"},"edge")," is in a valid context and may be used."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  A ",(0,r.kt)("inlineCode",{parentName:"p"},"bool")," value depends on if the ",(0,r.kt)("inlineCode",{parentName:"p"},"edge")," is in a valid context."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"edge.is_valid()")),(0,r.kt)("h3",{id:"underlying_graph_is_mutable"},"underlying","_","graph","_","is","_","mutable()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def underlying_graph_is_mutable() -> bool\n")),(0,r.kt)("p",null,"Check if the ",(0,r.kt)("inlineCode",{parentName:"p"},"graph")," can be modified."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  A ",(0,r.kt)("inlineCode",{parentName:"p"},"bool")," value depends on if the ",(0,r.kt)("inlineCode",{parentName:"p"},"graph")," is mutable."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"edge.underlying_graph_is_mutable()")),(0,r.kt)("h3",{id:"id"},"id"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"@property\ndef id() -> EdgeId\n")),(0,r.kt)("p",null,"Get the ID of the edge."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"EdgeId")," represents ID of the edge."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"InvalidContextError")," - If edge is out of context.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"edge.id")),(0,r.kt)("h3",{id:"type"},"type"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"@property\ndef type() -> EdgeType\n")),(0,r.kt)("p",null,"Get the type of edge."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"EdgeType")," describing the type of edge."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"InvalidContextError")," - If edge is out of context.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"edge.type")),(0,r.kt)("h3",{id:"from_vertex"},"from","_","vertex()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'@property\ndef from_vertex() -> "Vertex"\n')),(0,r.kt)("p",null,"Get the source vertex."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"Vertex")," from where the edge is directed."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"InvalidContextError")," - If edge is out of context.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"edge.from_vertex")),(0,r.kt)("h3",{id:"to_vertex"},"to","_","vertex()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'@property\ndef to_vertex() -> "Vertex"\n')),(0,r.kt)("p",null,"Get the destination vertex."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"Vertex")," to where the edge is directed."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"InvalidContextError")," - If edge is out of context.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"edge.to_vertex")),(0,r.kt)("h3",{id:"properties"},"properties"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"@property\ndef properties() -> Properties\n")),(0,r.kt)("p",null,"Get the properties of the edge."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  All ",(0,r.kt)("inlineCode",{parentName:"p"},"Properties")," of edge."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"InvalidContextError")," - If edge is out of context.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"edge.properties")),(0,r.kt)("h3",{id:"__eq__"},"_","_","eq","_","_"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def __eq__(other) -> bool\n")),(0,r.kt)("p",null,"Raise InvalidContextError."),(0,r.kt)("h2",{id:"vertex-objects"},"Vertex Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class Vertex()\n")),(0,r.kt)("p",null,"Vertex in the graph database."),(0,r.kt)("p",null,"Access to a Vertex is only valid during a single execution of a procedure\nin a query. You should not globally store an instance of a Vertex. Using an\ninvalid Vertex instance will raise InvalidContextError."),(0,r.kt)("h3",{id:"is_valid-1"},"is","_","valid()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def is_valid() -> bool\n")),(0,r.kt)("p",null,"Checks if ",(0,r.kt)("inlineCode",{parentName:"p"},"Vertex")," is in valid context and may be used."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  A ",(0,r.kt)("inlineCode",{parentName:"p"},"bool")," value depends on if the ",(0,r.kt)("inlineCode",{parentName:"p"},"Vertex")," is in a valid context."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"vertex.is_valid()")),(0,r.kt)("h3",{id:"underlying_graph_is_mutable-1"},"underlying","_","graph","_","is","_","mutable()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def underlying_graph_is_mutable() -> bool\n")),(0,r.kt)("p",null,"Check if the ",(0,r.kt)("inlineCode",{parentName:"p"},"graph")," is mutable."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  A ",(0,r.kt)("inlineCode",{parentName:"p"},"bool")," value depends on if the ",(0,r.kt)("inlineCode",{parentName:"p"},"graph")," is mutable."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"vertex.underlying_graph_is_mutable()")),(0,r.kt)("h3",{id:"id-1"},"id"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"@property\ndef id() -> VertexId\n")),(0,r.kt)("p",null,"Get the ID of the Vertex."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"VertexId")," represents ID of the vertex."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"InvalidContextError")," - If vertex is out of context.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"vertex.id")),(0,r.kt)("h3",{id:"labels"},"labels"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"@property\ndef labels() -> typing.Tuple[Label]\n")),(0,r.kt)("p",null,"Get the labels of the vertex."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  A tuple of ",(0,r.kt)("inlineCode",{parentName:"p"},"Label")," representing vertex Labels"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"InvalidContextError")," - If vertex is out of context."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"OutOfRangeError")," - If some of the labels are removed while collecting the labels."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"DeletedObjectError")," - If ",(0,r.kt)("inlineCode",{parentName:"li"},"Vertex")," has been deleted.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"vertex.labels")),(0,r.kt)("h3",{id:"add_label"},"add","_","label()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def add_label(label: str) -> None\n")),(0,r.kt)("p",null,"Add the label to the vertex."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"label")," - String label to be added.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"InvalidContextError")," - If ",(0,r.kt)("inlineCode",{parentName:"li"},"Vertex")," is out of context."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"UnableToAllocateError")," - If unable to allocate memory for storing the label."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ImmutableObjectError")," - If ",(0,r.kt)("inlineCode",{parentName:"li"},"Vertex")," is immutable."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"DeletedObjectError")," - If ",(0,r.kt)("inlineCode",{parentName:"li"},"Vertex")," has been deleted."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"SerializationError")," - If ",(0,r.kt)("inlineCode",{parentName:"li"},"Vertex")," has been modified by another transaction.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"vertex.add_label(label)")),(0,r.kt)("h3",{id:"remove_label"},"remove","_","label()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def remove_label(label: str) -> None\n")),(0,r.kt)("p",null,"Remove the label from the vertex."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"label")," - String label to be deleted")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"InvalidContextError")," - If ",(0,r.kt)("inlineCode",{parentName:"li"},"Vertex")," is out of context."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ImmutableObjectError")," - If ",(0,r.kt)("inlineCode",{parentName:"li"},"Vertex")," is immutable."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"DeletedObjectError")," - If ",(0,r.kt)("inlineCode",{parentName:"li"},"Vertex")," has been deleted."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"SerializationError")," - If ",(0,r.kt)("inlineCode",{parentName:"li"},"Vertex")," has been modified by another transaction.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"vertex.remove_label(label)")),(0,r.kt)("h3",{id:"properties-1"},"properties"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"@property\ndef properties() -> Properties\n")),(0,r.kt)("p",null,"Get the properties of the vertex."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"Properties")," on a current vertex."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"InvalidContextError")," - If ",(0,r.kt)("inlineCode",{parentName:"li"},"Vertex")," is out of context.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"vertex.properties")),(0,r.kt)("h3",{id:"in_edges"},"in","_","edges"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"@property\ndef in_edges() -> typing.Iterable[Edge]\n")),(0,r.kt)("p",null,"Iterate over inbound edges of the vertex. When the first parameter to a procedure is a projected graph, iterating will start over the inbound edges of the given vertex in the projected graph.\nDoesn\u2019t return a dynamic view of the edges but copies the\ncurrent inbound edges."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  Iterable list of ",(0,r.kt)("inlineCode",{parentName:"p"},"Edge")," objects that are directed in towards the current vertex."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"InvalidContextError")," - If ",(0,r.kt)("inlineCode",{parentName:"li"},"Vertex")," is out of context."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"UnableToAllocateError")," - If unable to allocate an iterator."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"DeletedObjectError")," - If ",(0,r.kt)("inlineCode",{parentName:"li"},"Vertex")," has been deleted.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"for edge in vertex.in_edges:")),(0,r.kt)("h3",{id:"out_edges"},"out","_","edges"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"@property\ndef out_edges() -> typing.Iterable[Edge]\n")),(0,r.kt)("p",null,"Iterate over outbound edges of the vertex. When the first parameter to a procedure is a projected graph, iterating will start over the outbound edges of the given vertex in the projected graph."),(0,r.kt)("p",null,"Doesn\u2019t return a dynamic view of the edges but copies the\ncurrent outbound edges."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  Iterable list of ",(0,r.kt)("inlineCode",{parentName:"p"},"Edge")," objects that are directed out of the current vertex."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"InvalidContextError")," - If ",(0,r.kt)("inlineCode",{parentName:"li"},"Vertex")," is out of context."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"UnableToAllocateError")," - If unable to allocate an iterator."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"DeletedObjectError")," - If ",(0,r.kt)("inlineCode",{parentName:"li"},"Vertex")," has been deleted.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"for edge in vertex.out_edges:")),(0,r.kt)("h3",{id:"__eq__-1"},"_","_","eq","_","_"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def __eq__(other) -> bool\n")),(0,r.kt)("p",null,"Raise InvalidContextError"),(0,r.kt)("h2",{id:"path-objects"},"Path Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class Path()\n")),(0,r.kt)("p",null,"Path containing Vertex and Edge instances."),(0,r.kt)("h3",{id:"__init__"},"_","_","init","_","_"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def __init__(starting_vertex_or_path: typing.Union[_mgp.Path, Vertex])\n")),(0,r.kt)("p",null,"Initialize with a starting Vertex."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"InvalidContextError")," - If passed in Vertex is invalid."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"UnableToAllocateError")," - If cannot allocate a path.")),(0,r.kt)("h3",{id:"is_valid-2"},"is","_","valid()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def is_valid() -> bool\n")),(0,r.kt)("p",null,"Check if ",(0,r.kt)("inlineCode",{parentName:"p"},"Path")," is in valid context and may be used."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  A ",(0,r.kt)("inlineCode",{parentName:"p"},"bool")," value depends on if the ",(0,r.kt)("inlineCode",{parentName:"p"},"Path")," is in a valid context."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"path.is_valid()")),(0,r.kt)("h3",{id:"expand"},"expand()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def expand(edge: Edge)\n")),(0,r.kt)("p",null,"Append an edge continuing from the last vertex on the path."),(0,r.kt)("p",null,"The last vertex on the path will become the other endpoint of the given\nedge, as continued from the current last vertex."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"edge")," - ",(0,r.kt)("inlineCode",{parentName:"li"},"Edge")," that is added to the path")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"InvalidContextError")," - If using an invalid ",(0,r.kt)("inlineCode",{parentName:"li"},"Path")," instance or if passed in ",(0,r.kt)("inlineCode",{parentName:"li"},"Edge")," is invalid."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"LogicErrorError")," - If the current last vertex in the path is not part of the given edge."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"UnableToAllocateError")," - If unable to allocate memory for path extension.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"path.expand(edge)")),(0,r.kt)("h3",{id:"vertices"},"vertices"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"@property\ndef vertices() -> typing.Tuple[Vertex, ...]\n")),(0,r.kt)("p",null,"Vertices are ordered from the start to the end of the path."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  A tuple of ",(0,r.kt)("inlineCode",{parentName:"p"},"Vertex")," objects order from start to end of the path."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"InvalidContextError")," - If using an invalid Path instance.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"path.vertices")),(0,r.kt)("h3",{id:"edges"},"edges"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"@property\ndef edges() -> typing.Tuple[Edge, ...]\n")),(0,r.kt)("p",null,"Edges are ordered from the start to the end of the path."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  A tuple of ",(0,r.kt)("inlineCode",{parentName:"p"},"Edge")," objects order from start to end of the path"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"InvalidContextError")," - If using an invalid ",(0,r.kt)("inlineCode",{parentName:"li"},"Path")," instance.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"path.edges")),(0,r.kt)("h2",{id:"record-objects"},"Record Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class Record()\n")),(0,r.kt)("p",null,"Represents a record of resulting field values."),(0,r.kt)("h3",{id:"__init__-1"},"_","_","init","_","_"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def __init__(**kwargs)\n")),(0,r.kt)("p",null,"Initialize with name=value fields in kwargs."),(0,r.kt)("h2",{id:"vertices-objects"},"Vertices Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class Vertices()\n")),(0,r.kt)("p",null,"Iterable over vertices in a graph."),(0,r.kt)("h3",{id:"is_valid-3"},"is","_","valid()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def is_valid() -> bool\n")),(0,r.kt)("p",null,"Check if ",(0,r.kt)("inlineCode",{parentName:"p"},"Vertices")," is in valid context and may be used."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  A ",(0,r.kt)("inlineCode",{parentName:"p"},"bool")," value depends on if the ",(0,r.kt)("inlineCode",{parentName:"p"},"Vertices")," is in valid context."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"vertices.is_valid()")),(0,r.kt)("h3",{id:"__iter__-1"},"_","_","iter","_","_"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def __iter__() -> typing.Iterable[Vertex]\n")),(0,r.kt)("p",null,"Iterate over vertices."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  Iterable list of ",(0,r.kt)("inlineCode",{parentName:"p"},"Vertex")," objects."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"InvalidContextError")," - If context is invalid."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"UnableToAllocateError")," - If unable to allocate an iterator or a vertex.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"for vertex in graph.vertices")),(0,r.kt)("h3",{id:"__contains__-1"},"_","_","contains","_","_"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def __contains__(vertex)\n")),(0,r.kt)("p",null,"Check if Vertices contain the given vertex."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"vertex")," - ",(0,r.kt)("inlineCode",{parentName:"li"},"Vertex")," to be checked if it is a part of graph ",(0,r.kt)("inlineCode",{parentName:"li"},"Vertices"),".")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  Bool value depends if there is ",(0,r.kt)("inlineCode",{parentName:"p"},"Vertex")," in graph ",(0,r.kt)("inlineCode",{parentName:"p"},"Vertices"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"UnableToAllocateError")," - If unable to allocate the vertex.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"if vertex in graph.vertices:")),(0,r.kt)("h3",{id:"__len__-1"},"_","_","len","_","_"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def __len__()\n")),(0,r.kt)("p",null,"Get the number of vertices."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  A number of vertices in the graph."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"InvalidContextError")," - If context is invalid."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"UnableToAllocateError")," - If unable to allocate an iterator or a vertex.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"len(graph.vertices)")),(0,r.kt)("h2",{id:"graph-objects"},"Graph Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class Graph()\n")),(0,r.kt)("p",null,"State of the graph database in current ProcCtx."),(0,r.kt)("h3",{id:"is_valid-4"},"is","_","valid()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def is_valid() -> bool\n")),(0,r.kt)("p",null,"Check if ",(0,r.kt)("inlineCode",{parentName:"p"},"graph")," is in a valid context and may be used."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  A ",(0,r.kt)("inlineCode",{parentName:"p"},"bool")," value depends on if the ",(0,r.kt)("inlineCode",{parentName:"p"},"graph")," is in a valid context."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"graph.is_valid()")),(0,r.kt)("h3",{id:"get_vertex_by_id"},"get","_","vertex","_","by","_","id()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def get_vertex_by_id(vertex_id: VertexId) -> Vertex\n")),(0,r.kt)("p",null,"Return the Vertex corresponding to the given vertex_id from the graph. When the first parameter to a procedure is a projected graph, the vertex must also exist in the projected graph."),(0,r.kt)("p",null,"Access to a Vertex is only valid during a single execution of a\nprocedure in a query. You should not globally store the returned\nVertex."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"vertex_id")," - Memgraph Vertex ID")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"Vertex"),"corresponding to ",(0,r.kt)("inlineCode",{parentName:"p"},"vertex_id")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"IndexError")," - If unable to find the given vertex_id."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"InvalidContextError")," - If context is invalid.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"graph.get_vertex_by_id(vertex_id)")),(0,r.kt)("h3",{id:"vertices-1"},"vertices"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"@property\ndef vertices() -> Vertices\n")),(0,r.kt)("p",null,"Get all vertices in the graph."),(0,r.kt)("p",null,"Access to a Vertex is only valid during a single execution of a\nprocedure in a query. You should not globally store the returned Vertex\ninstances."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"Vertices")," that contained in the graph."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"InvalidContextError")," - If context is invalid.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("p",null,"  Iteration over all graph ",(0,r.kt)("inlineCode",{parentName:"p"},"Vertices"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"graph = context.graph\nfor vertex in graph.vertices:\n")),(0,r.kt)("h3",{id:"is_mutable"},"is","_","mutable()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def is_mutable() -> bool\n")),(0,r.kt)("p",null,"Check if the graph is mutable. Thus it can be used to modify vertices and edges."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  A ",(0,r.kt)("inlineCode",{parentName:"p"},"bool")," value that depends if the graph is mutable or not."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"graph.is_mutable()")),(0,r.kt)("h3",{id:"create_vertex"},"create","_","vertex()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def create_vertex() -> Vertex\n")),(0,r.kt)("p",null,"Create an empty vertex. When the first parameter to a procedure is a projected graph, the vertex is also added to the projected graph view."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  Created ",(0,r.kt)("inlineCode",{parentName:"p"},"Vertex"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ImmutableObjectError")," - If ",(0,r.kt)("inlineCode",{parentName:"li"},"graph")," is immutable."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"UnableToAllocateError")," - If unable to allocate a vertex.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples")),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"vertex = graph.create_vertex()")),(0,r.kt)("h3",{id:"delete_vertex"},"delete","_","vertex()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def delete_vertex(vertex: Vertex) -> None\n")),(0,r.kt)("p",null,"Delete a vertex if there are no edges. When the first parameter to a procedure is a projected graph, the vertex must also exist in the projected graph."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"vertex")," - ",(0,r.kt)("inlineCode",{parentName:"li"},"Vertex")," to be deleted")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ImmutableObjectError")," - If ",(0,r.kt)("inlineCode",{parentName:"li"},"graph")," is immutable."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"LogicErrorError")," - If ",(0,r.kt)("inlineCode",{parentName:"li"},"vertex")," has edges."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"SerializationError")," - If ",(0,r.kt)("inlineCode",{parentName:"li"},"vertex")," has been modified by another transaction.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"graph.delete_vertex(vertex)")),(0,r.kt)("h3",{id:"detach_delete_vertex"},"detach","_","delete","_","vertex()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def detach_delete_vertex(vertex: Vertex) -> None\n")),(0,r.kt)("p",null,"Delete a vertex and all of its edges. When the first parameter to a procedure is a projected graph, such an operation is not possible. "),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"vertex")," - ",(0,r.kt)("inlineCode",{parentName:"li"},"Vertex")," to be deleted with all of its edges")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ImmutableObjectError")," - If ",(0,r.kt)("inlineCode",{parentName:"li"},"graph")," is immutable."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"SerializationError")," - If ",(0,r.kt)("inlineCode",{parentName:"li"},"vertex")," has been modified by another transaction.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"graph.detach_delete_vertex(vertex)")),(0,r.kt)("h3",{id:"create_edge"},"create","_","edge()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def create_edge(from_vertex: Vertex, to_vertex: Vertex,\n                edge_type: EdgeType) -> Edge\n")),(0,r.kt)("p",null,"Create an edge. When the first parameter is a projected graph, it will create a new directed edge with a specified label only if both vertices are a part of the projected graph."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  Created ",(0,r.kt)("inlineCode",{parentName:"p"},"Edge"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"from_vertex")," - ",(0,r.kt)("inlineCode",{parentName:"li"},"Vertex")," from where edge is directed."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"to_vertex")," - ",(0,r.kt)("inlineCode",{parentName:"li"},"Vertex"),"  to where edge is directed."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"edge_type")," - ",(0,r.kt)("inlineCode",{parentName:"li"},"EdgeType")," defines the type of edge.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ImmutableObjectError")," - If ",(0,r.kt)("inlineCode",{parentName:"li"},"graph")," is immutable."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"UnableToAllocateError")," - If unable to allocate an edge."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"DeletedObjectError")," - If ",(0,r.kt)("inlineCode",{parentName:"li"},"from_vertex")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"to_vertex")," has been deleted."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"SerializationError")," - If ",(0,r.kt)("inlineCode",{parentName:"li"},"from_vertex")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"to_vertex")," has been modified by another transaction.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"edge = graph.create_edge(from_vertex, vertex, edge_type)")),(0,r.kt)("h3",{id:"delete_edge"},"delete","_","edge()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def delete_edge(edge: Edge) -> None\n")),(0,r.kt)("p",null,"Delete an edge. When the first parameter to a procedure is a projected graph, the edge must also exist in the projected graph."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"edge")," - ",(0,r.kt)("inlineCode",{parentName:"li"},"Edge")," to be deleted")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"ImmutableObjectError: If ",(0,r.kt)("inlineCode",{parentName:"li"},"graph")," is immutable."),(0,r.kt)("li",{parentName:"ul"},"Raise SerializationError: If ",(0,r.kt)("inlineCode",{parentName:"li"},"edge"),", its source or destination vertex has been modified by another transaction.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples")),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"graph.delete_edge(edge)")),(0,r.kt)("h2",{id:"aborterror-objects"},"AbortError Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class AbortError(Exception)\n")),(0,r.kt)("p",null,"Signals that the procedure was asked to abort its execution."),(0,r.kt)("h2",{id:"procctx-objects"},"ProcCtx Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class ProcCtx()\n")),(0,r.kt)("p",null,"Context of a procedure being executed."),(0,r.kt)("p",null,"Access to a ProcCtx is only valid during a single execution of a procedure\nin a query. You should not globally store a ProcCtx instance."),(0,r.kt)("h3",{id:"graph"},"graph"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"@property\ndef graph() -> Graph\n")),(0,r.kt)("p",null,"Access to ",(0,r.kt)("inlineCode",{parentName:"p"},"Graph")," object."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  Graph object."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"InvalidContextError")," - If context is invalid.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples"),":"),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},"context.graph")),(0,r.kt)("h2",{id:"logger-objects"},"Logger Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class Logger()\n")),(0,r.kt)("p",null,"Class for logging."),(0,r.kt)("h3",{id:"info"},"info()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def info(out: str) -> None\n")),(0,r.kt)("p",null,"Logs a message ",(0,r.kt)("inlineCode",{parentName:"p"},"out")," on ",(0,r.kt)("inlineCode",{parentName:"p"},"INFO")," log level."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"out")," - ",(0,r.kt)("inlineCode",{parentName:"li"},"str")," to be logged")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples")),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},'logger.info("message")')),(0,r.kt)("h3",{id:"debug"},"debug()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def debug(out: str) -> None\n")),(0,r.kt)("p",null,"Logs a message ",(0,r.kt)("inlineCode",{parentName:"p"},"out")," on ",(0,r.kt)("inlineCode",{parentName:"p"},"DEBUG")," log level."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"out")," - ",(0,r.kt)("inlineCode",{parentName:"li"},"str")," to be logged")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples")),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},'logger.debug("message")')),(0,r.kt)("h3",{id:"error"},"error()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def error(out: str) -> None\n")),(0,r.kt)("p",null,"Logs a message ",(0,r.kt)("inlineCode",{parentName:"p"},"out")," on ",(0,r.kt)("inlineCode",{parentName:"p"},"ERROR")," log level."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"out")," - ",(0,r.kt)("inlineCode",{parentName:"li"},"str")," to be logged")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples")),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},'logger.error("message")')),(0,r.kt)("h3",{id:"trace"},"trace()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def trace(out: str) -> None\n")),(0,r.kt)("p",null,"Logs a message ",(0,r.kt)("inlineCode",{parentName:"p"},"out")," on ",(0,r.kt)("inlineCode",{parentName:"p"},"TRACE")," log level."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"out")," - ",(0,r.kt)("inlineCode",{parentName:"li"},"str")," to be logged")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples")),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},'logger.trace("message")')),(0,r.kt)("h3",{id:"warning"},"warning()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def warning(out: str) -> None\n")),(0,r.kt)("p",null,"Logs a message ",(0,r.kt)("inlineCode",{parentName:"p"},"out")," on ",(0,r.kt)("inlineCode",{parentName:"p"},"WARNING")," log level."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"out")," - ",(0,r.kt)("inlineCode",{parentName:"li"},"str")," to be logged")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples")),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},'logger.warning("message")')),(0,r.kt)("h3",{id:"critical"},"critical()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def critical(out: str) -> None\n")),(0,r.kt)("p",null,"Logs a message ",(0,r.kt)("inlineCode",{parentName:"p"},"out")," on ",(0,r.kt)("inlineCode",{parentName:"p"},"CRITICAL")," log level."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"out")," - ",(0,r.kt)("inlineCode",{parentName:"li"},"str")," to be logged")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples")),(0,r.kt)("p",null,"  ",(0,r.kt)("inlineCode",{parentName:"p"},'logger.critical("message")')),(0,r.kt)("h2",{id:"unsupportedtypingerror-objects"},"UnsupportedTypingError Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class UnsupportedTypingError(Exception)\n")),(0,r.kt)("p",null,"Signals a typing annotation is not supported as a _mgp.CypherType."),(0,r.kt)("h2",{id:"deprecated-objects"},"Deprecated Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class Deprecated()\n")),(0,r.kt)("p",null,"Annotate a resulting Record","'","s field as deprecated."),(0,r.kt)("h3",{id:"read_proc"},"read","_","proc()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def read_proc(func: typing.Callable[..., Record])\n")),(0,r.kt)("p",null,"Register ",(0,r.kt)("inlineCode",{parentName:"p"},"func")," as a read-only procedure of the current module."),(0,r.kt)("p",null,"The decorator ",(0,r.kt)("inlineCode",{parentName:"p"},"read_proc")," is meant to be used to register module procedures.\nThe registered ",(0,r.kt)("inlineCode",{parentName:"p"},"func")," needs to be a callable which optionally takes\n",(0,r.kt)("inlineCode",{parentName:"p"},"ProcCtx")," as its first argument. Other arguments of ",(0,r.kt)("inlineCode",{parentName:"p"},"func")," will be bound to\nvalues passed in the cypherQuery. The full signature of ",(0,r.kt)("inlineCode",{parentName:"p"},"func")," needs to be\nannotated with types. The return type must be ",(0,r.kt)("inlineCode",{parentName:"p"},"Record(field_name=type, ...)"),"\nand the procedure must produce either a complete Record or None. To mark a\nfield as deprecated, use ",(0,r.kt)("inlineCode",{parentName:"p"},"Record(field_name=Deprecated(type), ...)"),".\nMultiple records can be produced by returning an iterable of them.\nRegistering generator functions is currently not supported."),(0,r.kt)("h3",{id:"write_proc"},"write","_","proc()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def write_proc(func: typing.Callable[..., Record])\n")),(0,r.kt)("p",null,"Register ",(0,r.kt)("inlineCode",{parentName:"p"},"func")," as a writeable procedure of the current module."),(0,r.kt)("p",null,"The decorator ",(0,r.kt)("inlineCode",{parentName:"p"},"write_proc")," is meant to be used to register module\nprocedures. The registered ",(0,r.kt)("inlineCode",{parentName:"p"},"func")," needs to be a callable which optionally\ntakes ",(0,r.kt)("inlineCode",{parentName:"p"},"ProcCtx")," as the first argument. Other arguments of ",(0,r.kt)("inlineCode",{parentName:"p"},"func")," will be\nbound to values passed in the cypherQuery. The full signature of ",(0,r.kt)("inlineCode",{parentName:"p"},"func"),"\nneeds to be annotated with types. The return type must be\n",(0,r.kt)("inlineCode",{parentName:"p"},"Record(field_name=type, ...)")," and the procedure must produce either a\ncomplete Record or None. To mark a field as deprecated, use\n",(0,r.kt)("inlineCode",{parentName:"p"},"Record(field_name=Deprecated(type), ...)"),". Multiple records can be produced\nby returning an iterable of them. Registering generator functions is\ncurrently not supported."),(0,r.kt)("h2",{id:"invalidmessageerror-objects"},"InvalidMessageError Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class InvalidMessageError(Exception)\n")),(0,r.kt)("p",null,"Signals using a message instance outside of the registered transformation."),(0,r.kt)("h2",{id:"message-objects"},"Message Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class Message()\n")),(0,r.kt)("p",null,"Represents a message from a stream."),(0,r.kt)("h3",{id:"is_valid-5"},"is","_","valid()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def is_valid() -> bool\n")),(0,r.kt)("p",null,"Return True if ",(0,r.kt)("inlineCode",{parentName:"p"},"self")," is in valid context and may be used."),(0,r.kt)("h3",{id:"source_type"},"source","_","type()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def source_type() -> str\n")),(0,r.kt)("p",null,"Supported in all stream sources"),(0,r.kt)("p",null,"Raise InvalidArgumentError if the message is from an unsupported stream source."),(0,r.kt)("h3",{id:"payload"},"payload()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def payload() -> bytes\n")),(0,r.kt)("p",null,"Supported stream sources:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Kafka"),(0,r.kt)("li",{parentName:"ul"},"Pulsar")),(0,r.kt)("p",null,"Raise InvalidArgumentError if the message is from an unsupported stream source."),(0,r.kt)("h3",{id:"topic_name"},"topic","_","name()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def topic_name() -> str\n")),(0,r.kt)("p",null,"Supported stream sources:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Kafka"),(0,r.kt)("li",{parentName:"ul"},"Pulsar")),(0,r.kt)("p",null,"Raise InvalidArgumentError if the message is from an unsupported stream source."),(0,r.kt)("h3",{id:"key"},"key()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def key() -> bytes\n")),(0,r.kt)("p",null,"Supported stream sources:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Kafka")),(0,r.kt)("p",null,"Raise InvalidArgumentError if the message is from an unsupported stream source."),(0,r.kt)("h3",{id:"timestamp"},"timestamp()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def timestamp() -> int\n")),(0,r.kt)("p",null,"Supported stream sources:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Kafka")),(0,r.kt)("p",null,"Raise InvalidArgumentError if the message is from an unsupported stream source."),(0,r.kt)("h3",{id:"offset"},"offset()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def offset() -> int\n")),(0,r.kt)("p",null,"Supported stream sources:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Kafka")),(0,r.kt)("p",null,"Raise InvalidArgumentError if the message is from an unsupported stream source."),(0,r.kt)("h2",{id:"invalidmessageserror-objects"},"InvalidMessagesError Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class InvalidMessagesError(Exception)\n")),(0,r.kt)("p",null,"Signals using a messages instance outside of the registered transformation."),(0,r.kt)("h2",{id:"messages-objects"},"Messages Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class Messages()\n")),(0,r.kt)("p",null,"Represents a list of messages from a stream."),(0,r.kt)("h3",{id:"is_valid-6"},"is","_","valid()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def is_valid() -> bool\n")),(0,r.kt)("p",null,"Return True if ",(0,r.kt)("inlineCode",{parentName:"p"},"self")," is in valid context and may be used."),(0,r.kt)("h3",{id:"message_at"},"message","_","at()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def message_at(id: int) -> Message\n")),(0,r.kt)("p",null,"Raise InvalidMessagesError if context is invalid."),(0,r.kt)("h3",{id:"total_messages"},"total","_","messages()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def total_messages() -> int\n")),(0,r.kt)("p",null,"Raise InvalidContextError if context is invalid."),(0,r.kt)("h2",{id:"transctx-objects"},"TransCtx Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class TransCtx()\n")),(0,r.kt)("p",null,"Context of a transformation being executed."),(0,r.kt)("p",null,"Access to a TransCtx is only valid during a single execution of a transformation.\nYou should not globally store a TransCtx instance."),(0,r.kt)("h3",{id:"graph-1"},"graph"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"@property\ndef graph() -> Graph\n")),(0,r.kt)("p",null,"Raise InvalidContextError if context is invalid."),(0,r.kt)("h2",{id:"funcctx-objects"},"FuncCtx Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class FuncCtx()\n")),(0,r.kt)("p",null,"Context of a function being executed."),(0,r.kt)("p",null,"Access to a FuncCtx is only valid during a single execution of a function in\na query. You should not globally store a FuncCtx instance. The graph object\nwithin the FuncCtx is not mutable."),(0,r.kt)("h3",{id:"function"},"function()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def function(func: typing.Callable)\n")),(0,r.kt)("p",null,"Register ",(0,r.kt)("inlineCode",{parentName:"p"},"func")," as a user-defined function in the current module."),(0,r.kt)("p",null,"The decorator ",(0,r.kt)("inlineCode",{parentName:"p"},"function")," is meant to be used to register module functions.\nThe registered ",(0,r.kt)("inlineCode",{parentName:"p"},"func")," needs to be a callable which optionally takes\n",(0,r.kt)("inlineCode",{parentName:"p"},"FuncCtx")," as its first argument. Other arguments of ",(0,r.kt)("inlineCode",{parentName:"p"},"func")," will be bound to\nvalues passed in the Cypher query. Only the function arguments need to be\nannotated with types. The return type doesn","'","t need to be specified, but it\nhas to be supported by ",(0,r.kt)("inlineCode",{parentName:"p"},"mgp.Any"),". Registering generator functions is\ncurrently not supported."),(0,r.kt)("h2",{id:"invalidcontexterror-objects"},"InvalidContextError Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class InvalidContextError(Exception)\n")),(0,r.kt)("p",null,"Signals using a graph element instance outside of the registered procedure."),(0,r.kt)("h2",{id:"unknownerror-objects"},"UnknownError Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class UnknownError(_mgp.UnknownError)\n")),(0,r.kt)("p",null,"Signals unspecified failure."),(0,r.kt)("h2",{id:"unabletoallocateerror-objects"},"UnableToAllocateError Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class UnableToAllocateError(_mgp.UnableToAllocateError)\n")),(0,r.kt)("p",null,"Signals failed memory allocation."),(0,r.kt)("h2",{id:"insufficientbuffererror-objects"},"InsufficientBufferError Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class InsufficientBufferError(_mgp.InsufficientBufferError)\n")),(0,r.kt)("p",null,"Signals that some buffer is not big enough."),(0,r.kt)("h2",{id:"outofrangeerror-objects"},"OutOfRangeError Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class OutOfRangeError(_mgp.OutOfRangeError)\n")),(0,r.kt)("p",null,"Signals that an index-like parameter has a value that is outside its\npossible values."),(0,r.kt)("h2",{id:"logicerrorerror-objects"},"LogicErrorError Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class LogicErrorError(_mgp.LogicErrorError)\n")),(0,r.kt)("p",null,"Signals faulty logic within the program such as violating logical\npreconditions or class invariants and may be preventable."),(0,r.kt)("h2",{id:"deletedobjecterror-objects"},"DeletedObjectError Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class DeletedObjectError(_mgp.DeletedObjectError)\n")),(0,r.kt)("p",null,"Signals accessing an already deleted object."),(0,r.kt)("h2",{id:"invalidargumenterror-objects"},"InvalidArgumentError Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class InvalidArgumentError(_mgp.InvalidArgumentError)\n")),(0,r.kt)("p",null,"Signals that some of the arguments have invalid values."),(0,r.kt)("h2",{id:"keyalreadyexistserror-objects"},"KeyAlreadyExistsError Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class KeyAlreadyExistsError(_mgp.KeyAlreadyExistsError)\n")),(0,r.kt)("p",null,"Signals that a key already exists in a container-like object."),(0,r.kt)("h2",{id:"immutableobjecterror-objects"},"ImmutableObjectError Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class ImmutableObjectError(_mgp.ImmutableObjectError)\n")),(0,r.kt)("p",null,"Signals modification of an immutable object."),(0,r.kt)("h2",{id:"valueconversionerror-objects"},"ValueConversionError Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class ValueConversionError(_mgp.ValueConversionError)\n")),(0,r.kt)("p",null,"Signals that the conversion failed between python and cypher values."),(0,r.kt)("h2",{id:"serializationerror-objects"},"SerializationError Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class SerializationError(_mgp.SerializationError)\n")),(0,r.kt)("p",null,"Signals serialization error caused by concurrent modifications from\ndifferent transactions."),(0,r.kt)("h2",{id:"authorizationerror-objects"},"AuthorizationError Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class AuthorizationError(_mgp.AuthorizationError)\n")),(0,r.kt)("p",null,"Signals that the user doesn't have sufficient permissions to perform\nprocedure call."))}d.isMDXComponent=!0}}]);