"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[13089],{3905:function(e,t,a){a.d(t,{Zo:function(){return m},kt:function(){return c}});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var p=n.createContext({}),s=function(e){var t=n.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},m=function(e){var t=s(e.components);return n.createElement(p.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),u=s(a),c=r,h=u["".concat(p,".").concat(c)]||u[c]||d[c]||i;return a?n.createElement(h,o(o({ref:t},m),{},{components:a})):n.createElement(h,o({ref:t},m))}));function c(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=u;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var s=2;s<i;s++)o[s]=a[s];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},14892:function(e,t,a){a.r(t),a.d(t,{assets:function(){return m},contentTitle:function(){return p},default:function(){return c},frontMatter:function(){return l},metadata:function(){return s},toc:function(){return d}});var n=a(87462),r=a(63366),i=(a(67294),a(3905)),o=["components"],l={id:"storage",title:"Storage memory usage",sidebar_label:"Storage memory usage"},p=void 0,s={unversionedId:"under-the-hood/storage",id:"under-the-hood/storage",title:"Storage memory usage",description:"Estimating Memgraph's storage memory usage is not entirely straightforward",source:"@site/docs/under-the-hood/storage.md",sourceDirName:"under-the-hood",slug:"/under-the-hood/storage",permalink:"/docs/memgraph/next/under-the-hood/storage",editUrl:"https://github.com/memgraph/docs/tree/master/docs/under-the-hood/storage.md",tags:[],version:"current",frontMatter:{id:"storage",title:"Storage memory usage",sidebar_label:"Storage memory usage"},sidebar:"memgraph",previous:{title:"Under the hood",permalink:"/docs/memgraph/next/under-the-hood"},next:{title:"Indexing",permalink:"/docs/memgraph/next/under-the-hood/indexing"}},m={},d=[{value:"The calculation in detail",id:"the-calculation-in-detail",level:2},{value:"<code>Delta</code> memory layout",id:"delta-memory-layout",level:3},{value:"<code>Vertex</code> memory layout",id:"vertex-memory-layout",level:3},{value:"<code>Edge</code> memory layout",id:"edge-memory-layout",level:3},{value:"<code>SkipList</code> memory layout",id:"skiplist-memory-layout",level:3},{value:"Index memory layout",id:"index-memory-layout",level:3},{value:"Each index object in total",id:"each-index-object-in-total",level:4},{value:"Properties",id:"properties",level:3},{value:"Marvel dataset use case",id:"marvel-dataset-use-case",level:3},{value:"Query Execution memory Usage",id:"query-execution-memory-usage",level:2}],u={toc:d};function c(e){var t=e.components,l=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,n.Z)({},u,l,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Estimating Memgraph's storage memory usage is not entirely straightforward\nbecause it depends on a lot of variables, but it is possible to do so quite\naccurately. Below is an example that will try to show the basic reasoning."),(0,i.kt)("p",null,"If you want to ",(0,i.kt)("strong",{parentName:"p"},"estimate")," the storage memory usage, use the following formula:"),(0,i.kt)("p",null,"$\\texttt{StorageRAMUsage} = \\texttt{NumberOfVertices} \\times 260\\text{B} + \\texttt{NumberOfEdges} \\times 180\\text{B}$"),(0,i.kt)("p",null,"Let's test this formula on the ",(0,i.kt)("a",{parentName:"p",href:"https://memgraph.com/download/datasets/marvel-cinematic-universe/marvel-cinematic-universe.cypherl.gz"},"Marvel Comic Universe Social Network\ndataset"),",\nwhich is also available as a dataset inside Memgraph Lab and contains 21,723\nvertices and 682,943 edges. "),(0,i.kt)("p",null,"According to the formula, storage memory usage should be: "),(0,i.kt)("p",null,"$\n\\begin{aligned}\n\\texttt{StorageRAMUsage} &= 21,723 \\times 260\\text{B} + 682,943 \\times 180\\text{B} ","\\"," &= 5,647,980\\text{B} + 122,929,740\\text{B}","\\"," &= 128,577,720\\text{B} \\approx 125\\text{MB}\n\\end{aligned}\n$"),(0,i.kt)("p",null,"Now, let's run an empty Memgraph instance on a x86 Ubuntu. It consumes ",(0,i.kt)("strong",{parentName:"p"},"~75MB"),"\nof RAM due to baseline runtime overhead. Once the dataset is loaded, RAM usage\nrises up to ",(0,i.kt)("strong",{parentName:"p"},"~260MB"),". Memory usage primarily consists of storage and query\nexecution memory usage. After executing ",(0,i.kt)("inlineCode",{parentName:"p"},"FREE MEMORY")," query to force the cleanup\nof query execution, the RAM usage drops to ",(0,i.kt)("strong",{parentName:"p"},"~200MB"),". If the baseline runtime\noverhead of ",(0,i.kt)("strong",{parentName:"p"},"75MB")," is subtracted from the total memory usage of the dataset,\nwhich is ",(0,i.kt)("strong",{parentName:"p"},"200MB"),", and storage memory usage comes up to ",(0,i.kt)("strong",{parentName:"p"},"~125MB"),", which shows\nthat the formula is correct."),(0,i.kt)("h2",{id:"the-calculation-in-detail"},"The calculation in detail"),(0,i.kt)("p",null,"Let's dive deeper into the memory usage values. Because Memgraph works on the\nx86 architecture, calculations are based on the x86 Linux memory usage."),(0,i.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"For the latest and most precise memory layout please clone\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/memgraph/memgraph"},"Memgraph")," and use, e.g.,\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/PhilArmstrong/pahole-gdb"},"pahole")," to discover accurate\ninformation. "))),(0,i.kt)("p",null,"Each\xa0",(0,i.kt)("inlineCode",{parentName:"p"},"Vertex"),"\xa0and\xa0",(0,i.kt)("inlineCode",{parentName:"p"},"Edge"),"\xa0object has a pointer to\xa0a ",(0,i.kt)("inlineCode",{parentName:"p"},"Delta"),"\xa0object.\xa0The\n",(0,i.kt)("inlineCode",{parentName:"p"},"Delta"),"\xa0object stores all changes on a certain\xa0",(0,i.kt)("inlineCode",{parentName:"p"},"Vertex"),"\xa0or\xa0",(0,i.kt)("inlineCode",{parentName:"p"},"Edge"),"\xa0and that's\nwhy\xa0",(0,i.kt)("inlineCode",{parentName:"p"},"Vertex"),"\xa0and\xa0",(0,i.kt)("inlineCode",{parentName:"p"},"Edge"),"\xa0memory usage will be increased by the memory of\nthe\xa0",(0,i.kt)("inlineCode",{parentName:"p"},"Delta"),"\xa0objects they are pointing to. If there are few updates, there are\nalso few\xa0",(0,i.kt)("inlineCode",{parentName:"p"},"Delta"),"\xa0objects because the latest data is stored in the object.\nBut, if the database has a lot of concurrent operations, many\xa0",(0,i.kt)("inlineCode",{parentName:"p"},"Delta"),"\xa0objects\nwill be created. Of course, the\xa0",(0,i.kt)("inlineCode",{parentName:"p"},"Delta"),"\xa0objects will be kept in memory as long as\nneeded, and a bit more, because of the internal GC inefficiencies."),(0,i.kt)("h3",{id:"delta-memory-layout"},(0,i.kt)("inlineCode",{parentName:"h3"},"Delta")," memory layout"),(0,i.kt)("p",null,"Each ",(0,i.kt)("inlineCode",{parentName:"p"},"Delta")," object has a least ",(0,i.kt)("strong",{parentName:"p"},"104B"),"."),(0,i.kt)("h3",{id:"vertex-memory-layout"},(0,i.kt)("inlineCode",{parentName:"h3"},"Vertex")," memory layout"),(0,i.kt)("p",null,"Each ",(0,i.kt)("inlineCode",{parentName:"p"},"Vertex")," object has at least ",(0,i.kt)("strong",{parentName:"p"},"112B")," + ",(0,i.kt)("strong",{parentName:"p"},"104B")," for the ",(0,i.kt)("inlineCode",{parentName:"p"},"Delta")," object, in\ntotal, a minimum of ",(0,i.kt)("strong",{parentName:"p"},"216B"),"."),(0,i.kt)("h3",{id:"edge-memory-layout"},(0,i.kt)("inlineCode",{parentName:"h3"},"Edge")," memory layout"),(0,i.kt)("p",null,"Each ",(0,i.kt)("inlineCode",{parentName:"p"},"Edge")," object has at least ",(0,i.kt)("strong",{parentName:"p"},"40B")," + ",(0,i.kt)("strong",{parentName:"p"},"104B")," for the ",(0,i.kt)("inlineCode",{parentName:"p"},"Delta")," object, in\ntotal, a minimum of ",(0,i.kt)("strong",{parentName:"p"},"144B"),"."),(0,i.kt)("h3",{id:"skiplist-memory-layout"},(0,i.kt)("inlineCode",{parentName:"h3"},"SkipList")," memory layout"),(0,i.kt)("p",null,"Each object (",(0,i.kt)("inlineCode",{parentName:"p"},"Vertex"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Edge"),") is placed inside a data structure\ncalled a ",(0,i.kt)("inlineCode",{parentName:"p"},"SkipList"),". The ",(0,i.kt)("inlineCode",{parentName:"p"},"SkipList")," has an additional overhead in terms of\n",(0,i.kt)("inlineCode",{parentName:"p"},"SkipListNode")," structure and ",(0,i.kt)("inlineCode",{parentName:"p"},"next_pointers"),". Each ",(0,i.kt)("inlineCode",{parentName:"p"},"SkipListNode")," has an\nadditional ",(0,i.kt)("strong",{parentName:"p"},"8B")," element overhead and another ",(0,i.kt)("strong",{parentName:"p"},"8B")," for each of the ",(0,i.kt)("inlineCode",{parentName:"p"},"next_pointers"),"."),(0,i.kt)("p",null,"It is impossible to know the exact number of ",(0,i.kt)("strong",{parentName:"p"},"next_pointers")," upfront, and\nconsequently the total size, but it's never more than ",(0,i.kt)("strong",{parentName:"p"},"double the number of\nobjects")," because the number of pointers is generated by binomial distribution\n(take a look at ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/memgraph/memgraph/blob/master/src/utils/skip_list.hpp"},"the source\ncode"),"\nfor details)."),(0,i.kt)("h3",{id:"index-memory-layout"},"Index memory layout"),(0,i.kt)("p",null,"Each ",(0,i.kt)("inlineCode",{parentName:"p"},"LabelIndex::Entry")," object has exactly ",(0,i.kt)("strong",{parentName:"p"},"16B"),"."),(0,i.kt)("p",null,"Depending on the actual value stored, each ",(0,i.kt)("inlineCode",{parentName:"p"},"LabelPropertyIndex::Entry")," has at least ",(0,i.kt)("strong",{parentName:"p"},"72B"),"."),(0,i.kt)("p",null,"Objects of both types are placed into the ",(0,i.kt)("inlineCode",{parentName:"p"},"SkipList"),"."),(0,i.kt)("h4",{id:"each-index-object-in-total"},"Each index object in total"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"SkipListNode<LabelIndex::Entry>")," object has ",(0,i.kt)("strong",{parentName:"li"},"24B"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"SkipListNode<LabelPropertyIndex::Entry>")," has at least ",(0,i.kt)("strong",{parentName:"li"},"80B"),"."),(0,i.kt)("li",{parentName:"ul"},"Each ",(0,i.kt)("inlineCode",{parentName:"li"},"SkipListNode")," has an additional ",(0,i.kt)("strong",{parentName:"li"},"16B")," because of the ",(0,i.kt)("strong",{parentName:"li"},"next_pointers"),".")),(0,i.kt)("h3",{id:"properties"},"Properties"),(0,i.kt)("p",null,"All properties use ",(0,i.kt)("strong",{parentName:"p"},"1B")," for metadata - type, size of property ID and the size\nof payload in the case of ",(0,i.kt)("inlineCode",{parentName:"p"},"NULL")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"BOOLEAN")," values, or size of payload size\nindicator for other types (how big is the stored value, for example, integers\ncan be 1B, 2B 4B or 8b depending on their value). "),(0,i.kt)("p",null,"Then they take up ",(0,i.kt)("strong",{parentName:"p"},"another byte")," for storing property ID, which means each\nproperty takes up at least 2B. After those 2B, some properties (for example,\n",(0,i.kt)("inlineCode",{parentName:"p"},"STRING")," values) store addition metadata. And lastly, all properties store the\nvalue. So the layout of each property is:"),(0,i.kt)("p",null,"$\\texttt{propertySize} = \\texttt{basicMetadata} + \\texttt{propertyID} + ","[\\texttt{additionalMetadata}]"," + \\texttt{value}.$"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Value type"),(0,i.kt)("th",{parentName:"tr",align:null},"Size"),(0,i.kt)("th",{parentName:"tr",align:null},"Note"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"NULL")),(0,i.kt)("td",{parentName:"tr",align:null},"1B + 1B"),(0,i.kt)("td",{parentName:"tr",align:null},"The value is written in the first byte of the basic metadata.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"BOOL")),(0,i.kt)("td",{parentName:"tr",align:null},"1B + 1B"),(0,i.kt)("td",{parentName:"tr",align:null},"The value is written in the first byte of the basic metadata.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"INT")),(0,i.kt)("td",{parentName:"tr",align:null},"1B + 1B + 1B, 2B, 4B or 8B"),(0,i.kt)("td",{parentName:"tr",align:null},"Basic metadata, property ID and the value depending on the size of the integer.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"DOUBLE")),(0,i.kt)("td",{parentName:"tr",align:null},"1B + 1B + 8B"),(0,i.kt)("td",{parentName:"tr",align:null},"Basic metadata, property ID and the value")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"STRING")),(0,i.kt)("td",{parentName:"tr",align:null},"1B + 1B + 1B + min 1B"),(0,i.kt)("td",{parentName:"tr",align:null},"Basic metadata, property ID, additional metadata and lastly the value depending on the size of the string, where 1 ASCII character in the string takes up 1B.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"LIST")),(0,i.kt)("td",{parentName:"tr",align:null},"1B + 1B + 1B + min 1B"),(0,i.kt)("td",{parentName:"tr",align:null},"Basic metadata, property ID, additional metadata and the total size depends on the number and size of the values in the list.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"MAP")),(0,i.kt)("td",{parentName:"tr",align:null},"1B + 1B + 1B + min 1B"),(0,i.kt)("td",{parentName:"tr",align:null},"Basic metadata, property ID, additional metadata and the total size depends on the number and size of the values in the map.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"TEMPORAL_DATA")),(0,i.kt)("td",{parentName:"tr",align:null},"1B + 1B + 1B + min 1B + min 1B"),(0,i.kt)("td",{parentName:"tr",align:null},"Basic metadata, property ID, additional metadata, seconds, microseconds. Value od the seconds and microseconds is at least 1B, but probably 4B in most cases due to the large values they store.")))),(0,i.kt)("h3",{id:"marvel-dataset-use-case"},"Marvel dataset use case"),(0,i.kt)("p",null,"The Marvel dataset consists of ",(0,i.kt)("inlineCode",{parentName:"p"},"Hero"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Comic")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"ComicSeries")," labels, which\nare indexed. There are also three label-property indices - on the ",(0,i.kt)("inlineCode",{parentName:"p"},"name"),"\nproperty of ",(0,i.kt)("inlineCode",{parentName:"p"},"Hero")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Comic")," vertices, and on the ",(0,i.kt)("inlineCode",{parentName:"p"},"title")," property of\n",(0,i.kt)("inlineCode",{parentName:"p"},"ComicSeries")," vertices. The ",(0,i.kt)("inlineCode",{parentName:"p"},"ComicSeries")," vertices also have the ",(0,i.kt)("inlineCode",{parentName:"p"},"publishYear"),"\nproperty."),(0,i.kt)("img",{src:a(86274).Z}),(0,i.kt)("p",null,"There are 6487 ",(0,i.kt)("inlineCode",{parentName:"p"},"Hero")," and 12,661 ",(0,i.kt)("inlineCode",{parentName:"p"},"Comic")," vertices with the property ",(0,i.kt)("inlineCode",{parentName:"p"},"name"),".\nThat's 19,148 vertices in total. To calculate how much storage those vertices\nand properties occupy, we are going to use the following formula:"),(0,i.kt)("p",null,"$\\texttt{NumberOfVertices} \\times (\\texttt{Vertex} + \\texttt{properties} + \\texttt{SkipListNode} + \\texttt{next","_","pointers} + \\texttt{Delta}).$"),(0,i.kt)("p",null,"Let's assume the name on average has $3\\text{B}+10\\text{B} = 13\\text{B}$ (each\nname is on average 10 characters long). One the average values are included, the\ncalculation is:"),(0,i.kt)("p",null,"$19,148 \\times (112\\text{B} + 13\\text{B} + 16\\text{B} + 16\\text{B} + 104\\text{B}) = 19,148 \\times 261\\text{B} = 4,997,628\\text{B}.$"),(0,i.kt)("p",null,"The remaining 2,584 vertices are the ",(0,i.kt)("inlineCode",{parentName:"p"},"ComicSeries")," vertices with the ",(0,i.kt)("inlineCode",{parentName:"p"},"title")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"publishYear")," properties. Let's assume that the ",(0,i.kt)("inlineCode",{parentName:"p"},"title")," property is\napproximately the same length as the ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," property. The ",(0,i.kt)("inlineCode",{parentName:"p"},"publishYear")," property\nis a list of integers. The average length of the ",(0,i.kt)("inlineCode",{parentName:"p"},"publishYear")," list is 2.17,\nlet's round it up to 3 elements. Since the year is an integer, 2B for each\ninteger will be more than enough, plus the 2B for the metadata. Therefore, each\nlist occupies $3 \\times 2\\text{B} \\times 2\\text{B} = 12\\text{B}$. Using the same\nformula as above, but being careful to include both ",(0,i.kt)("inlineCode",{parentName:"p"},"title")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"publishYear"),"\nproperties, the calculation is:"),(0,i.kt)("p",null,"$2584 \\times (112\\text{B} + 13\\text{B} + 12\\text{B} + 16\\text{B} + 16\\text{B} + 104\\text{B}) = 2584 \\times 273\\text{B} = 705,432\\text{B}.$"),(0,i.kt)("p",null,"In total, $5,703,060\\text{B}$ to store vertices."),(0,i.kt)("p",null,"The edges don't have any properties on them, so the formula is as follows:"),(0,i.kt)("p",null,"$\\texttt{NumberOfEdges} \\times (\\texttt{Edge} + \\texttt{SkipListNode} + \\texttt{next","_","pointers} + \\texttt{Delta}).$"),(0,i.kt)("p",null,"There are 682,943 edges in the Marvel dataset. Hence, we have:"),(0,i.kt)("p",null,"$682,943 \\times (40\\text{B}+16\\text{B}+16\\text{B}+104\\text{B}) = 682,943 \\times 176\\text{B} = 120,197,968\\text{B}.$"),(0,i.kt)("p",null,"Next, ",(0,i.kt)("inlineCode",{parentName:"p"},"Hero"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Comic")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"ComicSeries")," labels have label indices. To calculate\nhow much space they take up, use the following formula:"),(0,i.kt)("p",null,"$\\texttt{NumberOfLabelIndices} \\times \\texttt{NumberOfVertices} \\times (\\texttt{SkipListNode<LabelIndex::Entry>} + \\texttt{next","_","pointers}).$"),(0,i.kt)("p",null,"Since there are three label indices, we have the following calculation:"),(0,i.kt)("p",null,"$3 \\times 21,723 \\times (24\\text{B}+16\\text{B}) = 65,169 \\times 40\\text{B} = 2,606,760\\text{B}.$"),(0,i.kt)("p",null,"For label-property index, labeled property needs to be taken into account.\nProperty ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," is indexed on ",(0,i.kt)("inlineCode",{parentName:"p"},"Hero")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Comic")," vertices, while property\n",(0,i.kt)("inlineCode",{parentName:"p"},"title")," is indexed on ",(0,i.kt)("inlineCode",{parentName:"p"},"ComicSeries")," vertices. We already assumed that the\n",(0,i.kt)("inlineCode",{parentName:"p"},"title")," property is approximately the same length as the ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," property. "),(0,i.kt)("p",null,"Here is the formula:"),(0,i.kt)("p",null,"$\\texttt{NumberOfLabelPropertyIndices} \\times \\texttt{NumberOfVertices} \\times (\\texttt{SkipListNode<LabelIndex::Entry>} + \\texttt{property} + \\texttt{next","_","pointers}).$"),(0,i.kt)("p",null,"When the appropriate values are included, the calculation is:"),(0,i.kt)("p",null,"$3 \\times 21,723 \\times (80\\text{B}+13\\text{B}+16\\text{B})= 65,169 \\times 109\\text{B} = 7,103,421\\text{B}.$"),(0,i.kt)("p",null,"Now let's sum up everything we calculated:"),(0,i.kt)("p",null,"$5,703,060\\text{B} + 120,197,968\\text{B} + 2,606,760\\text{B} + 7,103,421\\text{B} = 135,611,209 \\text{B} \\approx 130\\text{MB}.$"),(0,i.kt)("p",null,"Bear in mind the number can vary because objects can have higher overhead due to\nthe additional data."),(0,i.kt)("h2",{id:"query-execution-memory-usage"},"Query Execution memory Usage"),(0,i.kt)("p",null,"Query execution also uses up RAM. In some cases, intermediate results are\naggregated to return valid query results and the query execution memory can end\nup using a large amount of RAM. Keep in mind that query execution memory\nmonotonically grows in size during the execution, and it's freed once the query\nexecution is done."),(0,i.kt)("h1",{id:"configuration-options-to-reduce-memory-usage"},"Configuration options to reduce memory usage"),(0,i.kt)("p",null,"Here are several tips how you can reduce memory usage and increase scalability:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Consider removing label index by executing ",(0,i.kt)("inlineCode",{parentName:"li"},"DROP INDEX ON :Label;")," "),(0,i.kt)("li",{parentName:"ol"},"Consider removing label-property index by executing ",(0,i.kt)("inlineCode",{parentName:"li"},"DROP INDEX\nON :Label(property);")," "),(0,i.kt)("li",{parentName:"ol"},"If you don't have properties on relationships, disable them in the\nconfiguration file by setting the ",(0,i.kt)("inlineCode",{parentName:"li"},"-storage-properties-on-edges")," flag to\n",(0,i.kt)("inlineCode",{parentName:"li"},"false"),". This can significantly reduce memory usage because effectively\n",(0,i.kt)("inlineCode",{parentName:"li"},"Edge")," objects will not be created, and all information will be inlined under\n",(0,i.kt)("inlineCode",{parentName:"li"},"Vertex")," objects. You can disable properties on relationships with a\nnon-empty database, if the relationships are without properties. If you need\nhelp with adapting the configuration to your needs, check out the the how-to\nguide on ",(0,i.kt)("a",{parentName:"li",href:"/docs/memgraph/next/how-to-guides/config-logs"},"changing configuration settings"),". ")),(0,i.kt)("p",null,"You can also check our reference guide for information about ",(0,i.kt)("a",{parentName:"p",href:"/docs/memgraph/next/reference-guide/memory-control"},"controlling memory\nusage"),", and you\n",(0,i.kt)("a",{parentName:"p",href:"/docs/memgraph/next/reference-guide/inspecting-queries"},"inspect")," and\n",(0,i.kt)("a",{parentName:"p",href:"/docs/memgraph/next/reference-guide/profiling-queries"},"profile")," your queries\nto devise a plan for their optimization."))}c.isMDXComponent=!0},86274:function(e,t,a){t.Z=a.p+"assets/images/marvel-dataset-schema-67ee0f7cee0d1be8f961455853efd61f.png"}}]);