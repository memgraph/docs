"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[52216],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return m}});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var p=r.createContext({}),s=function(e){var n=r.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=s(e.components);return r.createElement(p.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,p=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=s(t),m=a,h=d["".concat(p,".").concat(m)]||d[m]||u[m]||o;return t?r.createElement(h,i(i({ref:n},c),{},{components:t})):r.createElement(h,i({ref:n},c))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=d;var l={};for(var p in n)hasOwnProperty.call(n,p)&&(l[p]=n[p]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var s=2;s<o;s++)i[s]=t[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},70256:function(e,n,t){t.r(n),t.d(n,{assets:function(){return c},contentTitle:function(){return p},default:function(){return m},frontMatter:function(){return l},metadata:function(){return s},toc:function(){return u}});var r=t(87462),a=t(63366),o=(t(67294),t(3905)),i=["components"],l={id:"inspecting-queries",title:"Inspecting queries",sidebar_label:"Inspecting queries",slug:"/reference-guide/inspecting-queries"},p=void 0,s={unversionedId:"reference-guide/optimizing-queries/inspecting-queries",id:"version-2.2.1/reference-guide/optimizing-queries/inspecting-queries",title:"Inspecting queries",description:"Before a Cypher query is executed, it is converted into an internal form",source:"@site/memgraph_versioned_docs/version-2.2.1/reference-guide/optimizing-queries/inspecting-queries.md",sourceDirName:"reference-guide/optimizing-queries",slug:"/reference-guide/inspecting-queries",permalink:"/docs/memgraph/reference-guide/inspecting-queries",editUrl:"https://github.com/memgraph/docs/tree/master/memgraph_versioned_docs/version-2.2.1/reference-guide/optimizing-queries/inspecting-queries.md",tags:[],version:"2.2.1",frontMatter:{id:"inspecting-queries",title:"Inspecting queries",sidebar_label:"Inspecting queries",slug:"/reference-guide/inspecting-queries"},sidebar:"memgraph",previous:{title:"Indexing",permalink:"/docs/memgraph/reference-guide/indexing"},next:{title:"Profiling queries",permalink:"/docs/memgraph/reference-guide/profiling-queries"}},c={},u=[{value:"Where to next?",id:"where-to-next",level:2}],d={toc:u};function m(e){var n=e.components,t=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,r.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Before a Cypher query is executed, it is converted into an internal form\nsuitable for execution, known as a ",(0,o.kt)("em",{parentName:"p"},"plan"),". A plan is a tree-like data structure\ndescribing a pipeline of operations which will be performed on the database in\norder to yield the results for a given query. Every node within a plan is known\nas a ",(0,o.kt)("em",{parentName:"p"},"logical operator")," and describes a particular operation."),(0,o.kt)("p",null,"Because a plan represents a pipeline, the logical operators are iteratively\nexecuted as data passes from one logical operator to the other. Every logical\noperator ",(0,o.kt)("em",{parentName:"p"},"pulls")," data from the logical operator(s) preceding it, processes it\nand passes it onto the logical operator next in the pipeline for further\nprocessing."),(0,o.kt)("p",null,"Using the ",(0,o.kt)("inlineCode",{parentName:"p"},"EXPLAIN")," operator, it is possible for the user to inspect the\nproduced plan and gain insight into the execution of a query. Currently, the\nvarious logical operators aren't fully documented as their behavior is subject\nto change. However, the behavior of most of them can be deduced from their name.\nIn the future, additional information might be added to the output of the\n",(0,o.kt)("inlineCode",{parentName:"p"},"EXPLAIN")," operator."),(0,o.kt)("p",null,"As an example, let's inspect the plan produced for a simple query:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cypher"},"EXPLAIN MATCH (n) RETURN n;\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"+----------------+\n| QUERY PLAN     |\n+----------------+\n|  * Produce {n} |\n|  * ScanAll (n) |\n|  * Once        |\n+----------------+\n")),(0,o.kt)("p",null,"The output of the ",(0,o.kt)("inlineCode",{parentName:"p"},"EXPLAIN")," query is a representation of the produced plan. Every\nlogical operator within the plan starts with an asterisk character (",(0,o.kt)("inlineCode",{parentName:"p"},"*"),") and is\nfollowed by its name (and sometimes additional information). The execution of\nthe query proceeds iteratively (generating one entry of the result set at a\ntime), with data flowing from the bottom-most logical operator(s) (the start of\nthe pipeline) to the top-most logical operator(s) (the end of the pipeline)."),(0,o.kt)("p",null,"In the example above, the resulting plan is a pipeline of 3 logical operators.\n",(0,o.kt)("inlineCode",{parentName:"p"},"Once")," is the identity logical operator which does nothing and is always found\nat the start of the pipeline; ",(0,o.kt)("inlineCode",{parentName:"p"},"ScanAll")," is a logical operator which iteratively\nproduces all of the nodes in the graph; and ",(0,o.kt)("inlineCode",{parentName:"p"},"Produce")," is a logical operator\nwhich takes data produced by another logical operator and produces data for the\nquery's result set."),(0,o.kt)("p",null,"A slightly more complicated example would be:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cypher"},"EXPLAIN MATCH (n :Node)-[:Edge]-(m :Node) WHERE n.prop = 42 RETURN *;\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"+--------------------------------+\n| QUERY PLAN                     |\n+--------------------------------+\n|  * Produce {m, n}              |\n|  * Filter                      |\n|  * Expand (m)-[anon1:Edge]-(n) |\n|  * ScanAllByLabel (n :Node)    |\n|  * ScanAllByLabel (m :Node)    |\n|  * Once                        |\n+--------------------------------+\n")),(0,o.kt)("p",null,"In this example, the ",(0,o.kt)("inlineCode",{parentName:"p"},"Filter")," logical operator is used to filter the matched\nnodes because of the ",(0,o.kt)("inlineCode",{parentName:"p"},"WHERE n.prop = 42")," construct. The ",(0,o.kt)("inlineCode",{parentName:"p"},"Expand")," logical\noperator is used to find an edge between two nodes, in this case ",(0,o.kt)("inlineCode",{parentName:"p"},"m")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"n"),"\nwhich were matched previously using the ",(0,o.kt)("inlineCode",{parentName:"p"},"ScanAllByLabel")," logical operator (a\nvariant of the ",(0,o.kt)("inlineCode",{parentName:"p"},"ScanAll")," logical operator mentioned previously)."),(0,o.kt)("p",null,"The execution of the query proceeds iteratively as follows. First, two vertices\nof type ",(0,o.kt)("inlineCode",{parentName:"p"},":Node")," are found as the result of the two scans. Then, we try to find a\npath that consists of the two vertices and an edge between them. If a path is\nfound, it is further filtered based on a property of one of the vertices.\nFinally, if the path satisfied the filter, its two vertices are added to the\nquery's result set."),(0,o.kt)("p",null,"A simple example showcasing the fully general tree structure of the plan could\nbe:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cypher"},"EXPLAIN MERGE (n) RETURN n;\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"+------------------+\n| QUERY PLAN       |\n+------------------+\n|  * Produce {n}   |\n|  * Accumulate    |\n|  * Merge         |\n|  |\\ On Match     |\n|  | * ScanAll (n) |\n|  | * Once        |\n|  |\\ On Create    |\n|  | * CreateNode  |\n|  | * Once        |\n|  * Once          |\n+------------------+\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Merge")," logical operator (constructed as a result of the ",(0,o.kt)("inlineCode",{parentName:"p"},"MERGE")," construct)\ncan take input from up to 3 places. The ",(0,o.kt)("inlineCode",{parentName:"p"},"On Match")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"On Create"),' branches are\n"pulled from" only if a match was found or if a new vertex has to be created,\nrespectively.'),(0,o.kt)("h2",{id:"where-to-next"},"Where to next?"),(0,o.kt)("p",null,"To learn more about Memgraph's functionalities, visit the ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("a",{parentName:"strong",href:"/docs/memgraph/reference-guide"},"Reference guide")),".\nFor real-world examples of how to use Memgraph, we strongly suggest going through one of the available ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("a",{parentName:"strong",href:"/docs/memgraph/tutorials"},"Tutorials")),"."))}m.isMDXComponent=!0}}]);