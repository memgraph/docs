"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[46680],{3905:function(e,t,n){n.d(t,{Zo:function(){return s},kt:function(){return h}});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=r.createContext({}),c=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},s=function(e){var t=c(e.components);return r.createElement(p.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,p=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),u=c(n),h=a,m=u["".concat(p,".").concat(h)]||u[h]||d[h]||o;return n?r.createElement(m,i(i({ref:t},s),{},{components:n})):r.createElement(m,i({ref:t},s))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=u;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},18719:function(e,t,n){n.r(t),n.d(t,{assets:function(){return s},contentTitle:function(){return p},default:function(){return h},frontMatter:function(){return l},metadata:function(){return c},toc:function(){return d}});var r=n(87462),a=n(63366),o=(n(67294),n(3905)),i=["components"],l={id:"implement-custom-query-module-in-python",title:"Implement a custom query module in Python",sidebar_label:"Implement a custom query module in Python"},p=void 0,c={unversionedId:"tutorials/implement-custom-query-module-in-python",id:"version-2.3.0/tutorials/implement-custom-query-module-in-python",title:"Implement a custom query module in Python",description:"[![Related - How",source:"@site/memgraph_versioned_docs/version-2.3.0/tutorials/implement-custom-query-module-in-python.md",sourceDirName:"tutorials",slug:"/tutorials/implement-custom-query-module-in-python",permalink:"/docs/memgraph/2.3.0/tutorials/implement-custom-query-module-in-python",editUrl:"https://github.com/memgraph/docs/tree/master/memgraph_versioned_docs/version-2.3.0/tutorials/implement-custom-query-module-in-python.md",tags:[],version:"2.3.0",frontMatter:{id:"implement-custom-query-module-in-python",title:"Implement a custom query module in Python",sidebar_label:"Implement a custom query module in Python"},sidebar:"memgraph",previous:{title:"Graph modeling",permalink:"/docs/memgraph/2.3.0/tutorials/graph-modeling"},next:{title:"Install Memgraph on Windows 10",permalink:"/docs/memgraph/2.3.0/tutorials/install-memgraph-windows-10"}},s={},d=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Data model",id:"data-model",level:2},{value:"Preparing Memgraph",id:"preparing-memgraph",level:2},{value:"Goals",id:"goals",level:2},{value:"Python API",id:"python-api",level:2},{value:"Read procedure",id:"read-procedure",level:2},{value:"Testing the read procedure",id:"testing-the-read-procedure",level:3},{value:"Detecting errors",id:"detecting-errors",level:2},{value:"Write procedure",id:"write-procedure",level:2},{value:"The city and country nodes already exist",id:"the-city-and-country-nodes-already-exist",level:3},{value:"The country node exists but the city node doesn&#39;t",id:"the-country-node-exists-but-the-city-node-doesnt",level:3},{value:"Neither the country node nor the city node exist",id:"neither-the-country-node-nor-the-city-node-exist",level:3},{value:"Testing the write procedure",id:"testing-the-write-procedure",level:3},{value:"Where to next?",id:"where-to-next",level:2}],u={toc:d};function h(e){var t=e.components,l=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,r.Z)({},u,l,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"/docs/memgraph/2.3.0/how-to-guides/query-modules"},(0,o.kt)("img",{parentName:"a",src:"https://img.shields.io/static/v1?label=Related&message=How-to&color=blue&style=for-the-badge",alt:"Related - How\nto"})),"\n",(0,o.kt)("a",{parentName:"p",href:"/docs/memgraph/2.3.0/reference-guide/query-modules"},(0,o.kt)("img",{parentName:"a",src:"https://img.shields.io/static/v1?label=Related&message=Reference%20Guide&color=yellow&style=for-the-badge",alt:"Related - Reference\nGuide"}))),(0,o.kt)("p",null,"This tutorial will give you a basic idea of how to develop a custom query module\nin Python with Memgraph Lab 2.0 and use it on a dataset."),(0,o.kt)("p",null,"In short, query modules allow you to expand the Cypher query module with various\nprocedures. Procedures can be written in Python or C languages. Our MAGE library\nhas various modules dealing with complex graph algorithms, but you can implement\nyour own procedures gathered in query modules to optimize your queries. If you\nneed more information about what query modules are, please read our ",(0,o.kt)("a",{parentName:"p",href:"/docs/memgraph/2.3.0/reference-guide/query-modules"},"reference\nguide on query modules"),"."),(0,o.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,o.kt)("p",null,"In order to start developing a custom query you will need:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/docs/memgraph/2.3.0/installation"},"Memgraph Platform")),(0,o.kt)("li",{parentName:"ul"},"Visual Studio Code or a code editor of your choice")),(0,o.kt)("h2",{id:"data-model"},"Data model"),(0,o.kt)("p",null,"For this tutorial, we will use the Europe backpacking data model with the data\nfrom The European Backpacker Index (2018). The data set contains information\nabout 56 cities from 36 European countries, such as what cities are close, what\ncountries border each other, various pricing and recommended accommodation."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Backpacking",src:n(11389).Z,width:"845",height:"671"})),(0,o.kt)("details",null,(0,o.kt)("summary",null,"A detailed explanation of the data model"),(0,o.kt)("p",null,"Nodes:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Country")," - country with the following properties (example of the value):",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"id")," - country's id (",(0,o.kt)("inlineCode",{parentName:"li"},"5"),")"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"name")," - country's name (",(0,o.kt)("inlineCode",{parentName:"li"},'"Spain"'),")"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"City")," - city with the following properties (example of the value):",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"name")," - city's name (",(0,o.kt)("inlineCode",{parentName:"li"},'"Barcelona"'),")"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"country")," - country's name (",(0,o.kt)("inlineCode",{parentName:"li"},'"Spain"'),")"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"cheapest_hostel")," - the cheapest hostel in the city (",(0,o.kt)("inlineCode",{parentName:"li"},'"Amistat Beach Hostel\nBarcelona"'),")"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"hostel_url")," - URL of the cheapest hostel in the city\n(",(0,o.kt)("inlineCode",{parentName:"li"},'"https://www.priceoftravel.com/ABarcelonaHostel"'),")"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"rank")," - the cheapest hostel's rank according to The European Backpacker\nIndex (",(0,o.kt)("inlineCode",{parentName:"li"},"38"),")"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"local_currency")," - the name of the local currency (",(0,o.kt)("inlineCode",{parentName:"li"},'"Euro"'),")"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"local_currency_code")," - ISO3 code of the local currency (",(0,o.kt)("inlineCode",{parentName:"li"},'"EUR"'),")"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"total_USD")," - total daily cost including accommodation, attractions,\nmeals/drinks and transportation in USD (",(0,o.kt)("inlineCode",{parentName:"li"},"80.104"),")"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"cost_per_night_USD")," - daily cost of the cheapest hostel per night in USD\n(",(0,o.kt)("inlineCode",{parentName:"li"},"23.684"),")"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"attractions_USD")," - daily cost of the attractions in USD (",(0,o.kt)("inlineCode",{parentName:"li"},"16.12"),")"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"meals_USD")," - daily cost of the meals in USD (",(0,o.kt)("inlineCode",{parentName:"li"},"23.808"),")"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"drinks_USD")," - daily cost of the drinks in USD (",(0,o.kt)("inlineCode",{parentName:"li"},"11.16"),")"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"transportation_USD")," - daily cost of the transportation in USD (",(0,o.kt)("inlineCode",{parentName:"li"},"5.332"),")")))),(0,o.kt)("p",null,"Relationships:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},":Inside")," - connects ",(0,o.kt)("inlineCode",{parentName:"li"},"City")," node to the ",(0,o.kt)("inlineCode",{parentName:"li"},"Country")," node if the city is within\nthe country"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},":CloseTo")," - connects two ",(0,o.kt)("inlineCode",{parentName:"li"},"City")," nodes if cities are from the same or\nneighboring countries",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"eu_border")," - relationship property that indicates whether the EU border\nneeds to be crossed to reach the other city (",(0,o.kt)("inlineCode",{parentName:"li"},"true"),")"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},":Borders")," - connects two ",(0,o.kt)("inlineCode",{parentName:"li"},"Country")," nodes if they are neighboring countries.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"eu_border")," - relationship property that indicates whether the EU border\nneeds to be crossed to reach the other country (",(0,o.kt)("inlineCode",{parentName:"li"},"true"),")"))))),(0,o.kt)("p",null,"In this tutorial, we will mostly focus on the two nodes, ",(0,o.kt)("inlineCode",{parentName:"p"},":City")," and ",(0,o.kt)("inlineCode",{parentName:"p"},":Country"),",\nand their ",(0,o.kt)("inlineCode",{parentName:"p"},":Inside")," relationship."),(0,o.kt)("h2",{id:"preparing-memgraph"},"Preparing Memgraph"),(0,o.kt)("p",null,"Let's open Memgraph Lab where we will import the dataset, as well as write and\nuse the procedures from our query module."),(0,o.kt)("p",null,"If you have successfully installed Memgraph Platform, you should be able to open\nMemgraph Lab in a browser at ",(0,o.kt)("a",{parentName:"p",href:"http://localhost:3000/"},(0,o.kt)("inlineCode",{parentName:"a"},"http://localhost:3000/")),".\nNavigate to the ",(0,o.kt)("strong",{parentName:"p"},"Datasets")," menu item, click on the ",(0,o.kt)("strong",{parentName:"p"},"Europe backpacking"),"\ndataset to import it into Memgraph. You can also check the details of the\ndataset by clicking on ",(0,o.kt)("strong",{parentName:"p"},"Quick View")),(0,o.kt)("img",{src:n(10821).Z,className:"imgBorder"}),(0,o.kt)("p",null,"Go to the ",(0,o.kt)("strong",{parentName:"p"},"Query Execution")," and try running a test query that will show\nthe city Vienna and all its relationships:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-Cypher"},'MATCH p=(:City {name: "Vienna"})-[]-()\nRETURN (p);\n')),(0,o.kt)("img",{src:n(6082).Z,className:"imgBorder"}),(0,o.kt)("p",null,"You can click on the ",(0,o.kt)("inlineCode",{parentName:"p"},":City")," nodes to check the nodes' properties and get better\nacquainted with the dataset. We will come back to this view every time we want\nto test our query modules in making."),(0,o.kt)("img",{src:n(360).Z,className:"imgBorder"}),(0,o.kt)("p",null,"Now navigate to ",(0,o.kt)("strong",{parentName:"p"},"Query Modules"),". Here you can see all the query modules\navailable in Memgraph, such as utility modules or query modules from the MAGE\nlibrary. To create a new custom query module, click on the ",(0,o.kt)("strong",{parentName:"p"},"New Module"),"\nbutton, give the new module name ",(0,o.kt)("inlineCode",{parentName:"p"},"backpacking")," and create the module. Memgraph\nLab creates sample procedures to kick off your development. But before we start,\nlet's decide how we will expand the query language."),(0,o.kt)("img",{src:n(46738).Z,className:"imgBorder"}),(0,o.kt)("h2",{id:"goals"},"Goals"),(0,o.kt)("p",null,"Before we start to write a query module and procedures within, we need goals.\nHow do we want to expand the query language?"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Goal 1:")," We want to get a total cost of accommodation expenses for one night\nat the cheapest hostel in a given city, based on the number of adults and\nchildren that will be staying in it."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Goal 2:")," We also want to expand the data model by a given country and city.\nThe new ",(0,o.kt)("inlineCode",{parentName:"p"},"City")," node should get properties that it shares with the other cities\nin that country, such as ",(0,o.kt)("inlineCode",{parentName:"p"},"country"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"local_currency")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"local_currency_code"),"."),(0,o.kt)("h2",{id:"python-api"},"Python API"),(0,o.kt)("p",null,"Python API is defined in the ",(0,o.kt)("inlineCode",{parentName:"p"},"mgp")," module you can find in the Memgraph\ninstallation directory ",(0,o.kt)("inlineCode",{parentName:"p"},"/usr/lib/memgraph/python_support"),". If you are using\nDocker, you can copy the file from the Docker container into your computer for\nfaster access."),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Copy the ",(0,o.kt)("code",null,"mgp")," module from a Docker container"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"1.")," If it's not running, start your Memgraph instance using Docker."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"2.")," Open a new terminal and find the ",(0,o.kt)("inlineCode",{parentName:"p"},"CONTAINER ID")," of the Memgraph Docker\ncontainer:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"docker ps\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"3.")," Position yourself in the local directory where you want to copy the file."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"4.")," Copy a file from the container to your current directory with the\nfollowing command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"docker cp <CONTAINER ID>:/usr/lib/memgraph/python_support/mgp.py mgp.py\n")),(0,o.kt)("p",null,"Be sure to enter the correct CONTAINER ID."),(0,o.kt)("p",null,"Example of a command when copying the ",(0,o.kt)("inlineCode",{parentName:"p"},"mgp.py")," file to the user's desktop:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"C:\\Users\\Vlasta\\Desktop>docker cp 63e35:/usr/lib/memgraph/python_support/mgp.py mgp.py\n"))),(0,o.kt)("p",null,"In essence, Python API is a wrapper around the C API. If you look at row 15 of\nthe new module we've created in Memgraph Lab, you can see you need to import the\n",(0,o.kt)("inlineCode",{parentName:"p"},"mgp")," module at the beginning of every query module."),(0,o.kt)("p",null,"Below the ",(0,o.kt)("inlineCode",{parentName:"p"},"import mgp"),", in line 17, you can see a ",(0,o.kt)("inlineCode",{parentName:"p"},"@read_proc")," decorator. Python\nAPI defines ",(0,o.kt)("inlineCode",{parentName:"p"},"@read_proc"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"@write_proc")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"@transformation_proc")," decorators.\n",(0,o.kt)("inlineCode",{parentName:"p"},"@read_proc")," decorator handles read-only procedures, the ",(0,o.kt)("inlineCode",{parentName:"p"},"@write_proc")," decorator\nhandles procedures that also write to the database, and the\n",(0,o.kt)("inlineCode",{parentName:"p"},"@transformation_proc")," decorator handles data coming from streams."),(0,o.kt)("p",null,"If you look at our two goals, to get the total cost of accommodation, Memgraph\nonly needs to read from the database to get the value of the\n",(0,o.kt)("inlineCode",{parentName:"p"},"cost_per_night_USD"),", while to create new nodes it also needs to write in the\ndatabase."),(0,o.kt)("p",null,"Feel free to examine the examples and tips available in this template, and when\nyou are ready to continue with the tutorial, clear the file so we start writing\nour code from line 1."),(0,o.kt)("p",null,"We'll start with the ",(0,o.kt)("inlineCode",{parentName:"p"},"@read_proc")," decorator to achieve the first goal, then\nwe'll dive into a bit more complicated second goal and its ",(0,o.kt)("inlineCode",{parentName:"p"},"@write_proc"),"."),(0,o.kt)("h2",{id:"read-procedure"},"Read procedure"),(0,o.kt)("p",null,"As we established in the previous chapter, first we need to import the ",(0,o.kt)("inlineCode",{parentName:"p"},"mgp"),"\nmodule and then use the ",(0,o.kt)("inlineCode",{parentName:"p"},"@read_proc")," decorator. Then we will define the\nprocedure by giving it a name and signature, that is, what arguments it needs to\nreceive and what values it will return."),(0,o.kt)("p",null,"The goal of this procedure is to get a total cost of accommodation expenses for\none night at the cheapest hostel in a given city, based on the number of adults\nand children that will be staying in it."),(0,o.kt)("p",null,"So, let's name the procedure ",(0,o.kt)("inlineCode",{parentName:"p"},"total_cost"),". The procedure needs to receive the\nfollowing arguments in order to calculate the total cost of accommodation:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"the whole graph (all the nodes and relationships)"),(0,o.kt)("li",{parentName:"ul"},"the name of the city we are interested in"),(0,o.kt)("li",{parentName:"ul"},"the number of adults staying at the accommodation"),(0,o.kt)("li",{parentName:"ul"},"the number of children.")),(0,o.kt)("p",null,"The graph is passed to the procedure using the ",(0,o.kt)("inlineCode",{parentName:"p"},"ProcCtx")," instance. The name of\nthe city should be a string value, the number of adults an integer, and the\nnumber of children also an integer. Because customers can travel with or without\nchildren, we will define the children variable as optional by giving it a\npossibility to be ",(0,o.kt)("inlineCode",{parentName:"p"},"NULL")," and setting it to a default value of ",(0,o.kt)("inlineCode",{parentName:"p"},"None"),"."),(0,o.kt)("p",null,"Output values are defined as arguments of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Record")," class. We want the\nfunction to return the total cost per night as a float value, and we'll enable\nthe value to be NULL so that the procedure doesn't return an error if the city\ndoesn't have the cost of accommodation as a property and thus can't calculate\nthe total cost of accommodation."),(0,o.kt)("p",null,"After defining the name and signature, the code should look like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"import mgp\n\n@mgp.read_proc\ndef total_cost(context: mgp.ProcCtx,\n               city: mgp.Any[str],\n               adults: mgp.Number[int],\n               children: mgp.Nullable[int] = None,\n               ) -> mgp.Record(Total_cost_per_night = mgp.Nullable[float]):\n")),(0,o.kt)("p",null,"Now we want to go through all the nodes (vertices) in our graph and find only\nthose nodes that have both:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"the property ",(0,o.kt)("inlineCode",{parentName:"li"},"name")," with the same value as the variable ",(0,o.kt)("inlineCode",{parentName:"li"},"city")),(0,o.kt)("li",{parentName:"ol"},"the property ",(0,o.kt)("inlineCode",{parentName:"li"},"cost_pre_night_USD")," with a float value.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'import mgp\n\n@mgp.read_proc\ndef total_cost(context: mgp.ProcCtx,\n              city: mgp.Any[str],\n              adults: mgp.Number[int],\n              children: mgp.Nullable[int] = None,\n              ) -> mgp.Record(Total_cost_per_night = mgp.Nullable[float]):\n\n  for vertex in context.graph.vertices:\n    if vertex.properties["name"] == city and isinstance(vertex.properties.get("cost_per_night_USD"),float):\n')),(0,o.kt)("p",null,"When we find those nodes, we will save the cost of accommodation per night in a\nvariable ",(0,o.kt)("inlineCode",{parentName:"p"},"cost_per_night")," and multiply it with the number of adults to get the\n",(0,o.kt)("inlineCode",{parentName:"p"},"total_cost"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'import mgp\n\n@mgp.read_proc\ndef total_cost(context: mgp.ProcCtx,\n               city: mgp.Any[str],\n               adults: mgp.Number[int],\n               children: mgp.Nullable[int] = None,\n               ) -> mgp.Record(Total_cost_per_night = mgp.Nullable[float]):\n\n  for vertex in context.graph.vertices:\n    if vertex.properties["name"] == city and isinstance(vertex.properties.get("cost_per_night_USD"),float):\n      cost_per_night = vertex.properties.get("cost_per_night_USD")\n      total_cost = cost_per_night * adults\n')),(0,o.kt)("p",null,"Then we need to check if the number of children was given as an argument when\ncalling the procedure in query, and if it was, add half the cost of\naccommodation for each child. At the end, we return the total cost of\naccommodation per night."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'import mgp\n\n@mgp.read_proc\ndef total_cost(context: mgp.ProcCtx,\n               city: mgp.Any[str],\n               adults: mgp.Number[int],\n               children: mgp.Nullable[int] = None,\n               ) -> mgp.Record(Total_cost_per_night = mgp.Nullable[float]):\n\n  for vertex in context.graph.vertices:\n    if vertex.properties["name"] == city and isinstance(vertex.properties.get("cost_per_night_USD"),float):\n      cost_per_night = vertex.properties.get("cost_per_night_USD")\n      total_cost = cost_per_night * adults\n      if children is not None:\n        total_cost += cost_per_night / 2 * children\n      return mgp.Record(Total_cost_per_night = total_cost)\n')),(0,o.kt)("p",null,"If none of the nodes have both the property ",(0,o.kt)("inlineCode",{parentName:"p"},"name")," with the same value as the\nvariable ",(0,o.kt)("inlineCode",{parentName:"p"},"city")," nor the property ",(0,o.kt)("inlineCode",{parentName:"p"},"cost_pre_night_USD")," with a float value, we\nwill set the value of ",(0,o.kt)("inlineCode",{parentName:"p"},"Total_cost_per_night")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"None")," (that is, ",(0,o.kt)("inlineCode",{parentName:"p"},"NULL"),") in\norder to prevent the procedure from generating an error."),(0,o.kt)("p",null,"The finished procedure now looks like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'import mgp\n\n@mgp.read_proc\ndef total_cost(context: mgp.ProcCtx,\n              city: mgp.Any[str],\n              adults: mgp.Number[int],\n              children: mgp.Nullable[int] = None,\n              ) -> mgp.Record(\n                              Total_cost_per_night = mgp.Nullable[float]):\n\n  for vertex in context.graph.vertices:\n    if vertex.properties["name"] == city and isinstance(vertex.properties.get("cost_per_night_USD"),float):\n      cost_per_night = vertex.properties.get("cost_per_night_USD")\n      total_cost = cost_per_night * adults\n      if children is not None:\n        total_cost += cost_per_night / 2 * children\n      return mgp.Record(Total_cost_per_night = total_cost)\n\n  return mgp.Record(Total_cost_per_night = None)\n')),(0,o.kt)("p",null,"Save and close the query module. You will get an overview of the module that\nlists procedures and their signature."),(0,o.kt)("img",{src:n(72723).Z,className:"imgBorder"}),(0,o.kt)("h3",{id:"testing-the-read-procedure"},"Testing the read procedure"),(0,o.kt)("p",null,"Switch to ",(0,o.kt)("strong",{parentName:"p"},"Query Execution")," and call the procedure using the clause ",(0,o.kt)("inlineCode",{parentName:"p"},"CALL"),",\nthen calling the right module and procedure within it\n(",(0,o.kt)("inlineCode",{parentName:"p"},"backpacking.total_cost"),"). List all arguments except the whole graph inside\nbrackets, and at the end YIELD all the results:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cypher"},'CALL backpacking.total_cost("Zagreb", 2, 3) YIELD *;\n')),(0,o.kt)("p",null,"Result -> ",(0,o.kt)("inlineCode",{parentName:"p"},"Total_cost_per_night = 32.129999999999995")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cypher"},'CALL backpacking.total_cost("Vienna", 2) YIELD *;\n')),(0,o.kt)("p",null,"Result -> ",(0,o.kt)("inlineCode",{parentName:"p"},"Total_cost_per_night = 45.012")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cypher"},'CALL backpacking.total_cost("Whatever", 2) YIELD *;\n')),(0,o.kt)("p",null,"Result -> ",(0,o.kt)("inlineCode",{parentName:"p"},"Total_cost_per_night = null")),(0,o.kt)("img",{src:n(14693).Z,className:"imgBorder"}),(0,o.kt)("h2",{id:"detecting-errors"},"Detecting errors"),(0,o.kt)("p",null,"Some errors will be written out as you are trying to call the procedure. Others\ncan be viewed in the log file."),(0,o.kt)("p",null,"If you started your Memgraph Platform image by exposing the ",(0,o.kt)("inlineCode",{parentName:"p"},"7444")," port, you can\ncheck the logs from Memgraph Lab. Otherwise, you need to ",(0,o.kt)("a",{parentName:"p",href:"/docs/memgraph/2.3.0/how-to-guides/config-logs#accessing-logs"},"access the logs in the\nDocker container"),"."),(0,o.kt)("p",null,"But the rest of the errors in the code will result in the procedure not being\ndetected. That means that if you go to the ",(0,o.kt)("strong",{parentName:"p"},"Query Modules")," menu item and check\nmodule details by clicking on the arrow on the right, the procedure with an\nerror will not be listed."),(0,o.kt)("h2",{id:"write-procedure"},"Write procedure"),(0,o.kt)("p",null,"You can continue writing the write procedure below the read procedure. To edit\nthe current module go to ",(0,o.kt)("strong",{parentName:"p"},"Query Modules")," and find the ",(0,o.kt)("inlineCode",{parentName:"p"},"backpacking")," module.\nClick on the arrow to view details about the module, such as the name of the\nprocedures and their signatures. To continue editing the module, click on ",(0,o.kt)("strong",{parentName:"p"},"Edit\ncode"),". If you are writing the write procedure in a new module, don't forget to\nimport the ",(0,o.kt)("inlineCode",{parentName:"p"},"mgp")," module. For the write procedure, we will use the ",(0,o.kt)("inlineCode",{parentName:"p"},"@write_proc"),"\ndecorator."),(0,o.kt)("p",null,"The goal of this write procedure is to expand the data model by a given country\nand city. The new ",(0,o.kt)("inlineCode",{parentName:"p"},"City")," node should get properties that it shares with the\nother cities in that country, such as ",(0,o.kt)("inlineCode",{parentName:"p"},"country"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"local_currency")," and\n",(0,o.kt)("inlineCode",{parentName:"p"},"local_currency_code"),"."),(0,o.kt)("p",null,"Let's name the procedure ",(0,o.kt)("inlineCode",{parentName:"p"},"new_city"),". The procedure needs to receive the\nfollowing arguments in order to create two new nodes and connect them:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"the whole graph (all the nodes and relationships)"),(0,o.kt)("li",{parentName:"ul"},"the name of the city"),(0,o.kt)("li",{parentName:"ul"},"the name of the country.")),(0,o.kt)("p",null,"The graph is passed to the procedure using the ",(0,o.kt)("inlineCode",{parentName:"p"},"ProcCtx")," instance. The names of\nthe city and country should be of string values."),(0,o.kt)("p",null,"Output values are defined as arguments of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Record")," class. We want the\nfunction to return the city and country nodes and their relationship."),(0,o.kt)("p",null,"After defining the name and signature, the code should look like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"@mgp.write_proc\ndef new_city(context: mgp.ProcCtx,\n             in_city: mgp.Nullable[str],\n             in_country: mgp.Nullable[str],\n                    ) -> mgp.Record(City = mgp.Vertex,\n                                    Relationship = mgp.Edge,\n                                    Country = mgp.Vertex):\n")),(0,o.kt)("p",null,"We will gradually expand our code to cover all three cases:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"the city and country nodes already exist"),(0,o.kt)("li",{parentName:"ol"},"the country node exists but the city node doesn't"),(0,o.kt)("li",{parentName:"ol"},"neither the country node nor the city node exist")),(0,o.kt)("h3",{id:"the-city-and-country-nodes-already-exist"},"The city and country nodes already exist"),(0,o.kt)("p",null,"We want to check if the city and country passed as arguments already exist in\nthe database because if they do, there is no need to create them. We can just\nreturn them as a result. Because the ",(0,o.kt)("inlineCode",{parentName:"p"},"City")," nodes also include the ",(0,o.kt)("inlineCode",{parentName:"p"},"country"),"\nproperty, we can only check ",(0,o.kt)("inlineCode",{parentName:"p"},"City")," nodes to find out if a certain city inside a\ncertain country already exists."),(0,o.kt)("p",null,"So let's go through all the nodes (vertices) in the graph to check if there is a\nnode with the ",(0,o.kt)("inlineCode",{parentName:"p"},"country")," property of the same value as the ",(0,o.kt)("inlineCode",{parentName:"p"},"in_country")," argument.\nIf there is, let's check if the ",(0,o.kt)("inlineCode",{parentName:"p"},"name")," property of that nodes is of the same\nvalue as the as the ",(0,o.kt)("inlineCode",{parentName:"p"},"in_city")," argument. If there is, it means there are already\n",(0,o.kt)("inlineCode",{parentName:"p"},"City")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Country")," nodes with the same ",(0,o.kt)("inlineCode",{parentName:"p"},"name")," properties as the ",(0,o.kt)("inlineCode",{parentName:"p"},"in_city")," and\n",(0,o.kt)("inlineCode",{parentName:"p"},"in_country")," arguments."),(0,o.kt)("p",null,"To return the relationship between them, we need to go through all the\nrelationships from the ",(0,o.kt)("inlineCode",{parentName:"p"},"City")," node and find the one with type ",(0,o.kt)("inlineCode",{parentName:"p"},"Inside"),". Then we\nwill save the destination node in the ",(0,o.kt)("inlineCode",{parentName:"p"},"country")," variable, and return both nodes\nand the relationship."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'@mgp.write_proc\ndef new_city(context: mgp.ProcCtx,\n             in_city: mgp.Nullable[str],\n             in_country: mgp.Nullable[str],\n                    ) -> mgp.Record(City = mgp.Vertex,\n                                    Relationship = mgp.Edge,\n                                    Country = mgp.Vertex):\n\n    for v in context.graph.vertices:\n      if v.properties.get("country") == in_country:\n              if v.properties.get("name") == in_city:\n                  for r in v.out_edges:\n                      if r.type == "Inside":\n                          country = r.to_vertex\n                          return mgp.Record(City=v, Relationship=r, Country=country)\n')),(0,o.kt)("p",null,"At this point you can save the module and test the new procedure, by running the\nfollowing query:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cypher"},'CALL backpacking.new_city("Zagreb","Croatia") YIELD *;\n')),(0,o.kt)("img",{src:n(86458).Z,className:"imgBorder"}),(0,o.kt)("h3",{id:"the-country-node-exists-but-the-city-node-doesnt"},"The country node exists but the city node doesn't"),(0,o.kt)("p",null,"In the case that the ",(0,o.kt)("inlineCode",{parentName:"p"},"Country")," node with that name exists, but the ",(0,o.kt)("inlineCode",{parentName:"p"},"City")," node\ndoesn't, we should create a new ",(0,o.kt)("inlineCode",{parentName:"p"},"City")," node, and connect it with the existing\n",(0,o.kt)("inlineCode",{parentName:"p"},"Country")," node. Because the ",(0,o.kt)("inlineCode",{parentName:"p"},"City")," nodes have properties about the country they\nare connected to, we will use the existing ",(0,o.kt)("inlineCode",{parentName:"p"},"City")," nodes to copy property values\nto the new ",(0,o.kt)("inlineCode",{parentName:"p"},"City")," node, such as ",(0,o.kt)("inlineCode",{parentName:"p"},"local_currency")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"local_currency_code"),"."),(0,o.kt)("p",null,"The new ",(0,o.kt)("inlineCode",{parentName:"p"},"City")," node also has to get a new ",(0,o.kt)("inlineCode",{parentName:"p"},"id")," number, that's why we will save\nthe highest existing ",(0,o.kt)("inlineCode",{parentName:"p"},"id")," among ",(0,o.kt)("inlineCode",{parentName:"p"},"City")," nodes in the ",(0,o.kt)("inlineCode",{parentName:"p"},"city_id")," and increase that\nnumber by 1 to get the ID of the new ",(0,o.kt)("inlineCode",{parentName:"p"},"City")," node. Now that we have created a new\n",(0,o.kt)("inlineCode",{parentName:"p"},"City")," node, we need to create a relationship to connect it with the existing\n",(0,o.kt)("inlineCode",{parentName:"p"},"Country")," node and return both nodes and the relationship."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'@mgp.write_proc\ndef new_city(context: mgp.ProcCtx,\n             in_city: mgp.Nullable[str],\n             in_country: mgp.Nullable[str],\n                    ) -> mgp.Record(City = mgp.Vertex,\n                                    Relationship = mgp.Edge,\n                                    Country = mgp.Vertex):\n\n    city_id = 0\n    currency = None\n    currency_code = None\n\n    for v in context.graph.vertices:\n      label, = v.labels # get node label\n      if (label == "City") and (v.properties.get("id") > city_id): # the following 2 lines are getting the highest ID\n          city_id = v.properties.get("id")\n      if v.properties.get("country") == in_country:\n              currency = v.properties.get("local_currency") # the following 2 lines are saving property values\n              currency_code = v.properties.get("local_currency_code")\n              if v.properties.get("name") == in_city:\n                  for r in v.out_edges:\n                      if r.type == "Inside":\n                          country = r.to_vertex\n                          return mgp.Record(City=v, Relationship=r, Country=country)\n\n    city = context.graph.create_vertex() # creating a new node with properties\n    city.add_label("City")\n    city.properties.set("id", city_id + 1)\n    city.properties.set("name", in_city)\n    city.properties.set("country", in_country)\n    city.properties.set("local_currency", currency)\n    city.properties.set("local_currency_code", currency_code)\n\n    for v in context.graph.vertices: # creating a new relationship to an existing country\n            if v.properties.get("name") == in_country:\n                context.graph.create_edge(city, v, mgp.EdgeType("Inside"))\n                for r in city.out_edges:\n                    if r.type == "Inside":\n                        return mgp.Record(City=city, Relationship=r, Country=v)\n')),(0,o.kt)("p",null,"At this point you can save the module and test the new additions to the\nprocedure, by running the following query:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cypher"},'CALL backpacking.new_city("Makarska","Croatia") YIELD *;\n')),(0,o.kt)("img",{src:n(74724).Z,className:"imgBorder"}),(0,o.kt)("h3",{id:"neither-the-country-node-nor-the-city-node-exist"},"Neither the country node nor the city node exist"),(0,o.kt)("p",null,"Lastly, in the case there is no ",(0,o.kt)("inlineCode",{parentName:"p"},"City")," node nor ",(0,o.kt)("inlineCode",{parentName:"p"},"Country")," node with the ",(0,o.kt)("inlineCode",{parentName:"p"},"name"),"\nproperties the same as the provided arguments, we need to create both."),(0,o.kt)("p",null,"That is why we also need to find the largest ID among the ",(0,o.kt)("inlineCode",{parentName:"p"},"Country")," nodes.\nBecause we only need to create a new ",(0,o.kt)("inlineCode",{parentName:"p"},"Country")," node if one doesn't exist, we\nwill introduce a ",(0,o.kt)("inlineCode",{parentName:"p"},"country_exists")," variable with a default value ",(0,o.kt)("inlineCode",{parentName:"p"},"False"),". The\nvalue of that flag will change to ",(0,o.kt)("inlineCode",{parentName:"p"},"True")," only if both the Country node with the\n",(0,o.kt)("inlineCode",{parentName:"p"},"name")," property the same as the ",(0,o.kt)("inlineCode",{parentName:"p"},"in_country")," argument exists."),(0,o.kt)("p",null,"This is also the finished procedure:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'@mgp.write_proc\ndef new_city(context: mgp.ProcCtx,\n             in_city: mgp.Nullable[str],\n             in_country: mgp.Nullable[str],\n                    ) -> mgp.Record(City = mgp.Vertex,\n                                    Relationship = mgp.Edge,\n                                    Country = mgp.Vertex):\n\n    in_country_exists = False\n    country_id = 0\n    city_id = 0\n    currency = None\n    currency_code = None\n\n    for v in context.graph.vertices:\n      label, = v.labels # get node label\n      if (label == "City") and (v.properties.get("id") > city_id): # the following 4 lines are getting the highest IDs\n          city_id = v.properties.get("id")\n      if (label == "Country") and (v.properties.get("id") > country_id):\n          country_id = v.properties.get("id")\n      if v.properties.get("country") == in_country:\n              country_exists = True # flag is changed to `True`\n              currency = v.properties.get("local_currency")\n              currency_code = v.properties.get("local_currency_code")\n              if v.properties.get("name") == in_city:\n                  for r in v.out_edges:\n                      if r.type == "Inside":\n                          country = r.to_vertex\n                          return mgp.Record(City=v, Relationship=r, Country=country)\n\n    city = context.graph.create_vertex() # creating a new node with properties\n    city.add_label("City")\n    city.properties.set("id", city_id + 1)\n    city.properties.set("name", in_city)\n    city.properties.set("country", in_country)\n    city.properties.set("local_currency", currency)\n    city.properties.set("local_currency_code", currency_code)\n\n    if in_country_exists == True: # creating a relationship if the country node exist\n      for v in context.graph.vertices: # creating a new relationship to an existing country\n              if v.properties.get("name") == in_country:\n                  context.graph.create_edge(city, v, mgp.EdgeType("Inside"))\n                  for r in city.out_edges:\n                      if r.type == "Inside":\n                          return mgp.Record(City=city, Relationship=r, Country=v)\n\n    if in_country_exists == False: # creating a node and relationship if the country node doesn\'t exist\n        new_country = context.graph.create_vertex()\n        new_country.add_label("Country")\n        new_country.properties.set("id", country_id + 1)\n        new_country.properties.set("name", in_country)\n        context.graph.create_edge(city, new_country, mgp.EdgeType("Inside"))\n        for r in city.out_edges:\n                    if r.type == "Inside":\n                        return mgp.Record(City=city, Relationship=r, Country=new_country)\n')),(0,o.kt)("h3",{id:"testing-the-write-procedure"},"Testing the write procedure"),(0,o.kt)("p",null,"Save the query module, switch to ",(0,o.kt)("strong",{parentName:"p"},"Query Execution")," and call the procedure\nusing the clause ",(0,o.kt)("inlineCode",{parentName:"p"},"CALL"),", then calling the right module and procedure within it\n(",(0,o.kt)("inlineCode",{parentName:"p"},"backpacking.new_city"),"). List all arguments except the whole graph inside\nbrackets, and at the end ",(0,o.kt)("inlineCode",{parentName:"p"},"YIELD")," all the results:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cypher"},'CALL backpacking.new_city("Zagreb", "Croatia") YIELD *;\n')),(0,o.kt)("p",null,"The query returns existing ",(0,o.kt)("inlineCode",{parentName:"p"},"City")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Country")," nodes."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cypher"},'CALL backpacking.new_city("Vinkovci", "Croatia") YIELD *;\n')),(0,o.kt)("p",null,"The query returns new ",(0,o.kt)("inlineCode",{parentName:"p"},"City")," node connected to an existing ",(0,o.kt)("inlineCode",{parentName:"p"},"Country")," node."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cypher"},'CALL backpacking.new_city("Vinkovci", "Makroland") YIELD *;\n')),(0,o.kt)("p",null,"The query returns a new ",(0,o.kt)("inlineCode",{parentName:"p"},"City")," node connected to a new ",(0,o.kt)("inlineCode",{parentName:"p"},"Country")," node."),(0,o.kt)("h2",{id:"where-to-next"},"Where to next?"),(0,o.kt)("p",null,"Congratulations! You've written your first custom query module! Feel free to\nplay around with the Python API and let us know what you are working on through\nour ",(0,o.kt)("a",{parentName:"p",href:"https://discord.gg/memgraph"},"Discord server"),"."))}h.isMDXComponent=!0},86458:function(e,t,n){t.Z=n.p+"assets/images/existing-101b9034ba38b7124e40816ab7c1f242.png"},10821:function(e,t,n){t.Z=n.p+"assets/images/import-dataset-b56d2b2e9a81249d41c2381510aacc34.png"},72723:function(e,t,n){t.Z=n.p+"assets/images/module-details-8634146a326979476d8a65bdc497ac63.png"},46738:function(e,t,n){t.Z=n.p+"assets/images/new-module-500ca16d76b70050fad71e2a8cb631b9.png"},74724:function(e,t,n){t.Z=n.p+"assets/images/no-city-c06f9186534bb14c838141dcd589b59e.png"},14693:function(e,t,n){t.Z=n.p+"assets/images/total-cost-b3c6879c8c3b8ab1616a856e0d3d7c0a.png"},360:function(e,t,n){t.Z=n.p+"assets/images/vienna-details-8d023abe982e924706c61c4c2d96226c.png"},6082:function(e,t,n){t.Z=n.p+"assets/images/vienna-12746b6ab333ec0f9929cc3b0afe764e.png"},11389:function(e,t,n){t.Z=n.p+"assets/images/backpacking_metagraph-50976049aa85a582ed0afc3e921187f2.png"}}]);